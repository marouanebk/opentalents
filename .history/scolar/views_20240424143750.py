# Create your views here.
# Comment GitLab Test
from django.shortcuts import render, get_object_or_404
from django_tables2.config import RequestConfig
import threading
from django.db import transaction
from django.template import loader
import requests
from scolar.models import *
import os
from django.utils.safestring import mark_safe
from scolar.tables import OrganismeTable, OrganismeFilter, PFETable, PFEFilter, ValidationTable, MatiereTable, MatiereFilter, InscriptionEtudiantDocumentsTable, InscriptionEtudiantTable, InscriptionFilter, InscriptionGroupeTable, InscriptionTable,\
    EvaluationCompetenceElementTable, EvaluationTable, AbsenceEnseignantFilter,  AbsenceEnseignantTable, AbsenceEtudiantFilter, AbsenceEtudiantTable, ActiviteChargeConfigTable, \
    CompetenceElementTable, CompetenceFamilyTable, CompetenceTable, MatiereCompetenceElementTable, DiplomeTable, CycleTable, AutoriteTable, SpecialiteTable, PeriodeTable, DeliberationFormationTable, PVFilter, \
    ProgrammeTable, FormationTable, PlanificationTable, EtudiantFilter,  EtudiantTable, EnseignantFilter, EnseignantTable, SectionTable, FormationFilter, \
    GroupeAllFilter, GroupeAllTable, GroupeTable, NotesFormationTable, TutoratTable, ModuleFeedbackTable, ModuleFilter, ModuleTable, ChargeEnseignantTable, PVTable, PVEnseignantTable,\
    CoordinationModuleFilter, SemainierTable, FeedbackTable, AnneeUnivTable, SeanceTable, ActiviteEtudiantFilter, ActiviteEtudiantTable, ActiviteTable, ActiviteFilter,\
    PreinscriptionTable, ResidenceUnivTable, PreinscriptionFilter, ExamenTable, ExamenFilter, SalleFilter, SalleTable, PlaceEtudiantFilter, PlaceEtudiantTable,\
    SurveillanceFilter, SurveillanceTable, EnseignementsTable,EncadrementsTable,EncadrementsAttestationTable, SoutenancesAttestationTable, ProgresFormationTable, TraceTable, TraceFilter,\
    NotificationsTable, UserTable, ExportTable, DoctorantTable, DoctorantFilter, TheseFilter, TheseTable, ProjetFilter, ProjetTable, ProjetsEnseignantTable, CritereTable, OptionCritereTable, FormationDoctoratTable, InscriptionDoctoratAvancementTable, SeminairesFilter, SeminairesTable, \
    DomaineConnaissanceTable, PosteTable, PosteFilter, ProgrammeDetteTable, DetteFilter, DetteTable, UserFilter, PersonnelTable, PaysTable, WilayaTable, CommuneTable, SurveillancesEnseignantFilter, EnregistrementEtudiantTable, EnregistrementEtudiantFilter, EquipeRechercheFilter, EquipeRechercheTable, EquipeRechercheEnseignantTable, ExpertisesPFEAttestationTable, OffreFilter, OffreTable, CandidatureTable, \
    GoogleCalenderTable, GoogleCalenderFilter,CPTable,RessourceTable,AllocationTable
from functools import reduce
from django.contrib.messages.views import SuccessMessageMixin
from django.core.mail import EmailMessage, send_mass_mail
from django.views.generic.base import TemplateView
from django.db.models.signals import post_save, m2m_changed, post_delete, pre_delete
from django.db.models import Q, Count, Sum, When, Value, Case, F, Max, Min, Avg, OuterRef, Subquery
from django.db.models.functions import Cast, StrIndex, Substr
from django.dispatch import receiver
from scolar.forms import EnseignantDetailForm, AbsenceEtudiantReportSelectionForm, SeanceEtudiantSelectionForm, OTPImportFileForm, PFEDetailForm, OrganismeForm, SelectOrCreateOrganismeForm, COMPETENCE_EVAL, InscriptionUpdateForm, SelectChargeConfigForm, SelectPVSettingsForm, ChargeFilterForm, EvaluationCompetenceForm, NotesPFEUpdateForm, SeanceSelectionForm, PlanificationImportFileForm, EDTForm, CompetenceForm, FeedbackUpdateForm, SelectModuleForm, ReleveNotesUpdateForm, ImportDeliberationForm, AbsencesForm, ImportNotesForm, NotesUpdateForm, ImportFileForm, ImportAffectationForm, MatiereFormHelper, ImportFeedbackForm,\
     SelectionFormationForm, SelectSingleModuleForm, ImportAffectationDiplomeForm, ImportChargeForm, SelectPVAnnuelSettingsForm,DateSelectForm,\
    CommissionValidationCreateForm, ExamenCreateForm, SeanceSallesReservationForm, SurveillanceUpdateForm, InstitutionDetailForm,\
    SelectionInscriptionForm, ValidationPreInscriptionForm, EDTImportFileForm, EDTSelectForm, ExamenSelectForm, AffichageExamenSelectForm,\
    SalleConfigForm, ExamenUpdateForm, ExamenListSelectForm, AbsenceEtudiantSelectForm, SurveillanceListSelectForm, PartenaireCreateForm, ReservationPlaceEtudiantUpdateForm, PermissionsUpdateForm, UserChoiceForm, PermissionsUserUpdateForm, IntervalleDateSelectForm, DoctorantCreateForm, DoctorantUpdateForm, TheseCreateForm, TheseUpdateForm, TheseDetailForm, ProjetDetailForm, EtatAvancementCreateForm, EtatAvancementUpdateJuryForm, EvaluationEtatAvancementForm, SeminaireCreateForm, SeminaireDetailForm, SeminaireUpdateForm, DocumentsConfigUpdateForm, PassageSettingsForm, DetteUpdateForm, UserCreateForm, UserUpdateForm,\
    PasswordUpdateForm, EtudiantMatriculeUpdateForm, EnregistrementEtudiantCreateForm, EnregistrementEtudiantUpdateForm, SelectionEtudiantForm, EquipeRechercheDetailForm, SelectOrCreateOrganismeOffreForm, OffreDetailForm, CandidatureDetailForm, DemandeCompteForm , OrdreDuJourForm 

#from scolar.forms import *
from django.http import HttpResponseRedirect, HttpResponse, HttpResponseNotFound, Http404, HttpResponseForbidden
from django.views.generic.edit import CreateView, DeleteView, UpdateView
from crispy_forms.helper import FormHelper
from crispy_forms.layout import Submit, HTML, Button
from crispy_forms.bootstrap import TabHolder, Tab
from django.urls import reverse
from django import forms
from django.views.generic.detail import DetailView
from django.views.generic.list import ListView
import random
from bootstrap_datepicker_plus import DatePickerInput,TimePickerInput
from scolar.admin import settings
from jchart import Chart
from jchart.config import DataSet
from django.shortcuts import redirect
import urllib
from django.contrib import messages
from tablib import Dataset, Databook
from django_select2.forms import ModelSelect2Widget, Select2Widget, ModelSelect2MultipleWidget, Select2MultipleWidget
from django.contrib.auth.mixins import LoginRequiredMixin, UserPassesTestMixin, PermissionRequiredMixin
import datetime
from django.core.files.storage import default_storage
from django.contrib.auth.models import Group, Permission
import decimal
from wkhtmltopdf.views import PDFTemplateView, render_pdf_from_template
from django.db.models.aggregates import Avg
from django.contrib.auth.decorators import user_passes_test, permission_required,\
    login_required

from django.db.models.expressions import ExpressionWrapper
from django.db.models.fields import FloatField, DecimalField
import re, string
import operator
from _ast import If, In
from django.core.exceptions import ObjectDoesNotExist
from django.core.files import File

from google_auth_oauthlib.flow import Flow
from googleapiclient.discovery import build
from google.oauth2.credentials import Credentials
from uuid import uuid4
import pytz
from builtins import Exception
from time import sleep
from pyasn1.type.char import VideotexString
from django.http.response import FileResponse
from django.http import HttpResponseForbidden
from scolar.webhelp import *
from django.utils.html import format_html

#Module pour generation du fichier word
from docx import Document
from docx.shared import Inches
from docx.enum.text import WD_PARAGRAPH_ALIGNMENT

import pybase64
import tempfile

from django.views.static import serve
from mimetypes import guess_type
import io

from django.contrib.auth import update_session_auth_hash, login, authenticate
from django.contrib.auth.hashers import check_password

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import serializers

from .models import  Etudiant, Module, AnneeUniv , Programme , PeriodeProgramme , UE , Matiere
from django.http import JsonResponse
from django.forms import modelformset_factory

from django.forms.models import inlineformset_factory



def send_email(context):
    context_default = {
    "cc" : [],
    "signature" : signature_emails()
    }
    context={**context_default,**context}
    template = loader.get_template(f"scolar/emails/{context['template']}")
    email = EmailMessage(
        subject = context["objet"],
        body = template.render(context),
        to = context["destinataires"],
        cc = context["cc"]
    )
    email.content_subtype = "html"
    email.send(fail_silently=True)
    return


def activation_emails():
    try :
        institution_ = Institution.objects.all()
        if institution_.exists():
            institution_=institution_[0]
            return institution_.activation_emails
        else :
            return False
    except Exception :
        raise Exception

def activation_ddc():
    try :
        institution_ = Institution.objects.all()
        if institution_.exists():
            institution_=institution_[0]
            return institution_.activation_ddc
        else :
            return False
    except Exception :
        raise Exception

def activation_competences():
    try :
        institution_ = Institution.objects.all()
        if institution_.exists():
            institution_=institution_[0]
            return institution_.activation_competences
        else :
            return False
    except Exception :
        raise Exception
    
def activation_livret_competences():
    try :
        institution_ = Institution.objects.all()
        if institution_.exists():
            institution_=institution_[0]
            return institution_.activation_livret_competences
        else :
            return False
    except Exception :
        raise Exception

def activation_charges():
    try :
        institution_ = Institution.objects.all()
        if institution_.exists():
            institution_=institution_[0]
            return institution_.activation_charges
        else :
            return False
    except Exception :
        raise Exception

def activation_google_agenda():
    try :
        institution_ = Institution.objects.all()
        if institution_.exists():
            institution_=institution_[0]
            return institution_.activation_google_agenda
        else :
            return False
    except Exception :
        raise Exception

def activation_authentification_google():
    try :
        institution_ = Institution.objects.all()
        if institution_.exists():
            institution_=institution_[0]
            return institution_.activation_authentification_google
        else :
            return False
    except Exception :
        raise Exception

def activation_offres():
    try :
        institution_ = Institution.objects.all()
        if institution_.exists():
            institution_=institution_[0]
            return institution_.activation_offres
        else :
            return False
    except Exception :
        raise Exception

def email_direction():
    try :
        institution_ = Institution.objects.all()
        institution_=institution_[0]
        emails=[]
        exists_=False
        for user_ in institution_.users_direction.all() :
            if user_.get_email() :
                emails = emails + [user_.get_email()] 
                exists_=True
        if not exists_ :
            emails=['']
        return emails
    except Exception :
        raise Exception
    
def email_scolarite():
    try :
        institution_ = Institution.objects.all()
        institution_=institution_[0]
        emails=[]
        exists_=False
        for user_ in institution_.users_scolarite.all() :
            if user_.get_email() :
                emails = emails + [user_.get_email()] 
                exists_=True
        if not exists_ :
            emails=['']
        return emails
    except Exception :
        raise Exception
    
def email_stage():
    try :
        institution_ = Institution.objects.all()
        institution_=institution_[0]
        emails=[]
        exists_=False
        for user_ in institution_.users_stage.all() :
            if user_.get_email() :
                emails = emails + [user_.get_email()] 
                exists_=True
        if not exists_ :
            emails=['']
        return emails
    except Exception :
        raise Exception

def email_futurs_stagiaires():
    try :
        institution_ = Institution.objects.all()
        institution_=institution_[0]
        email_=['']
        if institution_.email_futurs_stagiaires :
            email_ = [institution_.email_futurs_stagiaires]
        return email_
    except Exception :
        raise Exception
    
def email_theses():
    try :
        institution_ = Institution.objects.all()
        institution_=institution_[0]
        emails=[]
        exists_=False
        for user_ in institution_.users_theses.all() :
            if user_.get_email() :
                emails = emails + [user_.get_email()] 
                exists_=True
        if not exists_ :
            emails=['']
        return emails
    except Exception :
        raise Exception
    
def email_offres():
    try :
        institution_ = Institution.objects.all()
        institution_=institution_[0]
        emails=[]
        exists_=False
        for user_ in institution_.users_offres.all() :
            if user_.get_email() :
                emails = emails + [user_.get_email()] 
                exists_=True
        if not exists_ :
            emails=['']
        return emails
    except Exception :
        raise Exception

def email_demandes_comptes():
    try :
        institution_ = Institution.objects.all()
        institution_=institution_[0]
        emails=[]
        exists_=False
        for user_ in institution_.users_demandes_comptes.all() :
            if user_.get_email() :
                emails = emails + [user_.get_email()] 
                exists_=True
        if not exists_ :
            emails=['']
        return emails
    except Exception :
        raise Exception
    
def email_webmaster():
    try :
        institution_ = Institution.objects.all()
        institution_=institution_[0]
        email_=['']
        if institution_.email_webmaster :
            email_ = [institution_.email_webmaster]
        return email_
    except Exception :
        raise Exception
    
def get_institution():
    institution_ = Institution.objects.all()
    if institution_.exists():
        return institution_[0]
    else :
        raise Exception
    
def signature_emails(): 
    institution=get_institution()
    return institution.signature_emails if institution.signature_emails else ''

def users_stage_institution():
    try :
        institution_ = Institution.objects.all()
        institution_=institution_[0]
        return institution_.users_stage.all()
    except Exception :
        return User.objects.none()
    
def users_theses_institution():
    try :
        institution_ = Institution.objects.all()
        institution_=institution_[0]
        return institution_.users_theses.all()
    except Exception :
        return User.objects.none()

def users_offres_institution():
    try :
        institution_ = Institution.objects.all()
        institution_=institution_[0]
        return institution_.users_offres.all()
    except Exception :
        return User.objects.none()

def users_demandes_comptes():
    try :
        institution_ = Institution.objects.all()
        institution_=institution_[0]
        return institution_.users_demandes_comptes.all()
    except Exception :
        return User.objects.none()

    
#source type User
#cible de type User ou Etudiant ou Enseignant ou n'importe quel autre modèle, si le modèle de Cible n'a pas d'attribut User alors la cible sera automatiquement None
#action de type texte
def trace_create(source, cible, action):
    try :
        if source :
            source_text_=source.nom()+' '+source.prenom()
        else :
            source_text_=""
        if cible :
            cible_class=cible.__class__
            if cible_class.__name__ == "User" :
                cible_text_=cible.nom()+' '+cible.prenom()
            else :
                if hasattr(cible_class, 'user') and cible.user :
                    cible_text_=cible.user.nom()+' '+cible.user.prenom()
                    cible=cible.user
                else :
                    if cible_class.__name__ == "Etudiant" :
                        cible_text_=cible.nom+' '+cible.prenom
                    else :
                        cible_text_=str(cible)
                    cible=None
        else :
            cible_text_=""
        trace_= Trace.objects.create(
            source=source,
            source_text=source_text_,
            cible=cible,
            cible_text=cible_text_,
            action=str(action),
                             )
        return trace_
        
    except Exception :
        return False
        
def exclude_columns_etudiant(user):
        exclude_=[]
        if not user.is_authenticated:
            exclude_.append('edit')
            exclude_.append('admin')
        elif user.is_etudiant() :
            exclude_.append('admin')
            exclude_.append('edit')
        return exclude_

def exclude_columns_enseignant(user):
        exclude_=[]
        if not user.is_authenticated:
            exclude_.append('edit')
            exclude_.append('admin')
        elif user.is_enseignant() :
            exclude_.append('admin')
            exclude_.append('edit')
        return exclude_


def assure_module(enseignant_, module_):
    if module_.coordinateur==enseignant_ :
        return True
    else :
        activite_list=Activite.objects.filter(module__matiere=module_.matiere, assuree_par__in=[enseignant_]).exclude(type__startswith='E_')
        return activite_list.exists()

def assure_module_groupe(enseignant_, module_, groupe_):
    if module_.coordinateur==enseignant_ :
        return True
    else :
        activite_list=Activite.objects.filter(module__matiere=module_.matiere, cible__in=[groupe_], assuree_par__in=[enseignant_]).exclude(type__startswith='E_')
        return activite_list.exists()


def get_groupe_list_from_str(student_set):
    """
        Cette fonction est utilisée dans l'import des activités à partir de FET export.
    """
    groupe_list=[]
    str_groupe_list=student_set.split('+')
    for str_groupe in str_groupe_list:
        groupe_elements=str_groupe.split()
        formation_str=groupe_elements[0]
        section_str=groupe_elements[1]
        groupe_str=groupe_elements[2] if len(groupe_elements)==3 else None
        if groupe_str:
            groupe=get_object_or_404(Groupe, code=groupe_str, section__code=section_str, section__formation__programme__code=formation_str, section__formation__annee_univ__encours=True)
        else:
            groupe=get_object_or_404(Groupe, code__isnull=True, section__code=section_str, section__formation__programme__code=formation_str, section__formation__annee_univ__encours=True)
        groupe_list.append(groupe)
    return groupe_list

def get_enseignant_list_from_str(teacher_set, separator):
    """
        Cette fonction est utilisée pour retrouver la liste des enseignants de la base de Talents
        qui correspondent à la liste des enseignants générée dans les activités importées de l'export de FET.
        Attention, il faut que les noms de enseignants dans FET correspondent aux noms dans la base de Talents
    """
    enseignant_list=[]
    str_enseignant_list=teacher_set.split(separator)
    for str_enseignant in str_enseignant_list:
        enseignant_elements=str_enseignant.split()
        #traiter les noms composés
        prenom_initial=enseignant_elements[len(enseignant_elements)-1]
        nom_=enseignant_elements[0]
        for i in range(1, len(enseignant_elements)-1):
            nom_+=' '+enseignant_elements[i]
        
        enseignant=Enseignant.objects.get(nom__icontains=nom_, prenom__startswith=prenom_initial)
        enseignant_list.append(enseignant)
    return enseignant_list
        
def get_type_activite_from_str(activity_tag):
    """
        Cette fonction est utilisée pour traduire les types d'activités dans l'export de FET vers le type d'activités dans la base
        de Talents.
        Attention, il faut uniformiser les notations avant la génération des EDT avec FET
    """
    TAG_TRANS={
        'Cours':'C',
        'eCours':'C',
        'TD':'TD',
        'eTD':'TD',
        'TDp':'TD',
        'TP':'TP',
        'eTP':'TP',
        'Projet':'P',
    }
    return TAG_TRANS[activity_tag]
    
@login_required
def planning_import_from_fet(request):
    # if this is a POST request we need to process the form data
    if not request.user.has_perm('scolar.fonctionnalitenav_planification_activites'):
        return redirect('/accounts/login/?next=%s' % request.path)
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = PlanificationImportFileForm(request.POST, request.FILES)
        
        # check whether it's valid:
        if form.is_valid():
            try:
                activite_file = request.FILES['file']
                
                dataset = Dataset(headers=['Students Sets', 'Subject', 'Teachers', 'Activity Tags', 'Total Duration'])
                #imported_data = dataset.load(activite_file.read().decode('utf-8'), format ='csv')
                imported_data = dataset.load(activite_file.read(), format ='xlsx')
                periode_=form.cleaned_data['periode']
                # supprimer toutes les activités de la période avant d'importer les nouvelles
                Activite.objects.filter(module__formation__annee_univ__encours=True, module__periode__periode=periode_).delete()
                # insert imported_data in Activite table
                ligne_problem=''
                for row in imported_data.dict :
                    try:
                        cible_=get_groupe_list_from_str(row['Students Sets'])
                        module_=Module.objects.get(matiere__code=row['Subject'].split()[0], periode__periode=periode_, formation=cible_[0].section.formation)
                        activite_= Activite.objects.create(
                                module=module_, 
                                type=get_type_activite_from_str(row['Activity Tags']),
                                vh=round(decimal.Decimal(str(row['Total Duration']).replace(',','.'))/decimal.Decimal(2),2),
                                repeter_chaque_semaine=True
                        )
                        try:
                            assuree_par_=get_enseignant_list_from_str(row['Teachers'], '+')
                        except Exception:
                            assuree_par_=[]
                            pass
                        
                        for enseignant_ in assuree_par_: 
                            activite_.assuree_par.add(enseignant_)
                        
                        for groupe_ in cible_:
                            activite_.cible.add(groupe_)
                        activite_.save()
                    except Exception:
                        ligne_problem+=str(row)+'\n'
                        continue       
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "L'import des activités n'a pas réussit. Il doit y avoir un problème dans le format du fichier")
                    messages.info(request, "Merci de renseigner la période pour laquelle vous voulez importer les activités pédagogiques.")
                    messages.info(request, "Le fichier doit être au format xlsx (généré par FET enregistré sous format xlsx) avec les colonnes: 'Students Sets', 'Subject', 'Teachers', 'Activity Tags', 'Total Duration'")  
                    messages.info(request, mark_safe("Students Sets : Programme Section OU Programme Section Groupe. Exemples : 1CS A OU 1CP B G06<br>"+
                                                     "Subject : Code de la matière <br> "+
                                                     "Teachers : NOM_DE_FAMILLE INITIALE_DU_PREMIER_PRENOM si l'activité est assurée par un seul enseignant, exemple : CHALLAL Y. Ou bien NOM_DE_FAMILLE1 INITIALE_DU_PREMIER_PRENOM1+NOM_DE_FAMILLE_2 INITIALE_DU_PREMIER_PRENOM2+... exemple : CHALLAL Y+AIT ALI YAHIA Y<br> "+
                                                     "Activity Tags : Un seul choix par ligne parmi : Cours, eCours, TD, eTD, TDp, TP, eTP, Projet <br> "+
                                                     "Total Duration : Nombre réel multiple de 30 min : 6 pour désigner 3 heures, 5 pour désigner 2 heures et demi, ainsi de suite (nombre avec virgule ou point autorisé)"))  
                    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer Planning à partir de FET'})                                    
            # redirect to a new URL:
            messages.success(request, "Les activités ont été importées avec succès")
            if len(ligne_problem)!=0:
                messages.warning(request, "Lignes avec erreurs:\n"+ligne_problem)
            return HttpResponseRedirect(reverse('planification_list')) 
    # if a GET (or any other method) we'll create a blank form
    else:
        form = PlanificationImportFileForm()
    messages.info(request, "Merci de renseigner la période pour laquelle vous voulez importer les activités pédagogiques.")
    messages.info(request, "Le fichier doit être au format xlsx (généré par FET enregistré sous format xlsx) avec les colonnes: 'Students Sets', 'Subject', 'Teachers', 'Activity Tags', 'Total Duration'")    
    messages.info(request, mark_safe("Students Sets : Programme Section OU Programme Section Groupe. Exemples : 1CS A OU 1CP B G06<br>"+
                                     "Subject : Code de la matière <br> "+
                                     "Teachers : NOM_DE_FAMILLE INITIALE_DU_PREMIER_PRENOM si l'activité est assurée par un seul enseignant, exemple : CHALLAL Y. Ou bien NOM_DE_FAMILLE1 INITIALE_DU_PREMIER_PRENOM1+NOM_DE_FAMILLE_2 INITIALE_DU_PREMIER_PRENOM2+... exemple : CHALLAL Y+AIT ALI YAHIA Y<br> "+
                                     "Activity Tags : Un seul choix par ligne parmi : Cours, eCours, TD, eTD, TDp, TP, eTP, Projet <br> "+
                                     "Total Duration : Nombre réel multiple de 30 min : 6 pour désigner 3 heures, 5 pour désigner 2 heures et demi, ainsi de suite (nombre avec virgule ou point autorisés)"))  
    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer Planification'})


JOUR_NUM={
    'Dimanche':0,
    'Lundi':1,
    'Mardi':2,
    'Mercredi':3,
    'Jeudi':4,
    'Vendredi':5,
    'Samedi':6
}

JOUR_LIST =['Dimanche', 'Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi']
    
def credentials_to_dict(credentials):
    return {'token': credentials.token,
          'refresh_token': credentials.refresh_token,
          'token_uri': credentials.token_uri,
          'client_id': credentials.client_id,
          'client_secret': credentials.client_secret,
          'scopes': credentials.scopes}
   

@login_required
def authorize_from_fet_to_google_agenda(request):
    # if this is a POST request we need to process the form data
    if not request.user.has_perm('scolar.fonctionnalitenav_planification_chargementagenda'):
        return redirect('/accounts/login/?next=%s' % request.path)

    flow = Flow.from_client_secrets_file(
        settings.GOOGLE_CLIENT_SECRET_FILE,
        scopes=settings.SCOPES,
        redirect_uri=settings.PROTOCOLE_HOST+reverse('callback_from_fet_to_google_agenda'))
    authorization_url, state = flow.authorization_url(
        access_type='offline',
        prompt='consent',
        include_granted_scopes='false')
    return redirect(authorization_url)
    
        
def callback_from_fet_to_google_agenda(request):
    # if this is a POST request we need to process the form data
    if not request.user.has_perm('scolar.fonctionnalitenav_planification_chargementagenda'):
        return redirect('/accounts/login/?next=%s' % request.path)
    
    print(request.GET)
    #state = request.session['state']
    state = request.GET.get('state')
    print(state)
    
    flow = Flow.from_client_secrets_file(
        settings.GOOGLE_CLIENT_SECRET_FILE,
        scopes=settings.SCOPES,
        state=state,
        redirect_uri=settings.PROTOCOLE_HOST+reverse('callback_from_fet_to_google_agenda'))
    
    #authorization_response = request.build_absolute_uri
    #flow.fetch_token(authorization_response=authorization_response)
    flow.fetch_token(code=request.GET.get('code'))
    # Store credentials in the session.
    # ACTION ITEM: In a production app, you likely want to save these
    #              credentials in a persistent database instead.
    credentials = flow.credentials
    print('flow;credentials', credentials)
    request.session['credentials'] = credentials_to_dict(credentials)
    print('session,credentiqls', request.session['credentials'])
    return HttpResponseRedirect(reverse('from_fet_to_google_agenda'))


@login_required
def from_fet_to_google_agenda(request):
    # if this is a POST request we need to process the form data
    if not request.user.has_perm('scolar.fonctionnalitenav_planification_chargementagenda'):
        return redirect('/accounts/login/?next=%s' % request.path)

    if 'credentials' not in request.session:
        return redirect('/scolar/authorize_from_fet_to_google_agenda')

    # Load credentials from the session.
    credentials_dict=request.session['credentials']
    credentials = Credentials(
        credentials_dict["token"],
        refresh_token = credentials_dict["refresh_token"],
        token_uri = credentials_dict["token_uri"],
        client_id = credentials_dict["client_id"],
        client_secret = credentials_dict["client_secret"],
        scopes = credentials_dict["scopes"]
        )
 
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = EDTImportFileForm(request.POST, request.FILES)
        
        # check whether it's valid:
        if form.is_valid():
            try:
                service = build("calendar", "v3", credentials=credentials)


                #start_datetime = datetime.datetime.now(tz=pytz.utc)
                
                timetable_file = request.FILES['file']
                dataset = Dataset()
                #imported_data = dataset.load(timetable_file.read().decode('utf-8'), format ='csv')
                imported_data = dataset.load(timetable_file.read(), format ='xlsx')
                cleaned_data=form.cleaned_data
                t = threading.Thread(target=task_from_fet_to_google_agenda,args=[cleaned_data, imported_data, service, request.user])
                t.setDaemon(True)
                t.start()
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "L'insertion des EDT n'a pas réussit. Il doit y avoir un problème dans le format du fichier")
                    messages.info(request, "Le fichier doit être au format csv (généré par FET) avec les colonnes: 'Activity Id', 'Day', 'Hour', 'Students Sets', 'Subject', 'Teachers', 'Activity Tags', 'Total Duration', Room'")                    
                    return render(request, 'scolar/import.html', {'form': form, 'titre':'Insertion des EDT à partir de FET'})                                    
            # redirect to a new URL:
            messages.success(request, "L'insertion des EDT dans Google Agenda a été lancée. Une notification vous sera transmise aussitôt terminée.")
            return HttpResponseRedirect(reverse('home')) 
    # if a GET (or any other method) we'll create a blank form
    else:
        form = EDTImportFileForm()
    messages.info(request, "Le fichier doit être au format xlsx (généré par FET et convertit au format xlsx) avec les colonnes: 'Activity Id', 'Day', 'Hour', 'Students Sets', 'Subject', 'Teachers', 'Activity Tags', 'Total Duration', Room'")    
    return render(request, 'scolar/import.html', {'form': form, 'titre':'Insérer les EDT dans Google Agenda à partir de FET'})
                
                

def task_from_fet_to_google_agenda(cleaned_data, imported_data, service, user): 
    try:
        start_date=cleaned_data['date_debut'] 
        end_date=cleaned_data['date_fin'] 
        
        # TODO : supprimer toutes les activités avant d'importer les nouvelles

        # insert imported_data in Google Agenda
        index_=0
        print("len(imported_data.dict)=", len(imported_data.dict))
        while index_ < len(imported_data.dict) :
            try:
                # pour chque slot time une ligne portant le même activity id est créée dans le fichier
                # il faut donc isoler la 1ère et dernière ligne d'une même activité pour retrouver l'heure début et l'heure fin d'une activité
                print("index_= ", index_)
                first_=index_
                last_=index_
                # avancer jusqu'une nouvelle activité ou fin du fichier
                while last_ < len(imported_data.dict):
                    if imported_data.dict[last_].get("Activity Id") == imported_data.dict[first_].get("Activity Id"):
                        last_+=1
                    else:
                        break
                last_-=1
                index_=last_+1
                first_activity_row=imported_data.dict[first_]
                last_activity_row=imported_data.dict[last_]
                #ATTENETION: dans FET il faut remplacer Pause1 par 12h10-12h40
                start_time_string=first_activity_row.get("Hour").split('-')[0] #TODO Convertir en heur
                start_time_h=int(start_time_string.split('h')[0])
                start_time_min=int(start_time_string.split('h')[1])
                
                end_time_string=last_activity_row.get("Hour").split('-')[1] #TODO Convertir en heur
                end_time_h=int(end_time_string.split('h')[0])
                end_time_min=int(end_time_string.split('h')[1])
                
                week_day=JOUR_NUM[imported_data.dict[first_].get("Day")]
                
                #insérer un event dans l'agenda de chaque groupe cible de l'activité
                groupe_list=get_groupe_list_from_str(first_activity_row['Students Sets'])
                try:
                    enseignant_list=get_enseignant_list_from_str(first_activity_row['Teachers'], '+')
                except:
                    if activation_emails():
                        email = EmailMessage('[Talents] Erreur lors de l\'insertion des EDT dans Google Agenda',
                                             'Bonjour,\n'+ 
                                             'Une erreur s\'est produite lors de l\'insertion des EDT dans Google Agenda'+'\n'+
                                             '==>  '+first_activity_row['Teachers']+'\n'
                                             'Bien cordialement.\n'+
                                             signature_emails(), to=[user.get_email()] )
                    
                        email.send(fail_silently=True)
                    
                    enseignant_list=[]

                room_list=[]
                for code_salle_ in first_activity_row['Room'].split('+'):
                    # ATTENTION on peut avoir plusieurs version d'une même salle en fonction de la capacité allouée pour les examens.
                    # Il faut que toutes ces version pointent sur le même calendarId
                    if  code_salle_:
                        room_=Salle.objects.filter(code=code_salle_)
                        if room_.exists():
                            room_list.append(room_[0])
                        else:
                            if activation_emails():
                                email = EmailMessage('[Talents] Erreur lors de l\'insertion des EDT dans Google Agenda',
                                                     'Bonjour,\n'+ 
                                                     'Une erreur s\'est produite lors de l\'insertion des EDT dans Google Agenda'+'\n'+
                                                     '==>  '+first_activity_row['Room']+'\n'
                                                     'Bien cordialement.\n'+
                                                     signature_emails(), to=[user.get_email()] )
                            
                                email.send(fail_silently=True)
                            continue
                        
                    
                first_groupe=True
                for groupe_ in groupe_list:
                    if groupe_.gCal():
                        if first_groupe:
                            first_groupe=False
                            first_groupe_event = {
                                        "summary": first_activity_row.get("Activity Tags") +" "+ first_activity_row.get("Subject") +" "+first_activity_row.get("Teachers"),
                                        #"description": "Bar",
                                        "start": {
                                            "dateTime": (start_date + datetime.timedelta(days=week_day, hours=start_time_h, minutes=start_time_min)).isoformat(),
                                            "timeZone":"Africa/Algiers"
                                        },
                                        "end": {
                                            "dateTime": (start_date + datetime.timedelta(days=week_day, hours=end_time_h, minutes=end_time_min)).isoformat(),
                                            "timeZone":"Africa/Algiers"
                                        },
                                        'attendees': [
                                            {'email': enseignant_.get_email()} for enseignant_ in enseignant_list
                                        ],
                                        'recurrence': [
                                            'RRULE:FREQ=WEEKLY;UNTIL='+end_date.strftime("%Y%m%dT%H%M%SZ"),
                                        ],
                                        'location': first_activity_row.get("Room"),
                                        'conferenceData': {
                                            'createRequest': {
                                                "requestId": f"{uuid4().hex}",
                                                'conferenceSolutionKey': {
                                                    'type': "hangoutsMeet"
                                                }
                                            }
                                        }
                                    }
                            if len(room_list)>0:
                                for room in room_list:
                                    first_groupe_event['attendees'].append({'email': room.calendarId, 'resource':True})

                            first_event = service.events().insert(calendarId=groupe_.gCal().calendarId, body=first_groupe_event, conferenceDataVersion=1).execute()
                            sleep(1)
                        else:
                            groupe_event = {
                                        "summary": first_activity_row.get("Activity Tags") +" "+ first_activity_row.get("Subject") +" "+first_activity_row.get("Teachers"),
                                        #"description": "Bar",
                                        "start": {
                                            "dateTime": (start_date + datetime.timedelta(days=week_day, hours=start_time_h, minutes=start_time_min)).isoformat(),
                                            "timeZone":"Africa/Algiers"
                                        },
                                        "end": {
                                            "dateTime": (start_date + datetime.timedelta(days=week_day, hours=end_time_h, minutes=end_time_min)).isoformat(),
                                            "timeZone":"Africa/Algiers"
                                        },
                                        'recurrence': [
                                            'RRULE:FREQ=WEEKLY;UNTIL='+end_date.strftime("%Y%m%dT%H%M%SZ"),
                                        ],
                                        'conferenceData': first_event['conferenceData'],
                                        'location': first_groupe_event['location'],
                                    }
                            
                            service.events().insert(calendarId=groupe_.gCal().calendarId, body=groupe_event, conferenceDataVersion=1).execute()
                            sleep(1)
            except Exception:
                print('ERREUR A LA LIGNE N°' + str(index_) + ': '+ str(imported_data.dict[index_]))
                if activation_emails():
                    email = EmailMessage('[Talents] Erreur lors de l\'insertion des EDT dans Google Agenda',
                                         'Bonjour,\n'+ 
                                         'Une erreur s\'est produite lors de l\'insertion des EDT dans Google Agenda'+'\n'+
                                         'ERREUR A LA LIGNE N°' + str(index_) + ': '+ str(imported_data.dict[index_])+'\n'+
                                         'Bien cordialement.\n'+
                                         signature_emails(), to=[user.get_email()] )
                
                    email.send(fail_silently=True)
                    sleep(1)
                
                continue
                    

        if activation_emails():
            email = EmailMessage('[Talents] Insertion des EDT dans Google Agenda',
                                 'Bonjour,\n'+ 
                                 "L'insertion des EDT dans Google Agenda est terminée avec succès \n"+
                                 'Bien cordialement.\n'+
                                 signature_emails(), to=[user.get_email()]                                                
                                )
            email.send(fail_silently=True)
    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            if activation_emails():
                email = EmailMessage('[Talents] Erreur lors de l\'insertion des EDT dans Google Agenda',
                                     'Bonjour,\n'+ 
                                     'Une erreur s\'est produite lors de l\'insertion des EDT dans Google Agenda'+'\n'+
                                     'Bien cordialement.\n'+
                                     signature_emails(), to=[user.get_email()] )
                email.send(fail_silently=True)



@login_required
def authorize_clear_google_agenda(request):
    # if this is a POST request we need to process the form data
    if not request.user.has_perm('scolar.fonctionnalitenav_planification_reinitialisationagenda'):
        return redirect('/accounts/login/?next=%s' % request.path)

    flow = Flow.from_client_secrets_file(
        settings.GOOGLE_CLIENT_SECRET_FILE,
        scopes=settings.SCOPES,
        redirect_uri=settings.PROTOCOLE_HOST+reverse('callback_clear_google_agenda'))
    authorization_url, state = flow.authorization_url(
        access_type='offline',
        prompt='consent',
        include_granted_scopes='false')
    return redirect(authorization_url)
    
        
def callback_clear_google_agenda(request):
    # if this is a POST request we need to process the form data
    if not request.user.has_perm('scolar.fonctionnalitenav_planification_reinitialisationagenda'):
        return redirect('/accounts/login/?next=%s' % request.path)
    
    state = request.GET.get('state')
    
    flow = Flow.from_client_secrets_file(
        settings.GOOGLE_CLIENT_SECRET_FILE,
        scopes=settings.SCOPES,
        state=state,
        redirect_uri=settings.PROTOCOLE_HOST+reverse('callback_clear_google_agenda'))
    
    #authorization_response = request.build_absolute_uri
    flow.fetch_token(code=request.GET.get('code'))
    # Store credentials in the session.
    # ACTION ITEM: In a production app, you likely want to save these
    #              credentials in a persistent database instead.
    credentials = flow.credentials
    request.session['credentials'] = credentials_to_dict(credentials)
    return HttpResponseRedirect(reverse('clear_google_agenda'))


@login_required
def clear_google_agenda(request):
    # if this is a POST request we need to process the form data
    if not request.user.has_perm('scolar.fonctionnalitenav_planification_reinitialisationagenda'):
        return redirect('/accounts/login/?next=%s' % request.path)
    
    if 'credentials' not in request.session:
        return redirect('/scolar/authorize_clear_google_agenda')

    # Load credentials from the session.
    credentials_dict=request.session['credentials']
    credentials = Credentials(
        credentials_dict["token"],
        refresh_token = credentials_dict["refresh_token"],
        token_uri = credentials_dict["token_uri"],
        client_id = credentials_dict["client_id"],
        client_secret = credentials_dict["client_secret"],
        scopes = credentials_dict["scopes"]
        )
 
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = EDTSelectForm(request.POST)
        
        # check whether it's valid:
        if form.is_valid():
            try:
                service = build("calendar", "v3", credentials=credentials)

                cleaned_data=form.cleaned_data

                t = threading.Thread(target=task_clear_google_agenda,args=[cleaned_data, service, request.user])
                t.setDaemon(True)
                t.start()

            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "Erreur lors de la demande de suppression des EDT de Google Agenda")
                    return render(request, 'scolar/import.html', {'form': form, 'titre':'Suppression des EDT de Google Agenda'})                                    
            # redirect to a new URL:
            messages.success(request, "La suppression des EDT de Google Agenda est en cours. Une notification vous sera transmise aussitôt terminée.")
            return HttpResponseRedirect(reverse('home')) 
    # if a GET (or any other method) we'll create a blank form
    else:
        form = EDTSelectForm()
    messages.info(request, "Merci de renseigner formulaire pour indiquer quels EDT supprimer de Google Agenda.")
    return render(request, 'scolar/import.html', {'form': form, 'titre':'Suppression des EDT de Google Agenda'})


def task_clear_google_agenda(cleaned_data, service, user):
    try:
        start_date=cleaned_data['date_debut'] 
        end_date=cleaned_data['date_fin'] 
        google_calendar_list=cleaned_data['google_calendar_list']
        for calendar_ in google_calendar_list:
            page_token = None
            while True:
                events = service.events().list(calendarId=calendar_.calendarId, 
                                               pageToken=page_token, 
                                               timeMin=start_date.strftime("%Y-%m-%dT%H:%M:%SZ"),
                                               timeMax=end_date.strftime("%Y-%m-%dT%H:%M:%SZ"),
                                               singleEvents=True
                                               ).execute()
                for event_ in events['items']:
                    try:
                        service.events().delete(calendarId=calendar_.calendarId, eventId=event_["id"], sendUpdates="none").execute()
                        sleep(1)
                    except Exception:
                        continue
                page_token = events.get('nextPageToken')
                if not page_token:
                    break
        if activation_emails():
            email = EmailMessage('[Talents] Suppression des EDT de Google Agenda',
                                 'Bonjour,\n'+ 
                                 "La suppression des EDT de Google Agenda est terminée avec succès \n"+
                                 'Bien cordialement.\n'+
                                 signature_emails(), to=[user.get_email()]                                                
                                )
            email.send(fail_silently=True)
    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            if activation_emails():
                email = EmailMessage('[Talents] Erreur lors de la suppression des EDT de Google Agenda',
                                     'Bonjour,\n'+ 
                                     'Une erreur s\'est produite lors de la suppression des EDT de Google Agenda'+'\n'+
                                     'Bien cordialement.\n'+
                                     signature_emails(), to=[user.get_email()] )
                email.send(fail_silently=True)


    
def edt_list_view(request):
    # if this is a POST request we need to process the form data
    context={}
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = EDTForm(request.POST)
        # check whether it's valid:
        if form.is_valid():
            form_data=form.cleaned_data
            groupe_=form_data['groupe']
            etudiant_=form_data['etudiant']
            enseignant_=form_data['enseignant']
            if groupe_:
                context['groupe']=Groupe.objects.get(id=groupe_.id)
            if enseignant_:
                context['enseignant']=enseignant_                                
            if etudiant_:
                inscription_list=Inscription.objects.filter(etudiant=etudiant_, formation__annee_univ__encours=True)
                if inscription_list.exists():
                    context['inscription_list']=inscription_list
    else:
        form = EDTForm()
    
    context['form']=form
    context['titre']='EDT Finder'
    messages.info(request, "Choisir un critère de recherche d'un EDT.")
    return render(request, 'scolar/edt_finder.html', context)

def releve_notes_update_view(request, inscription_pk):
    """
        Cette vue permet de modifier les notes post_delib et décision du jury pendant les délibérations
    """
    if not request.user.has_perm('scolar.fonctionnalitenav_pedagogie_generationpvsdeliberation'):
        return redirect('/accounts/login/?next=%s' % request.path)
    inscription_=Inscription.objects.get(id=inscription_pk)
    context = {}
    context['inscription'] = inscription_

    # if this is a POST request we need to process the form data

    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = ReleveNotesUpdateForm(inscription_pk, request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:
                # process the data in form.cleaned_data as required
                data=form.cleaned_data
                for periode_ in inscription_.inscription_periodes.all():
                    periode_.moy=data[periode_.periodepgm.code]
                    for ue_ in periode_.resultat_ues.all():
                        for resultat_ in ue_.resultat_matieres.all():
                            resultat_.moy_post_delib=data[resultat_.module.matiere.code]
                            resultat_.save(update_fields=['moy_post_delib'])
                            if resultat_.activation_rattrapage() :
                                resultat_.entree_rattrapage=data['rattrapage_'+resultat_.module.matiere.code]
                                resultat_.save(update_fields=['entree_rattrapage'])
                            if resultat_.activation_dettes() :
                                resultat_.dette=data['dette_'+resultat_.module.matiere.code]
                                resultat_.save(update_fields=['dette'])
                inscription_.proposition_decision_jury=data['proposition_decision_jury']
                inscription_.save(update_fields=['proposition_decision_jury'])
                ancienne_observation = inscription_.observation
                if inscription_.observation != data['observation'] :
                    inscription_.observation = data['observation']
                    inscription_.save(update_fields=['observation'])
                #calcul et enregistrement la moyenne après rachat 
                if (inscription_.proposition_decision_jury =='AR'or inscription_.proposition_decision_jury =='CR'):
                    inscription_.reset_moy_ra()
                    inscription_.moy_ra=inscription_.moyenne_post_delib()
                    inscription_.save(update_fields=['moy_ra'])

            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "Erreur lors de la modification des notes post délibération et/ou décision du conseil")
                    messages.info(request, "Merci d'utiliser ce formulaire pour le rachat (note post délibération)")
                    messages.info(request, "Ne pas oublier de renseigner la nouvelle décision du conseil.")
                    return render(request, 'scolar/releve_notes_update.html', {'form':form})
            messages.success(request, "Les modifications ont bien été enregistrées")
            return HttpResponseRedirect(reverse('deliberation_detail', kwargs={'formation_pk': inscription_.formation.id, })) 
    # if a GET (or any other method) we'll create a blank form
    else:

        form = ReleveNotesUpdateForm(inscription_pk)
        context['form']=form
        messages.info(request, "Merci d'utiliser ce formulaire pour le rachat (note post délibération)")
        messages.info(request, "Ne pas oublier de renseigner la nouvelle décision du conseil.")
    return render(request, 'scolar/releve_notes_update.html', context)



class ReleveNotesView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name = 'scolar/releve_notes.html'
    
    def test_func(self):
        inscription_=Inscription.objects.get(id=self.kwargs.get('inscription_pk')) 
        return self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_etudiants_visualisationnotesprofil', inscription_.etudiant.matricule)
    
    def get_context_data(self, **kwargs):
        context = super(ReleveNotesView, self).get_context_data(**kwargs)
        inscription_=Inscription.objects.get(id=self.kwargs.get('inscription_pk'))
        context['inscription'] = inscription_       
        context['decision_jury'] = dict(DECISIONS_JURY)
        context['categorie_ue']=dict(CAT_UE)
        context['date'] = datetime.date.today()
        context['credits'] = inscription_.formation.activation_credits()


        return context

class ReleveNotesPDFView(LoginRequiredMixin, UserPassesTestMixin, PDFTemplateView):
    template_name = 'scolar/releve_notes_pdf.html'
    cmd_options={
        'orientation':'Landscape',
        'page-size':'A4',

        }
    def test_func(self):
        inscription_=Inscription.objects.get(id=self.kwargs.get('inscription_pk'))
        return self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_etudiants_documents', inscription_.etudiant.matricule) or self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_etudiants_documentsnonsignes', inscription_.etudiant.matricule)
    
    def get_context_data(self, **kwargs):
        context = super(ReleveNotesPDFView, self).get_context_data(**kwargs)
        inscription_=Inscription.objects.get(id=self.kwargs.get('inscription_pk'))
        self.filename=str(inscription_)+'.pdf'
        context['inscription'] = inscription_
        context['date'] = datetime.date.today()
        context['categorie_ue']=dict(CAT_UE)
        context['decision_jury']=dict(DECISIONS_JURY)
        context['pdf']=1
        context['credits'] = 1 if inscription_.formation.activation_credits() else None
        # afficher le rang uiquement pour les décisions Admis, Rachat, Redoublement
        if inscription_.decision_jury in ['A', 'AC', 'AR', 'SR', 'AD', 'CR', 'R'] and inscription_.formation.archive==True:
            context['rang'] = 1
        else:
            context['rang'] = None
        return context

class ReleveNotesEnglishPDFView(LoginRequiredMixin, UserPassesTestMixin, PDFTemplateView):
    template_name = 'scolar/releve_notes_english_pdf.html'
    cmd_options={
        'orientation':'Landscape',
        'page-size':'A4',

        }
    def test_func(self):
        inscription_=Inscription.objects.get(id=self.kwargs.get('inscription_pk'))
        return self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_etudiants_documents', inscription_.etudiant.matricule) or self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_etudiants_documentsnonsignes', inscription_.etudiant.matricule)
    
    def get_context_data(self, **kwargs):
        context = super(ReleveNotesEnglishPDFView, self).get_context_data(**kwargs)
        inscription_=Inscription.objects.get(id=self.kwargs.get('inscription_pk'))
        self.filename=str(inscription_)+'_English.pdf'
        context['inscription'] = inscription_
        context['date'] = datetime.date.today()
        context['categorie_ue']=dict(CAT_UE)
        context['decision_jury']=dict(DECISIONS_JURY)
        context['pdf']=1
        context['credits'] = 1 if inscription_.formation.activation_credits() else None
        # afficher le rang uiquement pour les décisions Admis, Rachat, Redoublement
        if inscription_.decision_jury in ['A', 'AC', 'AR', 'SR', 'AD', 'CR', 'R'] and inscription_.formation.pv_final_existe():
            context['rang'] = 1
        else:
            context['rang'] = None
        return context
    
class ReleveNotesArabePDFView(LoginRequiredMixin, UserPassesTestMixin, PDFTemplateView):
    template_name = 'scolar/releve_notes_arabe_pdf.html'
    cmd_options={
        'orientation':'Landscape',
        'page-size':'A4',
        }
    def test_func(self):
        inscription_=Inscription.objects.get(id=self.kwargs.get('inscription_pk'))
        return self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_etudiants_documents', inscription_.etudiant.matricule) or self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_etudiants_documentsnonsignes', inscription_.etudiant.matricule)
    
    def get_context_data(self, **kwargs):
        context = super(ReleveNotesArabePDFView, self).get_context_data(**kwargs)
        inscription_=Inscription.objects.get(id=self.kwargs.get('inscription_pk'))
        self.filename=str(inscription_)+'_Arabe.pdf'
        context['inscription'] = inscription_
        context['date'] = datetime.date.today()
        context['categorie_ue']=dict(CAT_UE)
        context['decision_jury']=dict(DECISIONS_JURY)
        context['pdf']=1
        context['credits'] = 1 if inscription_.formation.activation_credits() else None
        # afficher le rang uiquement pour les décisions Admis, Rachat, Redoublement
        if inscription_.decision_jury in ['A', 'AC', 'AR', 'SR', 'AD', 'CR', 'R'] and inscription_.formation.pv_final_existe():
            context['rang'] = 1
        else:
            context['rang'] = None
        return context
    
# class ReleveNotesListPDFView(LoginRequiredMixin, UserPassesTestMixin, PDFTemplateView):
#     template_name = 'scolar/releve_notes_list_pdf.html'
#     cmd_options={
#         'orientation':'Landscape',
#         'page-size':'A4',
#         }
#     def test_func(self):
#         return self.request.user.is_scolarite()
#     
#     def get_context_data(self, **kwargs):
#         context = super(ReleveNotesListPDFView, self).get_context_data(**kwargs)
#         formation_=Formation.objects.get(id=self.kwargs.get('formation_pk'))
#         inscription_list=formation_.inscriptions_actives().order_by('etudiant__nom', 'etudiant__prenom')
#         self.filename='RELEVES_ANNUELS_'+str(formation_)+'.pdf'
#         context['inscription_list'] = inscription_list
#         context['date'] = datetime.date.today()
#         context['categorie_ue']=dict(CAT_UE)
#         context['decision_jury']=dict(DECISIONS_JURY)
#         context['pdf']=1
#         context['credits'] = 1 if formation_.programme.ordre <=2 else None
#         return context

@login_required
def releve_notes_list_pdf_view(request, formation_pk, periode_pk):
    if not (request.user.has_perm('scolar.fonctionnalitenav_etudiants_documentsgroupes')):
        messages.error(request,"Vous n'avez pas la permission d'exécution de cette opération")
        return redirect('/accounts/login/?next=%s' % request.path)
    try:
        t = threading.Thread(target=task_releves_notes_pdf,args=[formation_pk, request.user])
        t.setDaemon(True)
        t.start()
        messages.success(request,"Votre demande de génération des relevés de notes est prise en compte.")
        messages.success(request,"Une notification vous sera transmise une fois la tâche terminée.")

    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            messages.error(request,"ERREUR: lors de génération des relevés de notes. Merci de le signaler à l'administrateur.")
    return HttpResponseRedirect(reverse('document_list'))


def task_releves_notes_pdf(formation_pk, user): 
    try:
        context={}
        cmd_options={
            'orientation':'Landscape',
            'page-size':'A4',
            }
        
        formation_=Formation.objects.get(id=formation_pk)
        inscription_list=formation_.inscriptions_pour_deliberations().order_by('etudiant__nom', 'etudiant__prenom')
        filename='RELEVES_ANNUELS_'+str(formation_)+'.pdf'
        context['inscription_list'] = inscription_list
        context['date'] = datetime.date.today()
        context['categorie_ue']=dict(CAT_UE)
        context['decision_jury']=dict(DECISIONS_JURY)
        context['pdf']=1
        context['credits'] = 1 if formation_.activation_credits() else None
        context['institution'] = user.institution()
        if formation_.pv_final_existe():
            context['rang'] = 1
        else:
            context['rang'] = None
        
        pdf_=render_pdf_from_template(input_template='scolar/releve_notes_list_pdf.html', 
                                      header_template=None,
                                      footer_template=None,
                                      context=context, 
                                      cmd_options=cmd_options)
        random_string=''.join(random.choices(string.ascii_uppercase + string.digits, k=10))
        filename = 'RA_'+random_string+'.pdf'
        default_storage.save(settings.MEDIA_ROOT+'/files/'+filename, io.BytesIO(pdf_))
        file_url=settings.PROTOCOLE_HOST+'/media/files/'+filename
        trace_create(user, user, 'La génération des relevés annuels de '+str(formation_)+' est terminée : '+ file_url)

        if activation_emails():
            email = EmailMessage('[Talents] Génération des relevés de notes de '+str(formation_),
                                 'Bonjour,\n'+ 
                                 'La génération des relevés de notes de '+str(formation_)+' est terminée \n'+
                                 'Veuillez trouver ci-joints les relevés\n'+
                                 'Bien cordialement.\n'+
                                 signature_emails(), to=[user.get_email()]#+ 
                                                    #email_scolarite()+
                                                    #email_direction()
                                                    )
            email.attach(filename, pdf_, 'application/pdf' )
            email.send(fail_silently=True)
    except Exception:
        trace_create(user, user, 'Une erreur s\'est produite lors de la génération des relevés de notes de la formation '+str(formation_))
        if settings.DEBUG:
            raise Exception
        else:
            if activation_emails():
                email = EmailMessage('[Talents] Erreur lors de la génération des relevés de notes de  la formation '+str(formation_),
                                     'Bonjour,\n'+ 
                                     'Une erreur s\'est produite lors de la génération des relevés de notes de la formation '+str(formation_)+'\n'+
                                     'Bien cordialement.\n'+
                                     signature_emails(), to=[user.get_email()] )
                email.send(fail_silently=True)


class ReleveNotesGlobalPDFView(LoginRequiredMixin, UserPassesTestMixin, PDFTemplateView):
    template_name = 'scolar/releve_notes_global_pdf.html'
    cmd_options={
        'orientation':'Portrait',
        'page-size':'A4',
        }
    def test_func(self):
        return self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_etudiants_documents', self.kwargs.get('etudiant_pk'))
    
    def get_context_data(self, **kwargs):
        context = super(ReleveNotesGlobalPDFView, self).get_context_data(**kwargs)
        etudiant_=Etudiant.objects.get(matricule=self.kwargs.get('etudiant_pk'))
        self.filename=str(etudiant_)+'.pdf'
        context['etudiant'] = etudiant_
        context['inscription_list'] = Inscription.objects.filter(etudiant=etudiant_, formation__programme__diplome=self.kwargs.get('diplome_pk')).exclude(Q(decision_jury='R')|Q(decision_jury__startswith='M')|Q(decision_jury='AJ')).order_by('formation__programme__ordre')
        context['cycle_list'] = Cycle.objects.filter(programme__formation__inscription__in=context['inscription_list']).distinct().order_by('ordre')
        context['date'] = datetime.date.today()
        context['categorie_ue']=dict(CAT_UE)
        context['decision_jury']=dict(DECISIONS_JURY)
        context['mention']=dict(MENTION)
        context['diplome']=get_object_or_404(Diplome, id=context['inscription_list'].last().formation.programme.diplome.id)
        return context


class CertificatPDFView(LoginRequiredMixin, UserPassesTestMixin, PDFTemplateView):
    template_name = 'scolar/certificat_pdf.html'
    cmd_options={
        'orientation':'Landscape',
        'page-size':'A4',
        }
    
    def test_func(self):
        inscription_=Inscription.objects.get(id=self.kwargs.get('inscription_pk'))
        return self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_etudiants_documents', inscription_.etudiant.matricule) or self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_etudiants_documentsnonsignes', inscription_.etudiant.matricule) or self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_postgraduation_visualisationdocumentsdoctorants', inscription_.etudiant.matricule) or self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_postgraduation_visualisationdocumentsnonsignesdoctorants', inscription_.etudiant.matricule)
    
    def get_context_data(self, **kwargs):
        context = super(CertificatPDFView, self).get_context_data(**kwargs)
        inscription_=Inscription.objects.get(id=self.kwargs.get('inscription_pk'))
        self.filename='CERTIFICAT_3L_'+str(inscription_)+'.pdf'
        context['inscription'] = inscription_
        context['date'] = datetime.date.today()
        context['range'] = ['f','o'] # f : first, r:right, o:other positions are used in template so it's important

        return context

class Certificat2LPDFView(LoginRequiredMixin, UserPassesTestMixin, PDFTemplateView):
    template_name = 'scolar/certificat_old_pdf.html'
    cmd_options={
        'orientation':'Landscape',
        'page-size':'A4',
        }
    
    def test_func(self):
        inscription_=Inscription.objects.get(id=self.kwargs.get('inscription_pk'))
        return self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_etudiants_documents', inscription_.etudiant.matricule) or self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_etudiants_documentsnonsignes', inscription_.etudiant.matricule) or self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_postgraduation_visualisationdocumentsdoctorants', inscription_.etudiant.matricule) or self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_postgraduation_visualisationdocumentsnonsignesdoctorants', inscription_.etudiant.matricule)
    
    def get_context_data(self, **kwargs):
        context = super(Certificat2LPDFView, self).get_context_data(**kwargs)
        inscription_=Inscription.objects.get(id=self.kwargs.get('inscription_pk'))
        self.filename='CERTIFICAT_2L_'+str(inscription_)+'.pdf'
        context['inscription'] = inscription_
        context['date'] = datetime.date.today()
        context['range'] = ['f','o'] # f : first, r:right, o:other positions are used in template so it's important

        return context

class FicheInscriptionPDFView(LoginRequiredMixin, UserPassesTestMixin, PDFTemplateView):
    template_name = 'scolar/fiche_inscription_pdf.html'
    cmd_options={
        'orientation':'Portrait',
        'page-size':'A4',
        }
    
    def test_func(self):
        inscription_=Inscription.objects.get(id=self.kwargs.get('inscription_pk'))
        return self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_etudiants_documents', inscription_.etudiant.matricule)
    
    def get_context_data(self, **kwargs):
        context = super(FicheInscriptionPDFView, self).get_context_data(**kwargs)
        inscription_=Inscription.objects.get(id=self.kwargs.get('inscription_pk'))
        inscription_annee_precedente_=Inscription.objects.filter(etudiant=inscription_.etudiant,
                                                                 formation__annee_univ=inscription_.formation.annee_univ.annee_precedente(),
                                                                 formation__programme__diplome=inscription_.formation.programme.diplome
                                                                 )
        if inscription_annee_precedente_.count()==1:
            inscription_annee_precedente_= inscription_annee_precedente_.get()
        else:
            inscription_annee_precedente_= None
        
        self.filename='FICHE_INSCRIPTION'+str(inscription_)+'.pdf'
        context['inscription'] = inscription_
        context['inscription_annee_precedente'] = inscription_annee_precedente_
        context['decision_jury']=dict(DECISIONS_JURY)
        context['date'] = datetime.date.today()

        return context

# class CertificatListPDFView(LoginRequiredMixin, UserPassesTestMixin, PDFTemplateView):
#     template_name = 'scolar/certificat_list_pdf.html'
#     cmd_options={
#         'orientation':'Landscape',
#         'page-size':'A4',
#         }
#     def test_func(self):
#         return self.request.user.is_scolarite() or self.request.user.is_direction()
#     
#     def get_context_data(self, **kwargs):
#         context = super(CertificatListPDFView, self).get_context_data(**kwargs)
#         formation_=Formation.objects.get(id=self.kwargs.get('formation_pk'))
#         inscription_list=formation_.inscriptions_actives().order_by('etudiant__nom', 'etudiant__prenom')
#         self.filename='CERTIFICATS_3L_'+str(formation_)+'.pdf'
#         context['inscription_list'] = inscription_list
#         context['date'] = datetime.date.today()
#         context['range']=['f','r']
# 
#         return context

@login_required
def certificat_3l_list_pdf_view(request, formation_pk, periode_pk):
    if not request.user.has_perm('scolar.fonctionnalitenav_etudiants_documentsgroupes'):
        messages.error(request,"Vous n'avez pas la permission d'exécution de cette opération")
        return redirect('/accounts/login/?next=%s' % request.path)
    try:
        t = threading.Thread(target=task_certificat_3l_list_pdf,args=[formation_pk, request.user])
        t.setDaemon(True)
        t.start()
        messages.success(request,"Votre demande de génération des certificats de scolarité est prise en compte.")
        messages.success(request,"Une notification vous sera transmise une fois la tâche terminée.")

    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            messages.error(request,"ERREUR: lors de génération des certificats de scolarité. Merci de le signaler à l'administrateur.")
    return HttpResponseRedirect(reverse('document_list'))

def task_certificat_3l_list_pdf(formation_pk, user): 
    try:
        context={}
        cmd_options={
            'orientation':'Landscape',
            'page-size':'A4',
            }
        
        formation_=Formation.objects.get(id=formation_pk)
        inscription_list=formation_.pre_inscriptions().order_by('etudiant__nom', 'etudiant__prenom')
        filename='CERTIFICATS_3L_'+str(formation_)+'.pdf'
        context['inscription_list'] = inscription_list
        context['date'] = datetime.date.today()
        context['range']=['f','o']
        context['institution'] = user.institution()
        
        pdf_=render_pdf_from_template(input_template='scolar/certificat_list_pdf.html', 
                                      header_template=None,
                                      footer_template=None,
                                      context=context, 
                                      cmd_options=cmd_options)
        
        random_string=''.join(random.choices(string.ascii_uppercase + string.digits, k=10))
        filename = 'Cert3L_'+random_string+'.pdf'
        default_storage.save(settings.MEDIA_ROOT+'/files/'+filename, io.BytesIO(pdf_))
        file_url=settings.PROTOCOLE_HOST+'/media/files/'+filename
        trace_create(user, user, 'La génération des certificats de scolarité 3L de '+str(formation_)+' est terminée : '+ file_url)
        if activation_emails():
            email = EmailMessage('[Talents] Génération des certificats de scolarité 3L de '+str(formation_),
                                 'Bonjour,\n'+ 
                                 'La génération des certificats de scolarité 3L de '+str(formation_)+' est terminée \n'+
                                 'Veuillez trouver ci-joints les certificats\n'+
                                 'Bien cordialement.\n'+
                                 signature_emails(), to=[user.get_email()]#+ 
                                                    #email_scolarite()+
                                                    #email_direction()
                                                    )
            email.attach(filename, pdf_, 'application/pdf' )
            email.send(fail_silently=True)
    except Exception:
        trace_create(user, user, 'Une erreur s\'est produite lors de la génération des certificats de scolarité de la formation '+str(formation_))
        if settings.DEBUG:
            raise Exception
        else:
            if activation_emails():
                email = EmailMessage('[Talents] Erreur lors de la génération des certificats de scolarité de la formation '+str(formation_),
                                     'Bonjour,\n'+ 
                                     'Une erreur s\'est produite lors de la génération des certificats de scolarité de la formation '+str(formation_)+'\n'+
                                     'Bien cordialement.\n'+
                                     signature_emails(), to=[user.get_email()] )
                email.send(fail_silently=True)


class CertificatCongesPDFView(LoginRequiredMixin, UserPassesTestMixin, PDFTemplateView):
    template_name = 'scolar/certificat_conges_pdf.html'
    cmd_options={
        'orientation':'Landscape',
        'page-size':'A4',
        }
    def test_func(self):
        inscription_=Inscription.objects.get(id=self.kwargs.get('inscription_pk'))
        return self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_etudiants_documents', inscription_.etudiant.matricule) or self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_etudiants_documentsnonsignes', inscription_.etudiant.matricule) or self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_postgraduation_visualisationdocumentsdoctorants', inscription_.etudiant.matricule) or self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_postgraduation_visualisationdocumentsnonsignesdoctorants', inscription_.etudiant.matricule)
    
    def get_context_data(self, **kwargs):
        context = super(CertificatCongesPDFView, self).get_context_data(**kwargs)
        inscription_=Inscription.objects.get(id=self.kwargs.get('inscription_pk'))
        self.filename='ATTESTATION_CONGE_ACAD'+str(inscription_)+'.pdf'
        context['inscription'] = inscription_
        context['raison'] = dict(DECISIONS_JURY)[inscription_.decision_jury]
        context['date'] = datetime.date.today()

        return context

class AttestationReintegrationPDFView(LoginRequiredMixin, UserPassesTestMixin, PDFTemplateView):
    template_name = 'scolar/attestation_reintegration_pdf.html'
    cmd_options={
        'orientation':'Landscape',
        'page-size':'A4',
        }
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalite_etudiants_documentsnonsignes') or self.request.user.has_perm('scolar.fonctionnalite_postgraduation_visualisationdocumentsnonsignesdoctorants')
    
    def get_context_data(self, **kwargs):
        context = super(AttestationReintegrationPDFView, self).get_context_data(**kwargs)
        inscription_=Inscription.objects.get(id=self.kwargs.get('inscription_pk'))
        self.filename='ATTESTATION_REINTEGRATION_'+str(inscription_)+'.pdf'
        context['inscription'] = inscription_
        context['raison'] = dict(DECISIONS_JURY)[inscription_.decision_jury]
        context['date'] = datetime.date.today()

        return context

class CertificatOldPDFView(LoginRequiredMixin, UserPassesTestMixin, PDFTemplateView):
    template_name = 'scolar/certificat_old_pdf.html'
    cmd_options={
        'orientation':'Landscape',
        'page-size':'A4',
        }
    def test_func(self):
        inscription_=Inscription.objects.get(id=self.kwargs.get('inscription_pk'))
        return self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_etudiants_documents', inscription_.etudiant.matricule) or self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_etudiants_documentsnonsignes', inscription_.etudiant.matricule)
    
    def get_context_data(self, **kwargs):
        context = super(CertificatOldPDFView, self).get_context_data(**kwargs)
        inscription_=Inscription.objects.get(id=self.kwargs.get('inscription_pk'))
        self.filename='CERTIFICAT_Fr_Ar'+str(inscription_)+'.pdf'
        context['inscription'] = inscription_
        context['date'] = datetime.date.today()
        return context

# class CertificatOldListPDFView(LoginRequiredMixin, UserPassesTestMixin, PDFTemplateView):
#     template_name = 'scolar/certificat_old_list_pdf.html'
#     cmd_options={
#         'orientation':'Landscape',
#         'page-size':'A4',
#         }
#     def test_func(self):
#         return self.request.user.is_scolarite() or self.request.user.is_direction()
#     
#     def get_context_data(self, **kwargs):
#         context = super(CertificatOldListPDFView, self).get_context_data(**kwargs)
#         formation_=Formation.objects.get(id=self.kwargs.get('formation_pk'))
#         inscription_list=formation_.inscriptions_actives().order_by('etudiant__nom', 'etudiant__prenom')
#         self.filename='CERTIFICAT_Fr_Ar'+str(formation_)+'.pdf'
#         context['inscription_list'] = inscription_list
#         context['date'] = datetime.date.today()
#         return context

@login_required
def certificat_2l_list_pdf_view(request, formation_pk, periode_pk):
    if not request.user.has_perm('scolar.fonctionnalitenav_etudiants_documentsgroupes') :
        messages.error(request,"Vous n'avez pas la permission d'exécution de cette opération")
        return redirect('/accounts/login/?next=%s' % request.path)
    try:
        t = threading.Thread(target=task_certificat_2l_list_pdf,args=[formation_pk, request.user])
        t.setDaemon(True)
        t.start()
        messages.success(request,"Votre demande de génération des certificats de scolarité est prise en compte.")
        messages.success(request,"Une notification vous sera transmise une fois la tâche terminée.")

    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            messages.error(request,"ERREUR: lors de génération des certificats de scolarité. Merci de le signaler à l'administrateur.")
    return HttpResponseRedirect(reverse('document_list'))

def task_certificat_2l_list_pdf(formation_pk, user): 
    try:
        context={}
        cmd_options={
            'orientation':'Landscape',
            'page-size':'A4',
            }
        
        formation_=Formation.objects.get(id=formation_pk)
        inscription_list=formation_.pre_inscriptions().order_by('etudiant__nom', 'etudiant__prenom')
        filename='CERTIFICAT_Fr_Ar'+str(formation_)+'.pdf'
        context['inscription_list'] = inscription_list
        context['date'] = datetime.date.today()
        context['institution'] = user.institution()
        
        pdf_=render_pdf_from_template(input_template='scolar/certificat_old_list_pdf.html', 
                                      header_template=None,
                                      footer_template=None,
                                      context=context, 
                                      cmd_options=cmd_options)
        
        random_string=''.join(random.choices(string.ascii_uppercase + string.digits, k=10))
        filename = 'Cert2L_'+random_string+'.pdf'
        default_storage.save(settings.MEDIA_ROOT+'/files/'+filename, io.BytesIO(pdf_))
        file_url=settings.PROTOCOLE_HOST+'/media/files/'+filename
        trace_create(user, user, 'La génération des certificats de scolarité 2L de '+str(formation_)+' est terminée : '+ file_url)

        if activation_emails():
            email = EmailMessage('[Talents] Génération des certificats de scolarité 2L de '+str(formation_),
                                 'Bonjour,\n'+ 
                                 'La génération des certificats de scolarité 3L de '+str(formation_)+' est terminée \n'+
                                 'Veuillez trouver ci-joints les certifictas\n'+
                                 'Bien cordialement.\n'+
                                 signature_emails(), to=[user.get_email()]#+ 
                                                    #email_scolarite()+
                                                    #email_direction()
                                                    )
            email.attach(filename, pdf_, 'application/pdf' )
            email.send(fail_silently=True)
    except Exception:
        trace_create(user, user, 'Une erreur s\'est produite lors de la génération des certificats de scolarité de la formation '+str(formation_))
        if settings.DEBUG:
            raise Exception
        else:
            if activation_emails():
                email = EmailMessage('[Talents] Erreur lors de la génération des certificats de scolarité de la formation '+str(formation_),
                                     'Bonjour,\n'+ 
                                     'Une erreur s\'est produite lors de la génération des certificats de scolarité de la formation '+str(formation_)+'\n'+
                                     'Bien cordialement.\n'+
                                     signature_emails(), to=[user.get_email()] )
                email.send(fail_silently=True)


class ReleveECTSListPDFView(LoginRequiredMixin, UserPassesTestMixin, PDFTemplateView):
    template_name = 'scolar/releve_ects_list_pdf.html'
    cmd_options={
        'orientation':'Portrait',
        'page-size':'A4',
        }
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalitenav_etudiants_documentsgroupes')
    
    def get_context_data(self, **kwargs):
        context = super(ReleveECTSListPDFView, self).get_context_data(**kwargs)
        formation_=Formation.objects.get(id=self.kwargs.get('formation_pk'))
        inscription_list=formation_.inscriptions_actives().order_by('etudiant__nom', 'etudiant__prenom')
        self.filename='RELEVE_ECTS_'+str(formation_)+'.pdf'
        context['inscription_list'] = inscription_list
        context['date'] = datetime.date.today()
        return context

TYPE_DOC_URL={
    'C3L': 'certificat_list_pdf',
    'C2L': 'certificat_old_list_pdf',
    'RP1': 'releve_notes_provisoire_list_pdf',
    'RP2': 'releve_notes_provisoire_list_pdf',
    'RA': 'releve_notes_list_pdf',
    'RECTS': 'releve_ects_list_pdf',
    'FPFE': 'pfe_fiche_list_pdf',
}

def document_list_view(request):
    if not request.user.has_perm('scolar.fonctionnalitenav_etudiants_documentsgroupes'):
        messages.error(request,"Vous n'avez pas la permission d'exécution de cette opération")
        return redirect('/accounts/login/?next=%s' % request.path)
    # if this is a POST request we need to process the form data
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = SelectionFormationForm(request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:            
                form_data=form.cleaned_data
                formation_=form_data['formation']
                type_doc_=form_data['type_document']
                periode_=form_data['periode'] if form_data['periode'] else 0 
                return HttpResponseRedirect(reverse(TYPE_DOC_URL[type_doc_], kwargs={'formation_pk':formation_.id, 'periode_pk':periode_}))
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: La génération de la liste de documents demandés s'est arrêtée avec des erreurs. Merci de le signaler à l'administrateur." )
                    render(request, 'scolar/import.html', {'form': form, 'titre':'Génération de documents groupés.'})
            messages.success(request, "La génération des documents s'est terminée avec succès!")
            # redirect to a new URL:
             
    # if a GET (or any other method) we'll create a blank form
    else:
        form = SelectionFormationForm()
        messages.info(request, "Merci de renseigner les critères de choix des documents à générer.")
        messages.warning(request, "Attention! Assurez vous que les données sont bien présentes dans la base (inscriptions pour les certificats, délibérations pour les relevés.")
    return render(request, 'scolar/import.html', {'form': form, 'titre':'Génération de documents groupés'})

class ResidenceUnivCreateView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, CreateView):
    model = ResidenceUniv
    fields = ['nom', 'adresse', 'tel', 'wilaya', 'commune']
    template_name = 'scolar/create.html'
    success_message = "La résidence universitaire a été créée avec succès!"
    
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalite_configurationetablissement_modification')
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        try:
            form.fields['wilaya'] = forms.ModelChoiceField(
                        queryset=Wilaya.objects.all().order_by('nom'),
                        label=u"Wilaya",
                        widget=ModelSelect2Widget(
                            model=Wilaya,
                            search_fields=['nom__icontains',],
                            #attrs={'style':'width:800px; height:10px;'}
                        ),
                        help_text = "Choisir une wilaya. Tapez deux espaces pour avoir toute la liste.",
                        required = True
                        )
            form.fields['commune'] = forms.ModelChoiceField(
                        queryset=Commune.objects.all().order_by('nom'),
                        label=u"Commune",
                        widget=ModelSelect2Widget(
                            model=Commune,
                            search_fields=['nom__icontains',],
                            dependent_fields={'wilaya':'wilaya'},
                            #attrs={'style':'width:800px; height:10px;'}
                        ),
                        help_text = "Choisir une commune. Tapez deux espaces pour avoir toute la liste.",
                        required = True
                        )

            form.helper.add_input(Submit('submit','Enregistrer', css_class='btn-primary'))
            form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
            self.success_url = reverse('settings')
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors de la création d'une résidence universitaire.")
    
        return form

class ResidenceUnivListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name='scolar/list.html'

    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalite_configurationetablissement_visualisation')
    
    def get_queryset(self,**kwargs):
        return ResidenceUniv.objects.all().order_by('nom')
    
    def get_context_data(self, **kwargs):
        context = super(ResidenceUnivListView, self).get_context_data(**kwargs)
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalite_configurationetablissement_modification'):
            exclude_.append('edit')
            exclude_.append('admin')
        table = ResidenceUnivTable(self.get_queryset(**kwargs), exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['titre'] = "Liste des résidence universitaire"
        context['table'] = table
        context['back'] = reverse('settings')
        btn_list={}
        btn_list['Créer Résidence']=reverse('residenceuniv_create')
        context['btn_list']=btn_list
        
        return context
    
class PreinscriptionCreateView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, CreateView):
    model = Preinscription
    
    fields = ['inscription', 'wilaya_residence', 'commune_residence', 'interne', 'residence_univ', 'adresse_principale', 'photo', 'tel', 'numero_securite_sociale', 'quittance','lycee_bac','fonction_pere','fonction_mere','tel_parents']
    template_name = 'scolar/preinscription_create.html'
    success_message = "Votre pré-inscription est enregistrée avec succès!"
    
    def test_func(self):
        return self.request.user.is_etudiant()
        
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        try:
            inscription_list= Inscription.objects.filter(etudiant=self.request.user.etudiant, decision_jury='X', formation__annee_univ__annee_univ__gte=self.request.user.annee_encours().annee_univ)
            form.fields['inscription'] = forms.ModelChoiceField(label='Inscription en', 
                                                                queryset=inscription_list, 
                                                                initial=0,
                                                                required=True)
            form.fields['photo'].help_text="Si vous voulez changer de photo, merci de déposer ici un scan d'une photo d'identité. Taille maximale 1M."
            form.fields['quittance'].required=True
            form.fields['quittance'].label=u"Frais d'inscription"
            form.fields['quittance'].help_text="Merci de déposer ici une capture d'écran ou un document qui prouve le payement des frais d'inscription. Taille maximale 1M."
            form.fields['numero_securite_sociale'].initial=self.request.user.etudiant.numero_securite_sociale
            form.fields['numero_securite_sociale'].required=True
            form.fields['numero_securite_sociale'].help_text="Merci d'indiquer le numéro figurant sur l'ATS ou carte CHIFA. Si vous ne possédez pas d'assurance, tapez 111."
            form.fields['wilaya_residence'] = forms.ModelChoiceField(
                        queryset=Wilaya.objects.all().order_by('nom'),
                        label=u"Wilaya de résidence principale",
                        initial=self.request.user.etudiant.wilaya_residence,
                        widget=ModelSelect2Widget(
                            model=Wilaya,
                            search_fields=['nom__icontains',],
                            #attrs={'style':'width:800px; height:10px;'}
                        ),
                        help_text = "Choisir une wilaya. Tapez deux espaces pour avoir toute la liste.",
                        required = True
                        )
            form.fields['commune_residence'] = forms.ModelChoiceField(
                        queryset=Commune.objects.all().order_by('nom'),
                        label=u"Commune de résidence principale",
                        initial=self.request.user.etudiant.commune_residence,
                        widget=ModelSelect2Widget(
                            model=Commune,
                            search_fields=['nom__icontains',],
                            dependent_fields={'wilaya_residence':'wilaya'},
                            #attrs={'style':'width:800px; height:10px;'}
                        ),
                        help_text = "Choisir une commune. Tapez deux espaces pour avoir toute la liste.",
                        required = True
                        )
            form.fields['interne'].initial=self.request.user.etudiant.interne
            if self.request.user.etudiant.interne and self.request.user.etudiant.residence_univ:
                residence_univ_candidate=ResidenceUniv.objects.filter(
                                        reduce(lambda x, y: x | y, 
                                               [Q(nom__icontains=mot) for mot in self.request.user.etudiant.residence_univ.split()]))
                if residence_univ_candidate.exists():
                    form.fields['residence_univ'].initial=residence_univ_candidate[0]
            form.fields['adresse_principale'].initial=self.request.user.etudiant.addresse_principale
            form.fields['adresse_principale'].required=True
            form.fields['tel'].initial=self.request.user.etudiant.tel
            form.fields['tel'].help_text="Composé de 10 chiffres sans espace ou autre caratères."
            form.fields['tel'].required=True
            form.fields['tel_parents'].initial=self.request.user.etudiant.tel_parents 
            form.fields['tel_parents'].required=True
            form.fields['tel_parents'].help_text="Veuillez insérer le numéro de téléphone d'un de vos parents."                       
            urls_reglement=''
            for inscription_ in inscription_list:
                if not inscription_.etudiant.lycee_bac:
                    form.fields['lycee_bac'].required=True
                else:
                    form.fields['lycee_bac'].widget = forms.HiddenInput() 
                if not inscription_.etudiant.fonction_pere:       
                    form.fields['fonction_pere'].required=True
                else:
                    form.fields['fonction_pere'].widget = forms.HiddenInput()
                if not inscription_.etudiant.fonction_mere:         
                    form.fields['fonction_mere'].required=True                    
                else:                    
                    form.fields['fonction_mere'].widget = forms.HiddenInput() 
                                           
                if inscription_.formation.programme.cycle and inscription_.formation.programme.cycle.reglement.name:
                    urls_reglement+='<a href="'+inscription_.formation.programme.cycle.reglement.url+'">'+inscription_.formation.programme.code+'</a>,'
            form.fields['engagement'] = forms.BooleanField(required=True,
                                                           initial=False,
                                                           label=mark_safe('J\'ai lu et j\'approuve le réglement intérieur des études ('+urls_reglement+')')
                                                           )
            form.helper.add_input(Submit('submit','Envoyer', css_class='btn-primary'))
            form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
            self.success_url = reverse('home')
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: Vous n'êtes pas sur une liste de pré-inscription. Merci de le signaler à l'administrateur si vous devez vous pré-inscrire à une formation.")
    
        return form

@receiver(post_save, sender=Preinscription)
def email_preinscription_surveillance(sender, update_fields, instance, created, **kwargs):
    if created:
        trace_create(instance.inscription.etudiant.user, instance.inscription.formation.programme.assistant.user if instance.inscription.formation.programme.assistant and instance.inscription.formation.programme.assistant.user else None, 
                                "Une nouvelle demande d'inscription a été déposée: "+'\n'+
                                "Candidat : "+str(instance.inscription.etudiant)+'\n'+
                                "Année d'étude: "+str(instance.inscription.formation)+'\n'+
                                "Lien : "+settings.PROTOCOLE_HOST+reverse('validation_preinscription', kwargs={'inscription_pk':instance.inscription.id}))
        if instance.inscription.formation.programme.assistant and not settings.DEBUG :
            if activation_emails():
                email = EmailMessage('Inscription de '+str(instance.inscription.etudiant)+' en '+str(instance.inscription.formation),
                                     'Bonjour,\n'+ 
                                     "Une nouvelle demande d'inscription a été déposée: "+'\n'
                                     "Candidat : "+str(instance.inscription.etudiant)+'\n'
                                     "Année d'étude: "+str(instance.inscription.formation)+'\n'
                                     'Veuillez traiter cette demande d\'inscription en effectuant les vérifications nécessaires.\n'+
                                     'La demande est accessible à partir de votre compte sous le menu Pré-Inscriptions, ou en suivant ce lien:'+'\n'+
                                     settings.PROTOCOLE_HOST+reverse('preinscription_list')+'\n'+
                                     'Bien cordialement.\n'+
                                     signature_emails(), to=[instance.inscription.formation.programme.get_email_assistant()])
                email.send(fail_silently=True)


class PreinscriptionListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name='scolar/filter_list.html'

    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalitenav_etudiants_preinscriptions')
    
    def get_queryset(self,**kwargs):
        # Ici il y a eu un retour arrière, l'assistant aura désormais toutes les préinscriptions mais il verra les siennes en premier (pour ne pas avoir à créer plusieurs droits d'accès ou un espace pour l'assistant)
        preinscriptions=Preinscription.objects.none()
        if self.request.user.has_perm('scolar.fonctionnalitenav_etudiants_preinscriptions') :
            q1=Q(inscription__formation__programme__assistant__user=self.request.user)
            q2=Q(~Q(inscription__formation__programme__assistant__user=self.request.user))
            preinscriptions = Preinscription.objects.filter(q1 | q2).filter(inscription__formation__programme__doctorat=False).annotate(search_type_ordering=Case(When(q1, then=Value(1)),When(q2, then=Value(0)),default=Value(-1),output_field=models.IntegerField())).order_by('-search_type_ordering', '-id')
            #q2=( q1 | Preinscription.objects.filter(~Q(inscription__formation__programme__assistant__user=self.request.user)).order_by('-id')).distinct()
        return preinscriptions
            
    
    def get_context_data(self, **kwargs):
        context = super(PreinscriptionListView, self).get_context_data(**kwargs)
        filter_ = PreinscriptionFilter(self.request.GET, queryset=self.get_queryset(**kwargs))
        filter_.form.helper = FormHelper()
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalitenav_etudiants_preinscriptions'):
            exclude_.append('edit')
            exclude_.append('admin')
        table = PreinscriptionTable(filter_.qs, exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['filter'] = filter_
        context['table'] = table
        context['titre'] = "Liste des demandes d'inscription"
        context['back'] = reverse('home')
        return context

def validation_preinscription_view(request, inscription_pk):
    inscription_=get_object_or_404(Inscription, id=inscription_pk)
    is_doctorat=False
    if not inscription_.formation.programme.doctorat :
        if not request.user.has_perm('scolar.fonctionnalitenav_etudiants_preinscriptions') :
            messages.error(request,"Vous n'avez pas la permission d'exécution de cette opération")
            return redirect('/accounts/login/?next=%s' % request.path)
    else :
        is_doctorat=True
        if not request.user.has_perm('scolar.fonctionnalitenav_postgraduation_preinscriptions') :
            messages.error(request,"Vous n'avez pas la permission d'exécution de cette opération")
            return redirect('/accounts/login/?next=%s' % request.path)
        
    inscription_annee_precedente_=Inscription.objects.filter(etudiant=inscription_.etudiant,
                                                             formation__annee_univ=inscription_.formation.annee_univ.annee_precedente(),
                                                             formation__programme__diplome=inscription_.formation.programme.diplome
                                                             )
    if inscription_annee_precedente_.count()==1:
        inscription_annee_precedente_= inscription_annee_precedente_.get()
    else:
        inscription_annee_precedente_= None
    
    # if this is a POST request we need to process the form data
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = ValidationPreInscriptionForm(request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:            
                form_data=form.cleaned_data
                if form_data['valider_inscription']=='V':
                    inscription_.etudiant.wilaya_residence= inscription_.preinscription.wilaya_residence
                    inscription_.etudiant.commune_residence= inscription_.preinscription.commune_residence
                    inscription_.etudiant.addresse_principale= inscription_.preinscription.adresse_principale.upper()
                    inscription_.etudiant.tel= inscription_.preinscription.tel
                    inscription_.etudiant.interne= inscription_.preinscription.interne
                    inscription_.etudiant.tel_parents= inscription_.preinscription.tel_parents
                    if not inscription_.etudiant.fonction_pere :
                        inscription_.etudiant.fonction_pere= inscription_.preinscription.fonction_pere
                    if not inscription_.etudiant.fonction_mere:    
                        inscription_.etudiant.fonction_mere= inscription_.preinscription.fonction_mere
                    if not inscription_.etudiant.lycee_bac :                    
                        inscription_.etudiant.lycee_bac= inscription_.preinscription.lycee_bac
                    if inscription_.preinscription.interne:
                        if inscription_.preinscription.residence_univ:
                            inscription_.etudiant.residence_univ= inscription_.preinscription.residence_univ.nom.upper()
                            
                    inscription_.etudiant.numero_securite_sociale= inscription_.preinscription.numero_securite_sociale
                    if inscription_.preinscription.photo.name:
                        if inscription_.etudiant.photo.name != inscription_.etudiant.photo.field.upload_to+'/'+'anonymous-user.jpg':
                            inscription_.etudiant.photo.delete()
                        uploaded_file_name, uploaded_file_extension=os.path.splitext(inscription_.preinscription.photo.name)
                        #photo_file_name=inscription_.etudiant.photo.field.upload_to+'/'+inscription_.etudiant.matricule.replace('/','-')+uploaded_file_extension
                        photo_file_name=inscription_.etudiant.matricule.replace('/','-')+uploaded_file_extension
                        inscription_.etudiant.photo = File(inscription_.preinscription.photo, photo_file_name )
                    if inscription_.preinscription.quittance.name:
                        inscription_.quittance.delete()
                        uploaded_file_name, uploaded_file_extension=os.path.splitext(inscription_.preinscription.quittance.name)
                        #quittance_file_name=inscription_.quittance.field.upload_to+'/'+str(inscription_).replace('/','-').replace(' ','_')+uploaded_file_extension
                        quittance_file_name=str(inscription_.etudiant.matricule).replace('/','-')+uploaded_file_extension
                        inscription_.quittance = File(inscription_.preinscription.quittance, quittance_file_name )
                    inscription_.decision_jury='C'
                    inscription_.etudiant.save()
                    inscription_.save(update_fields=['decision_jury', 'quittance'])
                    inscription_.preinscription.photo.delete()
                    inscription_.preinscription.quittance.delete()
                    Preinscription.objects.filter(inscription=inscription_).delete()
                    
                    #Envoie de notification, relevé et certificat à l'étudiant
                    if activation_emails() and not settings.DEBUG :
                        if not is_doctorat :
                            email = EmailMessage('Votre Inscription en '+str(inscription_.formation),
                                                 'Bonjour '+inscription_.etudiant.prenom+',\n'+ 
                                                 "Votre inscription en : "+str(inscription_.formation)+' est confirmée.\n'
                                                 'Veuillez trouver ci-joints votre certificat de scolarité et votre relevé de notes de l\'année passée s\'il y a lieu.\n'+
                                                 'Ces documents sont une copie, seuls les originaux font foi.\n'+
                                                 "Pour récupérer les originaux, merci de vous rapprocher de la surveillance.\n"+
                                                 'Bien cordialement.\n'+
                                                 signature_emails(), to=[inscription_.etudiant.get_email(), inscription_.formation.programme.get_email_assistant(), request.user.get_email()])
                            
                        else :
                            email = EmailMessage('Votre Inscription en '+str(inscription_.formation),
                                                 'Bonjour '+inscription_.etudiant.prenom+',\n'+ 
                                                 "Votre inscription en : "+str(inscription_.formation)+' est confirmée.\n'
                                                 'S\'il y a lieu, votre certificat de scolarité sera attaché à ce même mail.\n'+
                                                 'Le document est une copie, seul l\'original fait foi.\n'+                                                 
                                                 'Bien cordialement.\n'+
                                                 signature_emails(), to=[inscription_.etudiant.get_email(), inscription_.formation.programme.get_email_assistant(), request.user.get_email()])
                        
                        if inscription_.formation.programme.activation_certificat_scolarite() :
                            cmd_options={
                                'orientation':'Landscape',
                                'page-size':'A4',
                                }
                            certificat_filename='CERTIFICAT_'+str(inscription_).replace(' ','_')+'.pdf'
                            context={}
                            context['inscription'] = inscription_
                            context['date'] = datetime.date.today()
                            context['categorie_ue']=dict(CAT_UE)
                            context['decision_jury']=dict(DECISIONS_JURY)
                            context['pdf']=1
                            context['range'] = ['f','o']
                            context['credits'] = 1 if inscription_.formation.activation_credits() else None
                            context['signature'] = 1
                            context['institution'] = inscription_.etudiant.user.institution()
                            certificat_pdf_=render_pdf_from_template(input_template='scolar/certificat_pdf.html', 
                                                          header_template=None,
                                                          footer_template=None,
                                                          context=context, 
                                                          cmd_options=cmd_options)
                            email.attach(certificat_filename, certificat_pdf_, 'application/pdf' )
                        
                        if inscription_.formation.programme.activation_fiche_inscription() :
                            cmd_options={
                                'orientation':'Portrait',
                                'page-size':'A4',
                                }
                            
                            fiche_filename='FICHE_INSCRIPTION'+str(inscription_)+'.pdf'
                            context['inscription_annee_precedente'] = inscription_annee_precedente_
                            fiche_pdf_=render_pdf_from_template(input_template='scolar/fiche_inscription_pdf.html', 
                                                          header_template=None,
                                                          footer_template=None,
                                                          context=context, 
                                                          cmd_options=cmd_options)
                            email.attach(fiche_filename, fiche_pdf_, 'application/pdf' )
                        
                        if inscription_annee_precedente_ and inscription_annee_precedente_.formation.programme.activation_releve_notes_fr() : 
                            cmd_options={
                                'orientation':'Landscape',
                                'page-size':'A4',
                                }
                            
                            context['inscription'] = inscription_annee_precedente_
                            releve_filename='RELEVE_ANNUEL_'+str(inscription_annee_precedente_).replace(' ','_')+'.pdf'
                            releve_pdf_=render_pdf_from_template(input_template='scolar/releve_notes_pdf.html', 
                                                          header_template=None,
                                                          footer_template=None,
                                                          context=context, 
                                                          cmd_options=cmd_options)
                            email.attach(releve_filename, releve_pdf_, 'application/pdf' )
                    
                        email.send(fail_silently=True)
                    
                    trace_create(request.user, inscription_.etudiant, "Préinscription en "+str(inscription_.formation)+" validée.")        
                    messages.success(request, "La préinscription a été validée avec succès!")
                else:
                    inscription_.preinscription.photo.delete()
                    inscription_.preinscription.quittance.delete()
                    Preinscription.objects.filter(inscription=inscription_).delete()
                    if not settings.DEBUG :
                        if activation_emails():
                            email = EmailMessage('Votre Inscription en '+str(inscription_.formation),
                                                 'Bonjour '+inscription_.etudiant.prenom+',\n'+ 
                                                 "Votre inscription en : "+str(inscription_.formation)+' n\'a pas été validée.\n'
                                                 'Motif de refus:\n'+
                                                 str(form_data['motif_refus'])+'\n'+
                                                 'Bien cordialement.\n'+
                                                 signature_emails(), to=[inscription_.etudiant.get_email(), request.user.get_email()])
                            
                            email.send(fail_silently=True)
                    trace_create(request.user, inscription_.etudiant, "Préinscription en "+str(inscription_.formation)+" rejetée. Motif de refus : "+str(form_data['motif_refus']))  
                    messages.warning(request, "La préinscription n'a pas été validée! Une notification a été envoyée à l'étudiant pour compléter son dossier.")
                    
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: lors de la validation de la préinscription. Merci de le signaler à l'administrateur." )
                
            # redirect to a new URL:
            #return HttpResponseRedirect(reverse('preinscription_list')) 
            if not is_doctorat :
                return HttpResponseRedirect(reverse('preinscription_list'))
            else :
                return HttpResponseRedirect(reverse('preinscription_doctorat_list'))
                
    # if a GET (or any other method) we'll create a blank form
    else:
        form = ValidationPreInscriptionForm()
        context={
                'form': form,
                'inscription': inscription_,
                'inscription_annee_precedente': inscription_annee_precedente_,
                'decision_jury':dict(DECISIONS_JURY),
                'titre': 'Validation de la Pré-Inscription de '+str(inscription_)
            }
        
        messages.info(request, "Merci de vérifier ces informations avant de valider l'inscription.")
        messages.warning(request, "Attention! Si une nouvelle photo est présente assurez vous qu'elle est semblable à l'ancienne. Sinon, refusez l'inscription.")
    return render(request, 'scolar/validation_preinscription.html', context)

    
class PVPFEPDFView(LoginRequiredMixin, UserPassesTestMixin, PDFTemplateView):
    template_name = 'scolar/pv_pfe_pdf.html'
    cmd_options={
        'orientation':'Portrait',
        'page-size':'A4',
        }
    def test_func(self):
        module_=Module.objects.get(id=self.kwargs.get('module_pk'))       
        return (self.request.user.has_perm('scolar.fonctionnalitenav_stages_visualisationsoutenances') and module_.matiere.pfe) or ((self.request.user.is_coordinateur(module_) or self.request.user.has_perm('scolar.fonctionnalitenav_stages_visualisationsoutenancesequipes'))and module_.formation.programme.matiere_equipe==module_.matiere)
    def get_context_data(self, **kwargs):
        context = super(PVPFEPDFView, self).get_context_data(**kwargs)
        groupe_=Groupe.objects.get(id=self.kwargs.get('groupe_pk'))
        module_=Module.objects.get(id=self.kwargs.get('module_pk'))
        self.filename='PV_'+str(groupe_.code)
        resultat_list={}
        if not groupe_.is_equipe() :
            resultats=Resultat.objects.filter(module=module_, resultat_ue__inscription_periode__groupe=groupe_)
        else :
            resultats=Resultat.objects.filter(ancien_resultat__isnull=True, module__matiere=module_.matiere, inscription__in=groupe_.pfe.equipe.inscriptions.all())
        for resultat_ in resultats :
            resultat_list[resultat_.inscription.etudiant.matricule]=resultat_
            self.filename+='_'+str(resultat_.inscription.etudiant.nom)
        self.filename+='.pdf'
        # Attention, si on télécharge le PV, on marque la saisie des notes comme terminée
        # Ca pose problème, quand l'assistante vérifie s'il y a PV, elle verrouille la saisie
        # Il faut remettre la possibilité au jury de choisir entre un simple enregsitrement ou envoie de PV
#         module_suivi_=get_object_or_404(ModulesSuivis, groupe=groupe_, module=module_)
#         module_suivi_.saisie_notes='T'
#         module_suivi_.save()
        context['groupe'] = groupe_
        if not groupe_.is_equipe() :
            context['inscrits_periode']=groupe_.inscrits_periode.all()
        else :
            #context['equipe']=groupe_.pfe.equipe
            objets_contenant_inscriptions=[]
            for resultat_ in resultats :
                objets_contenant_inscriptions.append(resultat_)
            context['inscrits_periode']=objets_contenant_inscriptions
                 
        context['module'] = module_
        context['resultat_list'] = resultat_list
        context['date'] = datetime.date.today()
        context['mention']=dict(MENTION)
        context['decision_jury']=dict(DECISIONS_JURY)
        context['options_depot']=dict(OPTIONS_DEPOT)
        return context


class ReleveNotesProvisoirePDFView(LoginRequiredMixin, UserPassesTestMixin, PDFTemplateView):
    template_name = 'scolar/releve_notes_provisoire_pdf.html'
    cmd_options={
        'orientation':'Landscape',
        'page-size':'A4',
        }
    def test_func(self):
        inscription_=Inscription.objects.get(id=self.kwargs.get('inscription_pk'))
        return self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_etudiants_documents', inscription_.etudiant.matricule) or self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_etudiants_documentsnonsignes', inscription_.etudiant.matricule)
    
    def get_context_data(self, **kwargs):
        context = super(ReleveNotesProvisoirePDFView, self).get_context_data(**kwargs)
        inscription_=Inscription.objects.get(id=self.kwargs.get('inscription_pk'))
        periode_=PeriodeProgramme.objects.get(id=self.kwargs.get('periode_pk'))
        self.filename=str(inscription_)+'.pdf'
        context['inscription'] = inscription_
        context['periode']=inscription_.inscription_periodes.all().get(periodepgm=periode_)
        context['date'] = datetime.date.today()
        context['categorie_ue']=dict(CAT_UE)
        context['credits'] = 1 if inscription_.formation.programme.activation_credits() else None

        return context

class ReleveNotesProvisoireListPDFView(LoginRequiredMixin, UserPassesTestMixin, PDFTemplateView):
    template_name = 'scolar/releve_notes_provisoire_list_pdf.html'
    cmd_options={
        'orientation':'Landscape',
        'page-size':'A4',
        }
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalite_etudiants_documents')
    
    def get_context_data(self, **kwargs):
        context = super(ReleveNotesProvisoireListPDFView, self).get_context_data(**kwargs)
        formation_=Formation.objects.get(id=self.kwargs.get('formation_pk'))
        periode_=Periode.objects.get(id=self.kwargs.get('periode_pk'))
        inscription_periode_list=InscriptionPeriode.objects.filter(inscription__formation=formation_, periodepgm__periode=periode_).exclude(groupe__isnull=True).exclude(inscription__decision_jury='X')
        self.filename='RELEVES_PROVISOIRE_'+str(formation_)+'.pdf'
        context['inscription_periode_list'] = inscription_periode_list
        context['date'] = datetime.date.today()
        context['categorie_ue']=dict(CAT_UE)
        context['credits'] = 1 if formation_.activation_credits() else None

        return context



class ReleveECTSPDFView(LoginRequiredMixin, UserPassesTestMixin, PDFTemplateView):
    template_name = 'scolar/releve_ects_pdf.html'
    cmd_options={
        'orientation':'Portrait',
        'page-size':'A3',
        }
    
    def test_func(self):
        inscription_=Inscription.objects.get(id=self.kwargs.get('inscription_pk'))
        return self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_etudiants_documents', inscription_.etudiant.matricule) or self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_etudiants_documentsnonsignes', inscription_.etudiant.matricule)
    
    def get_context_data(self, **kwargs):
        context = super(ReleveECTSPDFView, self).get_context_data(**kwargs)
        inscription_=Inscription.objects.get(id=self.kwargs.get('inscription_pk'))
        self.filename = str(inscription_.etudiant)+'_ECTS.pdf'
            
        context['inscription'] = inscription_
        context['date'] = datetime.date.today()
        return context


class ReleveECTSView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name = 'scolar/releve_ects.html'
    
    def test_func(self):
        inscription_=Inscription.objects.get(id=self.kwargs.get('inscription_pk'))
        return self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_etudiants_visualisationnotesprofil', inscription_.etudiant.matricule)
    
    def get_context_data(self, **kwargs):
        context = super(ReleveECTSView, self).get_context_data(**kwargs)
        inscription_=Inscription.objects.get(id=self.kwargs.get('inscription_pk'))
        context['inscription'] = inscription_

        return context


def import_deliberation_view(request, annee_univ_pk):
    if not request.user.has_perm('scolar.fonctionnalitenav_pedagogie_generationpvsdeliberation'):
        return redirect('/accounts/login/?next=%s' % request.path)

    # if this is a POST request we need to process the form data
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = ImportDeliberationForm(annee_univ_pk, request.POST, request.FILES)
        # check whether it's valid:
        if form.is_valid():
            try:            
                deliberation_file = request.FILES['file']
                dataset = Dataset()
                imported_data = dataset.load(deliberation_file.read(), format ='xlsx')
                # la première ligne du fichier doit contenir des entêtes, au moins Matricule Nom, Prenom, MoyAn,Rang, Decision
                # insert imported_data in inscription table
                form_data=form.cleaned_data
                formation_=form_data['formation']
                # initialiser les decisions_jury en cours à Non Inscrit
                Inscription.objects.filter(formation=formation_, decision_jury='C').update(decision_jury='X')
             
                t = threading.Thread(target=task_deliberation_import,args=[formation_, imported_data, request.user])
                t.setDaemon(True)
                t.start()
            
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: L'import du PV de délibération n'a pas réussit. Il doit y avoir un problème de format")
                    messages.info(request,"Indiquer le fichier .xlsx du PV de délibération annuel.")
                    messages.info(request,"La première ligne du fichier doit comporter au moins les colonnes suivantes: Matricule, NomEtud, Prenoms, Rang, Decision, MoyAn, (également 'RMoyAn' si le rattrapage est activé pour la formation, ainsi que RACMoyAn si la moyenne de rachat est importée).")
                    messages.info(request,"La colonne Decision doit correspondre à une des valeurs: Admis, Non Admis, Admis avec rachat, Admis avec rattrapage, Admis avec dettes, Maladie, Abandon, Redouble, Non Inscrit,'Admis au Concours','Admis au Concours avec Rachat','Transfert'.")
                    render(request, 'scolar/import.html', {'form': form, 'titre':'Importer les Délibérations'})
            # redirect to a new URL:
            messages.success(request, "Votre demande d'import du PV de délibérations a été prise en compte. Une notification vous sera transmise aussitôt effectuée.")
            return HttpResponseRedirect(reverse('deliberation_detail', kwargs={'formation_pk':formation_.id, })) 
    # if a GET (or any other method) we'll create a blank form
    else:
        form = ImportDeliberationForm(annee_univ_pk)
        messages.info(request,"Indiquer le fichier .xlsx du PV de délibération annuel.")        
        messages.info(request,"La première ligne du fichier doit comporter au moins les colonnes suivantes: Matricule, NomEtud, Prenoms, Rang, Decision, MoyAn, (également 'RMoyAn' si le rattrapage est activé pour la formation, ainsi que RACMoyAn si la moyenne de rachat est importée).")
        messages.info(request,"La colonne Decision doit correspondre à une des valeurs: Admis, Non Admis, Admis avec rachat, Admis avec rattrapage, Admis avec dettes, Maladie, Abandon, Redouble, Non Inscrit,'Admis au Concours','Admis au Concours avec Rachat','Transfert'.")
    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer les Délibérations'})

def task_deliberation_import(formation_, imported_data, user):
    try:
        with transaction.atomic() :
            for row in imported_data.dict :
               
                etudiant_, created=Etudiant.objects.get_or_create(matricule=str(row['Matricule']).strip(), defaults={
                    'matricule':str(row['Matricule']).strip(),
                    'nom':str(row['NomEtud']).strip() ,
                    'prenom':str(row['Prenoms']).strip()
                    })
                inscription_, created =Inscription.objects.get_or_create(etudiant=etudiant_, formation=formation_, defaults={
                    'etudiant':etudiant_,
                    'formation':formation_,
                })
                rang_=int(row['Rang'])
                decision_=row['Decision']
                if decision_=='Admis':
                    decision_='A'
                elif decision_=='Admis avec rachat':
                    decision_='AR'
                elif decision_=='Admis avec rattrapage':
                    decision_='SR'
                elif decision_=='Admis avec dettes':
                    decision_='AD'
                elif decision_=='Abandon':
                    decision_='F'
                elif decision_=='Redouble':
                    decision_='R'
                elif decision_=='Maladie':
                    decision_='M1'
                elif decision_=='Non Admis':
                    decision_='N'
                elif decision_=='Admis au Concours':
                    decision_='AC'
                elif decision_=='Admis au Concours avec Rachat':
                    decision_='CR'
                elif decision_=='Transfert':
                    decision_='FT'                               
                else:
                    decision_='X'
                RACMoyAn=0.0                 
                try:
                    inscription_.moy=decimal.Decimal(str(row['MoyAn']).replace(",","."))
                    #inscription_.moy_post_delib=inscription_.moy
                    RACMoyAn = row.get('RACMoyAn')
                    if RACMoyAn :
                        inscription_.moy_ra=decimal.Decimal(str(row['RACMoyAn']).replace(",","."))
                    else :
                        inscription_.reset_moy_ra()
                except Exception :
                    inscription_.moy=inscription_.moyenne()
                    inscription_.moy_ra=inscription_.moyenne_post_delib()
                inscription_.rang=rang_
                inscription_.decision_jury=decision_
                #inscription_.save(update_fields=['moy','moy_post_delib', 'rang','decision_jury'])
                if RACMoyAn :
                    inscription_.save(update_fields=['moy', 'rang','decision_jury','moy_ra'])
                else :
                    inscription_.save(update_fields=['moy', 'rang','decision_jury'])
                
                # indiquer les modules acquis et calculer les ECTS
                for resultat_ in Resultat.objects.filter(ancien_resultat__isnull=True, inscription=inscription_):
                    resultat_.ects=resultat_.calcul_ects()
                    #resultat_.ects_post_delib=resultat_.ects
                    if resultat_.moy>=10:
                        resultat_.acquis=True
                    else:
                        resultat_.acquis=False
                    resultat_.save(update_fields=['ects', 'acquis'])
    
            formation_.archive=True
            formation_.save(update_fields=['archive'])    
    except Exception:
        trace_create(user, user, 'Une erreur s\'est produite lors de l\'importation du PV de délibération de '+str(formation_))
        if settings.DEBUG:
            raise Exception
        else:
            if activation_emails():
                email = EmailMessage('[Talents] Erreur lors de l\importation du PV de délibération de la formation '+str(formation_),
                                     'Bonjour,\n'+ 
                                     'Une erreur s\'est produite lors de l\'importation du PV de délibération de '+str(formation_)+'\n'+
                                     'Veuillez vérifier les données et réessayer l\'importation \n'+
                                     'Bien cordialement.\n'+
                                     signature_emails(), to=[user.get_email()] )
                email.send(fail_silently=True)
    else :
        trace_create(user, user, 'L\'importation du PV de délibération de la formation '+str(formation_)+' a bien été effectuée')
        if activation_emails():
            email = EmailMessage('[Talents] Confirmation de l\'importation du PV de délibération de la formation '+str(formation_),
                                 'Bonjour,\n'+ 
                                 'L\'importation du PV de délibération de la formation '+str(formation_)+' a bien été effectuée \n'+
                                 'Nous vous en remercions \n'+
                                 'Bien cordialement.\n'+
                                 signature_emails(), to=[user.get_email()] )
            email.send(fail_silently=True)

@login_required
def export_inscriptions(request, formation_pk):
    if not request.user.has_perm('scolar.fonctionnalitenav_planification_visualisationformations'):
        messages.error(request, "Vous n'êtes pas autorisés à excéuter cette opération.")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    try:
        # Create the HttpResponse object with the appropriate CSV header.
        formation_=get_object_or_404(Formation, id=formation_pk)
        inscription_list=Inscription.objects.filter(formation=formation_).order_by('etudiant__nom', 'etudiant__prenom')
        header=['Matricule','NomEtud', 'Prenoms', 'Genre', 'Ddn', 'Section', 'Groupe', 'Situation', 'Observation',
                       'LieuNaissance', 'WilayaNaissance', 'NomEtudA', 'PrenomsA', 'LieuNaissanceA', 
                       'Email', 'Telephone', 'AdressePrincipale', 'WilayaResidence', 'CommuneResidence',
                       'Interne', 'ResidenceU','AnneeBac','SerieBac']
        sheet=Dataset()
        sheet.headers = header
    
        for inscription_ in inscription_list :
            row_=[]
            row_.append(str(inscription_.etudiant.matricule))
            row_.append(inscription_.etudiant.nom)
            row_.append(inscription_.etudiant.prenom)
            row_.append(inscription_.etudiant.sexe if inscription_.etudiant.sexe else '')
            row_.append(inscription_.etudiant.date_naissance if inscription_.etudiant.date_naissance else '')
            row_.append(inscription_.groupe.section.code if inscription_.groupe and inscription_.groupe.section else '')
            row_.append(inscription_.groupe.code if inscription_.groupe else '')
            row_.append(dict(DECISIONS_JURY)[inscription_.decision_jury])
            row_.append(inscription_.observation if inscription_.observation else '')
            row_.append(inscription_.etudiant.lieu_naissance if inscription_.etudiant.lieu_naissance else '')
            row_.append(inscription_.etudiant.wilaya_naissance.code if inscription_.etudiant.wilaya_naissance else '')            
            row_.append(inscription_.etudiant.nom_a if inscription_.etudiant.nom_a else '')
            row_.append(inscription_.etudiant.prenom_a if inscription_.etudiant.prenom_a else '')
            row_.append(inscription_.etudiant.lieu_naissance_a if inscription_.etudiant.lieu_naissance_a else '')
            row_.append(inscription_.etudiant.get_email())
            row_.append(str(inscription_.etudiant.tel) if inscription_.etudiant.tel else '')
            row_.append(inscription_.etudiant.addresse_principale if inscription_.etudiant.addresse_principale else '')            
            row_.append(inscription_.etudiant.wilaya_residence.code if inscription_.etudiant.wilaya_residence else '')
            row_.append(inscription_.etudiant.commune_residence.code_postal if inscription_.etudiant.commune_residence else '')
            row_.append("Oui" if inscription_.etudiant.interne else "Non")
            row_.append(inscription_.etudiant.residence_univ if inscription_.etudiant.residence_univ else '')
            #row_.append(inscription_.etudiant.n_inscription_bac if inscription_.etudiant.n_inscription_bac else '')
            row_.append(inscription_.etudiant.annee_bac if inscription_.etudiant.annee_bac else '')
            row_.append(dict(Serie_bac)[inscription_.etudiant.serie_bac] if inscription_.etudiant.serie_bac and dict(Serie_bac)[inscription_.etudiant.serie_bac] else '')
            # row_.append(inscription_.etudiant.moyenne_bac if inscription_.etudiant.moyenne_bac else '')
            # row_.append(inscription_.etudiant.prenom_pere if inscription_.etudiant.prenom_pere else '')
            # row_.append(inscription_.etudiant.prenom_pere_a if inscription_.etudiant.prenom_pere_a else '')
            # row_.append(inscription_.etudiant.nom_mere if inscription_.etudiant.nom_mere else '')
            # row_.append(inscription_.etudiant.nom_mere_a if inscription_.etudiant.nom_mere_a else '')
            # row_.append(inscription_.etudiant.prenom_mere if inscription_.etudiant.prenom_mere else '')
            # row_.append(inscription_.etudiant.prenom_mere_a if inscription_.etudiant.prenom_mere_a else '')
            # row_.append(inscription_.etudiant.matricule_progres if inscription_.etudiant.matricule_progres else '')   
            # row_.append(inscription_.etudiant.numero_securite_sociale)
            sheet.append(row_)
            
        filename='LISTE_'+str(formation_)+'.xlsx'
        filename=filename.replace(' ','_')

        response = HttpResponse(content_type='application/vnd.ms-excel')
        response['Content-Disposition'] = 'attachment; filename='+filename+";"
        response.write(sheet.xlsx)
    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            messages.error(request, "ERREUR: Il y a eu une erreur lors de l'export du fichier des notes. Merci de le signaler à l'administrateur.")
    return response

@login_required
def export_affectations_progres(request, formation_pk):
    if not request.user.has_perm('scolar.fonctionnalite_pedagogie_exportationnotesprogres'):
        messages.error(request, "Vous n'êtes pas autorisés à excéuter cette opération.")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    try:
        # Create the HttpResponse object with the appropriate CSV header.
        formation_=get_object_or_404(Formation, id=formation_pk)
        inscription_list=Inscription.objects.filter(formation=formation_).filter(Q(decision_jury = 'C')|Q(decision_jury = 'A')|Q(decision_jury = 'AR')|Q(decision_jury = 'SR')|Q(decision_jury = 'AD')|Q(decision_jury = 'AC')|Q(decision_jury = 'CR')).order_by('etudiant__nom', 'etudiant__prenom')
        header=['Numéro Inscription','Année Bac','Matricule','Nom', 'Prénom','Section','Groupe']
        sheet=Dataset()
        sheet.headers = header
    
        for inscription_ in inscription_list :
            row_=[]
            row_.append(' ')# inscription_.etudiant.numeroinscription if inscription_.etudiant.numeroinscriptionelse ''
            row_.append(' ')# inscription_.etudiant.annee_bac if inscription_.etudiant.annee_bac  else ''
            row_.append(inscription_.etudiant.matricule_progres)          
            row_.append(inscription_.etudiant.nom)
            row_.append(inscription_.etudiant.prenom)
            row_.append(inscription_.groupe.section.code if inscription_.groupe.section.code else '')
            row_.append(inscription_.groupe.code if inscription_.groupe else '')
            sheet.append(row_)
            
        filename='LISTE_'+str(formation_)+'.xlsx'
        filename=filename.replace(' ','_')

        response = HttpResponse(content_type='application/vnd.ms-excel')
        response['Content-Disposition'] = 'attachment; filename='+filename+";"
        response.write(sheet.xlsx)
    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            messages.error(request, "ERREUR: Il y a eu une erreur lors de l'export du fichier des affectations. Merci de le signaler à l'administrateur.")
    return response

class ExportListView(LoginRequiredMixin, PermissionRequiredMixin, TemplateView):
    template_name='scolar/list.html'    
    permission_required = 'scolar.fonctionnalitenav_Export_exportationlistes' 
       
    def get_context_data(self, **kwargs):
        context = super(ExportListView, self).get_context_data(**kwargs)        
        table = ExportTable(AnneeUniv.objects.all().order_by('-annee_univ'))
        RequestConfig(self.request).configure(table)
        context['titre'] ='Listes à exporter'
        context['table'] = table
        context['back'] = self.request.META.get('HTTP_REFERER')   
        context['webhelp']=format_html(HELP_EXPORT_DIFFERENTES_LISTES)     
        return context

@login_required    
def export_serv_national_list(request,annee_univ_pk):
    if not request.user.has_perm('scolar.fonctionnalitenav_Export_exportationlistes'):
        messages.error(request, "Vous n'êtes pas autorisés à excéuter cette opération.")
        return redirect('/accounts/login/?next=%s' % request.path)
    try:        
        annee_univ_=AnneeUniv.objects.get(annee_univ=annee_univ_pk)        
        #filtrer les garçons sortants:non admis, abandons.. de de l'année encours et l'année précédente.        
        if annee_univ_.encours==True:           
            sortants_list=Inscription.objects.filter(Q(formation__annee_univ=annee_univ_)|Q(formation__annee_univ=annee_univ_.annee_precedente()),etudiant__sexe='M').filter(Q(decision_jury='F') | Q(decision_jury='N')| Q(decision_jury='X')|Q(decision_jury='AC')).exclude(formation__programme__code__startswith='MS').order_by('formation__programme__ordre')
        else :
            sortants_list=Inscription.objects.filter(Q(formation__annee_univ=annee_univ_)|Q(formation__annee_univ=annee_univ_.annee_precedente()),etudiant__sexe='M').exclude(formation__programme__code__startswith='MS').order_by('formation__programme__ordre')
        #filtres les garçons de l'année encours       
        annee_encours_list=Inscription.objects.filter(formation__annee_univ=annee_univ_,etudiant__sexe='M').filter(Q(decision_jury='C')| Q(decision_jury__startswith='M')| Q(decision_jury='X')).exclude(formation__programme__code__startswith='MS').order_by('formation__programme__ordre')
        #filtrer les diplomés de l'année précédente   
        diplomes_list=Inscription.objects.filter(formation__annee_univ=annee_univ_.annee_precedente(),formation__programme__ordre__gte=5 ,etudiant__sexe='M').filter(decision_jury='A').exclude(formation__programme__code__startswith='MS').order_by('formation__programme__ordre')
        resultat_list=[]
        resultat_list=annee_encours_list|diplomes_list|sortants_list        
        situation_list=[]
        situation_list=["Maladie" if inscription_.decision_jury.startswith('M') else dict(DECISIONS_JURY)[inscription_.decision_jury]for inscription_ in resultat_list]
        institution_ = get_institution()
        book=Databook()
        cpt = 0
        for decision_ in set(situation_list):
            sheet=Dataset(title="Diplomes" if decision_=='Admis' else decision_)                                                              
            header=['Matricule','NOM','PNOM', 'NOMA',  'PNOMA','D_N','LIEU_NAIS','W_NAIS','CO_RESIDENCE','PPERE','NMERE', 
                'PMERE','ADRESSE','CODE_NIV','PROMO','CODE_DIP','CODE_SPECIALITE','CODE_ETABLISSEMENT','CODE_CYSCLE','CODE_STADE','SITUATION','ANNEE']           
            sheet.headers = header            
            cpt+=1
            for inscription_ in resultat_list:                                
                row_=[]
                if ("Maladie" if inscription_.decision_jury.startswith('M') else dict(DECISIONS_JURY)[inscription_.decision_jury])==decision_:                                             
                    row_.append(inscription_.etudiant.matricule)            
                    row_.append(inscription_.etudiant.nom)
                    row_.append(inscription_.etudiant.prenom)
                    row_.append(inscription_.etudiant.nom_a)
                    row_.append(inscription_.etudiant.prenom_a)
                    row_.append(inscription_.etudiant.date_naissance.strftime('%d/%m/%Y') if inscription_.etudiant.date_naissance else '')            
                    row_.append(inscription_.etudiant.lieu_naissance)
                    row_.append(inscription_.etudiant.wilaya_naissance.code if inscription_.etudiant.wilaya_naissance else '')
                    row_.append(inscription_.etudiant.commune_residence.code_postal if inscription_.etudiant.commune_residence else '')                    
                    row_.append(inscription_.etudiant.prenom_pere)
                    row_.append(inscription_.etudiant.nom_mere)
                    row_.append(inscription_.etudiant.prenom_mere) 
                    row_.append(inscription_.etudiant.addresse_principale)
                    row_.append(inscription_.formation.programme.code_serv_national)            
                    row_.append(inscription_.formation.programme)                    
                    row_.append(inscription_.formation.programme.diplome.code_diplome)
                    row_.append(inscription_.formation.programme.diplome.code_filiere)                    
                    row_.append(institution_.code_etablissement) if institution_.code_etablissement else row_.append('')
                    row_.append(inscription_.formation.programme.diplome.code_cycle)                    
                    row_.append('')
                    row_.append("Maladie" if inscription_.decision_jury.startswith('M') else dict(DECISIONS_JURY)[inscription_.decision_jury])                    
                    row_.append(inscription_.formation.annee_univ)                                
                    sheet.append(row_)                                       
                 
            book.add_sheet(sheet)
        if not cpt :
            sheet=Dataset(title="Vide")
            book.add_sheet(sheet)
            
        filename='Liste_Service_National'+str(annee_univ_)+'.xlsx'
        response = HttpResponse(content_type='application/vnd.ms-excel')
        response['Content-Disposition'] = 'attachment; filename='+filename+";"
        response.write(book.export('xlsx'))
    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            messages.error(request, "ERREUR: Il y a eu une erreur lors de l'exportation du fichier. Merci de le signaler à l'administrateur.")
    return response

@login_required
def export_maladie_list(request,annee_univ_pk):
    if not request.user.has_perm('scolar.fonctionnalitenav_Export_exportationlistes'):
        messages.error(request, "Vous n'êtes pas autorisés à excéuter cette opération.")
        return redirect('/accounts/login/?next=%s' % request.path)
    try:        
        annee_univ_=AnneeUniv.objects.get(annee_univ=annee_univ_pk)
        Maladie_list=Inscription.objects.filter(formation__annee_univ=annee_univ_,decision_jury__startswith='M').exclude(formation__programme__code__startswith='MS').order_by('formation__programme__ordre','etudiant__nom')        
        sheet=Dataset(title="Maladie")                                                              
        header=['Matricule','Nom','Prenom','Promo','Situation','Observation','annee']           
        sheet.headers = header            
        for inscription_ in Maladie_list:                                
            row_=[]                                         
            row_.append(inscription_.etudiant.matricule)            
            row_.append(inscription_.etudiant.nom)
            row_.append(inscription_.etudiant.prenom)
            row_.append(inscription_.formation.programme) 
            row_.append(dict(DECISIONS_JURY)[inscription_.decision_jury])
            row_.append(inscription_.observation)                      
            row_.append(inscription_.formation.annee_univ)                                
            sheet.append(row_)  
                             
        filename='Liste_Maladies'+str(annee_univ_)+'.xlsx'
        response = HttpResponse(content_type='application/vnd.ms-excel')
        response['Content-Disposition'] = 'attachment; filename='+filename+";"
        response.write(sheet.export('xlsx'))
    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            messages.error(request, "ERREUR: Il y a eu une erreur lors de l'exportation du fichier. Merci de le signaler à l'administration.")
    return response

@login_required
def export_sortants_list(request,annee_univ_pk):
    if not request.user.has_perm('scolar.fonctionnalitenav_Export_exportationlistes'):
        messages.error(request, "Vous n'êtes pas autorisés à excéuter cette opération.")
        return redirect('/accounts/login/?next=%s' % request.path)
    try:        
        annee_univ_=AnneeUniv.objects.get(annee_univ=annee_univ_pk)
        sortants_list=Inscription.objects.filter(formation__annee_univ=annee_univ_).filter(Q(decision_jury='F') | Q(decision_jury='N')| Q(decision_jury='X')| Q(decision_jury='FT')|Q(decision_jury='AC')|Q(decision_jury='CR')).order_by('decision_jury','formation__programme__ordre','etudiant__nom')       
        situation_list=[]
        situation_list=[dict(DECISIONS_JURY)[inscription_.decision_jury]for inscription_ in sortants_list]
        book=Databook()
        cpt=0
        for decision_ in set(situation_list):        
            sheet=Dataset(title=decision_)                                                              
            header=['Matricule','Nom','Prenom','Promo','Situation','Observation','annee','Matricule Progres']           
            sheet.headers = header   
            cpt+=1         
            for inscription_ in sortants_list:                                
                row_=[]
                if (dict(DECISIONS_JURY)[inscription_.decision_jury])==decision_:                                         
                    row_.append(inscription_.etudiant.matricule)            
                    row_.append(inscription_.etudiant.nom)
                    row_.append(inscription_.etudiant.prenom)
                    row_.append(inscription_.formation.programme) 
                    row_.append(dict(DECISIONS_JURY)[inscription_.decision_jury])
                    row_.append(inscription_.observation)                      
                    row_.append(inscription_.formation.annee_univ)
                    row_.append(inscription_.etudiant.matricule_progres)                                
                    sheet.append(row_)
            book.add_sheet(sheet)      
        if not cpt :
            sheet=Dataset(title="Vide")
            book.add_sheet(sheet)
        filename='Liste des sortants'+str(annee_univ_)+'.xlsx'
        response = HttpResponse(content_type='application/vnd.ms-excel')
        response['Content-Disposition'] = 'attachment; filename='+filename+";"
        response.write(book.export('xlsx'))
    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            messages.error(request, "ERREUR: Il y a eu une erreur lors de l'exportation du fichier. Merci de le signaler à l'administration.")
    return response

@login_required
def export_ETUDIANTS_list(request,annee_univ_pk):
    if not request.user.has_perm('scolar.fonctionnalitenav_Export_exportationlistes'):
        messages.error(request, "Vous n'êtes pas autorisés à excéuter cette opération.")
        return redirect('/accounts/login/?next=%s' % request.path)
    try:        
        annee_univ_=AnneeUniv.objects.get(annee_univ=annee_univ_pk)
        Maladie_list=Inscription.objects.filter(formation__annee_univ=annee_univ_).exclude(formation__programme__code__startswith='MS').order_by('formation__programme__ordre','etudiant__nom')        
        sheet=Dataset(title="Etudiants"+str(annee_univ_))                                                              
        header=['Promo','Matricule','Groupe','Nom','Prenom','PrenomPere','NomMere','PrenomMere','Genre','DateNais','LieuNais','WilayaReridence','Situation','Observation','Interne','Matricule Progres','Serie Bac',]           
        sheet.headers = header            
        for inscription_ in Maladie_list:                                
            row_=[]                                         
            row_.append(inscription_.formation.programme)
            row_.append(inscription_.etudiant.matricule)
            row_.append(inscription_.groupe.code if inscription_.groupe else '')            
            row_.append(inscription_.etudiant.nom)
            row_.append(inscription_.etudiant.prenom)
            row_.append(inscription_.etudiant.prenom_pere if inscription_.etudiant.prenom_pere else '')
            row_.append(inscription_.etudiant.nom_mere if inscription_.etudiant.nom_mere else '')
            row_.append(inscription_.etudiant.prenom_mere if inscription_.etudiant.prenom_mere else '')
            row_.append(inscription_.etudiant.sexe)
            row_.append(inscription_.etudiant.date_naissance if inscription_.etudiant.date_naissance else '')
            row_.append(inscription_.etudiant.lieu_naissance if inscription_.etudiant.lieu_naissance else '')
            row_.append(inscription_.etudiant.wilaya_residence.code if inscription_.etudiant.wilaya_residence else '')             
            row_.append(dict(DECISIONS_JURY)[inscription_.decision_jury])
            row_.append(inscription_.observation)                      
            row_.append(inscription_.etudiant.interne)
            row_.append(inscription_.etudiant.matricule_progres)
            row_.append(inscription_.etudiant.serie_bac)                                
            sheet.append(row_)  
                             
        filename='Liste_Etudiants'+str(annee_univ_)+'.xlsx'
        response = HttpResponse(content_type='application/vnd.ms-excel')
        response['Content-Disposition'] = 'attachment; filename='+filename+";"
        response.write(sheet.export('xlsx'))
    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            messages.error(request, "ERREUR: Il y a eu une erreur lors de l'exportation du fichier. Merci de le signaler à l'administration.")
    return response


def affectation_groupe_view(request):
    if not request.user.has_perm('scolar.fonctionnalite_etudiants_gestion'):
        return redirect('/accounts/login/?next=%s' % request.path)

    # if this is a POST request we need to process the form data
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = ImportAffectationForm(request.POST, request.FILES)
        # check whether it's valid:
        if form.is_valid():
            try:
                affectation_file = request.FILES['file']
                dataset = Dataset()
                imported_data = dataset.load(affectation_file.read(), format ='xlsx')
                # la première ligne du fichier doit contenir des entêtes, au moins Matricule Groupe Nom Prenom
                # insert imported_data in inscription table
                form_data=form.cleaned_data
                formation_=form_data['formation']
                t = threading.Thread(target=task_affectation_groupe_import,args=[formation_, imported_data, request.user])
                t.setDaemon(True)
                t.start()
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: L'import des affectations aux groupes n'a pas réussit. Veuillez vérifier le fichier et son format.")
                    messages.info(request, "Indiquer le fichier .xlsx d'affectation aux groupes des étudiants inscrits dans la formation indiquée ci-dessous.")
                    messages.info(request, "La première ligne du fichier doit comporter au moins les colonnes suivantes: Matricule, NomEtud, Prenoms, Section, Groupe")
                    messages.info(request, "Exemple de Section : A, B, ..  Groupe : G01, G02, ")
                    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer l\'affectation aux groupes'})
                
            messages.success(request, "La demande d'affectation aux groupes est prise en compte. Vous recevrez une notification aussitôt effectuée!")
            # redirect to a new URL:
            return HttpResponseRedirect(reverse('etudiant_list')) 
    # if a GET (or any other method) we'll create a blank form
    else:
        form = ImportAffectationForm()
        messages.info(request, "Indiquer le fichier .xlsx d'affectation aux groupes des étudiants inscrits dans la formation indiquée ci-dessous.")
        messages.info(request, "La première ligne du fichier doit comporter au moins les colonnes suivantes: Matricule, NomEtud, Prenoms, Section, Groupe")
        messages.info(request, "Exemple de Section : A, B, ..  Groupe : G01, G02, ")
        messages.warning(request, "Attention! Ne faites cette affectation qu'après avoir créé les programmes et leurs périodes, créé les sections et groupes et avoir indiqués pour chaque groupe les UE optionnelles.")
    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer l\'affectation aux groupes'})

@transaction.atomic
def task_affectation_groupe_import(formation_, imported_data, user):
    try:            
        for row in imported_data.dict :
            etudiant_, created=Etudiant.objects.get_or_create(matricule=str(row['Matricule']).strip(), defaults={
                'matricule':str(row['Matricule']).strip(),
                'nom':row['NomEtud'],
                'prenom':row['Prenoms']
                })
            groupe_=Groupe.objects.get(section__formation=formation_, section__code=str(row['Section']), code=str(row['Groupe']))
            inscription_, created =Inscription.objects.update_or_create(etudiant=etudiant_, formation=formation_, defaults={
                    'etudiant':etudiant_,
                    'formation':formation_,
                    #TODO enlever l'affectatation au groupe dans inscription on le maintient pour legacy compatibility
                    #On gère le groupe dans InscriptionPeriode
                    'groupe':groupe_,
                    #'rang':0,
                    #'moy':0,
                    #'moy_post_delib':0,
                })
            # On crée les InscriptionPeriode et on l'affecte au même groupe dans les périodes
            for periode_ in formation_.programme.periodes.all():
                InscriptionPeriode.objects.update_or_create(inscription=inscription_, periodepgm=periode_, defaults={
                        'inscription':inscription_,
                        'periodepgm':periode_,
                        'groupe':groupe_
                    })
            if inscription_.etudiant.user:
                if activation_emails() and formation_.annee_univ.encours:
                    email = EmailMessage('[Talents] Affectation au groupe '+str(groupe_),
                                         'Bonjour, '+inscription_.etudiant.nom+' '+inscription_.etudiant.prenom+'\n'+ 
                                         'Nous vous informons que vous avez été effecté au groupe '+str(groupe_)+'\n'+
                                         'Bien cordialement.\n'+
                                         signature_emails(), to=[inscription_.etudiant.get_email()] )
                    email.send(fail_silently=True)
                    sleep(1)
        trace_create(user, user, 'L\'importation de l\'affectation aux groupes de la formation '+str(formation_)+' a bien été effectuée')            
        if activation_emails():
            email = EmailMessage('[Talents] Confirmation de l\'importation de l\'affectation aux groupes de la formation '+str(formation_),
                                 'Bonjour,\n'+ 
                                 'L\'importation de l\'affectation aux groupes de la formation '+str(formation_)+' a bien été effectuée \n'+
                                 'Nous vous en remercions \n'+
                                 'Bien cordialement.\n'+
                                 signature_emails(), to=[user.get_email()] )
            email.send(fail_silently=True)

    except Exception as e:
        trace_create(user, user, 'Une erreur s\'est produite lors de l\'importation de l\affectation aux groupes de '+str(formation_))
        if settings.DEBUG:
            raise Exception
        else:
            if activation_emails():
                email = EmailMessage('[Talents] Erreur lors de l\importation des affectations aux groupes de la formation '+str(formation_),
                                     'Bonjour,\n'+ 
                                     'Une erreur s\'est produite lors de l\'importation de l\affectation aux groupes de '+str(formation_)+'\n'+
                                     'Veuillez vérifier les données et réessayer l\'importation \n'+
                                     'Bien cordialement.\n'+
                                     signature_emails()+'\n'+
                                     str(e), to=[user.get_email()] )
                email.send(fail_silently=True)

    

def affectation_pfe_valide_view(request):
    if not request.user.has_perm('scolar.fonctionnalite_stages_importation'):
        messages.error(request,"Vous n'avez pas les permissions pour exécuter cette opération.")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    # if this is a POST request we need to process the form data
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = ImportAffectationDiplomeForm(request.POST, request.FILES)
        # check whether it's valid:
        if form.is_valid():
            try:    
                affectation_file = request.FILES['file']
                dataset = Dataset()
                imported_data = dataset.load(affectation_file.read(), format ='xlsx')
                # la première ligne du fichier doit contenir des entêtes, au moins Matricule Groupe Nom Prenom
                # insert imported_data in inscription table
                form_data=form.cleaned_data
                diplome_=form_data['diplome']
                # attention, il s'agit ici de la formation associé au groupe de PFE et non pas la formation d'inscription
                # elles peuvent être différentes dans le cas de PFE mixtes, car on crée une formation Mixte, mais chaque étudiant du binôme garde sa spécialité donc sa formation à laquelle il est déjà inscrit
                formation_=form_data['formation']
                module_=Module.objects.get(formation=formation_, matiere__pfe=True)
                for row in imported_data.dict :
                    pfe_=get_object_or_404(PFE, id=int(row.get('ID')))
                    matricule_list=[inscription_.etudiant.matricule for inscription_ in pfe_.reserve_pour.all()]
                    
                    for matricule_ in matricule_list:
                        
                        default_section_, created=Section.objects.get_or_create(formation=formation_, code='A', defaults={
                                'formation':formation_,
                                'code':'A'
                            })
                        
                        groupe_, created=Groupe.objects.get_or_create(section=default_section_, code=str(row['Groupe']), defaults={
                                'code':str(row['Groupe']),
                                'section':default_section_
                            })

                        try:
                            #modifier le groupe de l'inscription à la formation du PFE (Ing ou Master)
                            inscription_=Inscription.objects.get(etudiant__matricule=matricule_, formation__programme__diplome=diplome_, formation__annee_univ=formation_.annee_univ)
                            #inscription_.groupe=groupe_
                            #inscription_.save()
                            #modifier le groupe d'inscription de la période
                            
                            InscriptionPeriode.objects.update_or_create(inscription=inscription_, periodepgm__periode=module_.periode.periode, defaults={
                                    'inscription':inscription_, 
                                    'periodepgm':module_.periode,
                                    'groupe':groupe_
                                })
                        except:
                            messages.error(request, "Etudiant non inscrit, il faut d'abord l'inscrire: "+matricule_)
                            continue
                  
                    
                    
                    if pfe_.coencadrants.exists():
                        encadrant_list=pfe_.coencadrants.all()
                        #encadrant_=encadrant_list[0]
                    elif module_.coordinateur:
                        pfe_.coencadrants.add(module_.coordinateur)
                        encadrant_list=[module_.coordinateur]
                    else:
                        messages.error(request, "Il faut désigner un coencadrant pour le PFE N°: "+str(pfe_.id))
                        continue
                    pfe_.groupe=groupe_
                    pfe_.save()

                    # on crée une activité d'encadrement ce qui va déclecnher l'insertion des charges et permettra la saisie des notes
                    # le PFE figurera ainsi dans Mes enseignements et les charges
                    
                    config_charge_=form_data['config_charge']
                    activite_, created=Activite.objects.update_or_create(type=config_charge_.type, module=module_, cible__in=[groupe_], defaults={
                            'type':config_charge_.type,
                            'module':module_,
                            'repeter_chaque_semaine':config_charge_.repeter_chaque_semaine,
                            'vh':config_charge_.vh,
                            'repartir_entre_intervenants':True,
                        })
                    activite_.cible.clear()
                    activite_.cible.add(groupe_)
                    for enseignant_ in activite_.assuree_par.all():
                        activite_.assuree_par.remove(enseignant_)
                    for enseignant in encadrant_list:
                        activite_.assuree_par.add(enseignant)
                    activite_.save()
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: L'affectation aux PFE n'a pas réussit. Le fichier est peut être mal formé!" )
                    messages.info(request, "Indiquer le fichier .xlsx d'affectation aux PFE des étudiants inscrits dans la formation indiquée ci-dessous.")
                    messages.info(request, "La première ligne du fichier doit comporter au moins les colonnes suivantes: Groupe, ID,")
                    messages.info(request, "La colonne Groupe correspond au code PFE, par ex. PSL23.")
                    render(request, 'scolar/import.html', {'form': form, 'titre':'Confirmer l\'affectation aux PFE'})
            messages.success(request, "L'affectation des étudiants aux PFE validés a été réalisée avec succès!")
            # redirect to a new URL:
            return HttpResponseRedirect(reverse('pfe_list')) 
    # if a GET (or any other method) we'll create a blank form
    else:
        form = ImportAffectationDiplomeForm()
        messages.info(request, "Indiquer le fichier .xlsx d'affectation aux PFE des étudiants inscrits dans la formation indiquée ci-dessous.")
        messages.info(request, "La première ligne du fichier doit comporter au moins les colonnes suivantes: Groupe, ID")
        messages.info(request, "La colonne Groupe correspond au code PFE, par ex. PSL23..")
        messages.warning(request, "Assurez vous que tous les binômes suivent le même module. Pour les binômes mixtes il faut créer une formation Mixte")
    return render(request, 'scolar/import.html', {'form': form, 'titre':'Confirmer l\'affectation aux PFE'})

        


def affectation_pfe_view(request):
    if not request.user.has_perm('scolar.fonctionnalite_stages_importation'):
        return redirect('/accounts/login/?next=%s' % request.path)
    
    # if this is a POST request we need to process the form data
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = ImportAffectationDiplomeForm(request.POST, request.FILES)
        # check whether it's valid:
        if form.is_valid():
            try:    
                affectation_file = request.FILES['file']
                dataset = Dataset()
                imported_data = dataset.load(affectation_file.read(), format ='xlsx')
                # la première ligne du fichier doit contenir des entêtes, au moins Matricule Groupe Nom Prenom
                # insert imported_data in inscription table
                form_data=form.cleaned_data
                diplome_=form_data['diplome']
                # attention, il s'agit ici de la formation associé au groupe de PFE et non pas la formation d'inscription
                # elles peuvent être différentes dans le cas de PFE mixtes, car on crée une formation Mixte, mais chaque étudiant du binôme garde sa spécialité donc sa formation à laquelle il est déjà inscrit
                formation_=form_data['formation']                
                module_=Module.objects.get(formation=formation_, matiere__pfe=True, periode__isnull=False)
                for row in imported_data.dict :
                    if row.get('Matricule'):
                        matricule_list=str(row['Matricule']).split('\n')
                    else:
                        nom_list=row['Nom'].split('\n')
                        prenom_list=row['Prenom'].split('\n')
                        matricule_list=[]
                        for nom_ in nom_list:
                            prenom_=prenom_list[nom_list.index(nom_)]
                            try:
                                matricule_=Etudiant.objects.get(nom__icontains=nom_, prenom__icontains=prenom_).matricule
                            except Exception:
                                messages.error(request, "L'étudiant "+nom_+" "+prenom_+" n'existe pas. Il faut corriger le nom ou l'insérer")
                                break
                            matricule_list.append(matricule_)

                    etudiant_list=[]
                    inscription_list=[]
                    for matricule_ in matricule_list:
                        etudiant_=Etudiant.objects.get(matricule=str(matricule_).strip())
                        etudiant_list.append(etudiant_)

                        
                        default_section_, created=Section.objects.get_or_create(formation=formation_, code='A', defaults={
                                'formation':formation_,
                                'code':'A'
                            })
                        
                        groupe_, created=Groupe.objects.get_or_create(section=default_section_, code=str(row['Groupe']), defaults={
                                'code':str(row['Groupe']),
                                'section':default_section_
                            })

                        try:
                            #modifier le groupe de l'inscription à la formation du PFE (Ing ou Master)
                            inscription_=Inscription.objects.get(etudiant=etudiant_, formation__programme__diplome=diplome_, formation__annee_univ=formation_.annee_univ)
                            inscription_list.append(inscription_)
                            #inscription_.groupe=groupe_
                            #inscription_.save()
                            #modifier le groupe d'inscription de la période
                            InscriptionPeriode.objects.update_or_create(inscription=inscription_, periodepgm__periode=module_.periode.periode, defaults={
                                    'inscription':inscription_, 
                                    'periodepgm':module_.periode,
                                    'groupe':groupe_
                                })
                        except:
                            messages.error(request, "Etudiant non inscrit, il faut d'abord l'inscrire: "+str(etudiant_))
                            continue
                  
                    if len(etudiant_list)==0:
                        messages.error(request,"Au moins un étudiant n'est pas valide sur cette ligne")
                        continue
                    
                    
                    if row['Coencadrants']:
                        encadrant_list=get_enseignant_list_from_str(row['Coencadrants'], '\n')
                        #encadrant_=encadrant_list[0]
                    elif module_.coordinateur:
                        encadrant_list=[module_.coordinateur]
                    else:
                        messages.error(request, "La présence d'un Encdrant pour le PFE "+str(groupe_)+" est obligatoire.")
                        continue
                    
                    pfe_, created=PFE.objects.update_or_create(groupe=groupe_, defaults={
                            'groupe':groupe_,
                            'intitule':row['Intitule'],
                            #'encadrant':encadrant_,
                            'promoteur':row['Promoteur'],
                            'email_promoteur':row['EmailPromoteur'] if row['EmailPromoteur'] else None ,                            
                            'type':row['Type'],
                            'statut_validation':row['Statut Validation'] if row['Statut Validation'] else'V'
                            
                        })
                    pfe_.coencadrants.clear()
                    for enseignant in encadrant_list:
                        pfe_.coencadrants.add(enseignant)
                    
                    pfe_.reserve_pour.clear()
                    for inscription_ in inscription_list:
                        pfe_.reserve_pour.add(inscription_)
                                        
                    pfe_.notification=False
                      
                    pfe_.save()

                    # on crée une activité d'encadrement ce qui va déclecnher l'insertion des charges et permettra la saisie des notes
                    # le PFE figurera ainsi dans Mes enseignements et les charges
                    
                    config_charge_=form_data['config_charge']
                    activite_, created=Activite.objects.update_or_create(type=config_charge_.type, module=module_, cible__in=[groupe_], defaults={
                            'type':config_charge_.type,
                            'module':module_,
                            'repeter_chaque_semaine':config_charge_.repeter_chaque_semaine,
                            'vh':config_charge_.vh,
                            'repartir_entre_intervenants':True,
                        })
                    activite_.cible.clear()
                    activite_.cible.add(groupe_)
                    for enseignant_ in activite_.assuree_par.all():
                        activite_.assuree_par.remove(enseignant_)
                    for enseignant in encadrant_list:
                        activite_.assuree_par.add(enseignant)
                    activite_.save()
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: L'affectation aux PFE n'a pas réussit. Le fichier est peut être mal formé!" )
                    messages.info(request, "Indiquer le fichier .xlsx d'affectation aux PFE des étudiants inscrits dans la formation indiquée ci-dessous.")
                    messages.info(request, mark_safe("La première ligne du fichier doit comporter au moins les colonnes suivantes: Matricule, Nom, Prenom, Groupe, Intitule, Promoteur,EmailPromoteur,Coencadrants,Type,Statut Validation.<br>Type:P=PFE, M=Master <br>Statut Validation:V=Validé,C=Contrôle-Non visible,S= Soumis-Visible,W=Validation en cours,RR=Révision Requise,RT=Révision Terminée, LR=Levée de Réserve,N=Rejeté"))
                    messages.info(request, "La colonne Groupe correspond au code PFE, par ex. PSL23. Les colonnes Matricule et Coencadrants peuvent contenir plusieurs éléments séparés par un saut de ligne dans la même cellule excel. Dans la cellule des coencadrants il faut mettre l'enseignant sous la forme : NOM Prénom initial si il est composé.")
                    render(request, 'scolar/import.html', {'form': form, 'titre':'Importer l\'affectation aux PFE'})
            messages.success(request, "L'affectation aux PFE a été réalisée avec succès!")
            # redirect to a new URL:
            return HttpResponseRedirect(reverse('pfe_list')) 
    # if a GET (or any other method) we'll create a blank form
    else:
        form = ImportAffectationDiplomeForm()
        messages.info(request, "Indiquer le fichier .xlsx d'affectation aux PFE des étudiants inscrits dans la formation indiquée ci-dessous.")
        messages.info(request, mark_safe("La première ligne du fichier doit comporter au moins les colonnes suivantes: Matricule, Nom, Prenom, Groupe, Intitule, Promoteur,EmailPromoteur,Coencadrants,Type,Statut Validation.<br>Type:P=PFE, M=Master <br> Statut Validation:V=Validé,C=Contrôle-Non visible,S= Soumis-Visible,W=Validation en cours,RR=Révision Requise,RT=Révision Terminée, LR=Levée de Réserve,N=Rejeté"))
        messages.info(request, "La colonne Groupe correspond au code PFE, par ex. PSL23. Les colonnes Matricule et Coencadrants peuvent contenir plusieurs éléments séparés par un saut de ligne dans la même cellule excel. Dans la cellule des coencadrants il faut mettre l'enseignant sous la forme : NOM Prénom initial si il est composé.")
        messages.warning(request, "Assurez vous que tous les binômes suivent le même module. Pour les binômes mixtes il faut créer une formation Mixte")
    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer l\'affectation aux PFE'})


@receiver(post_save, sender=InscriptionPeriode)
def add_resultat_inscription(sender, update_fields, instance, created, **kwargs):
    
    # créer les résultats que doit avoir l'étudiant
    if instance.groupe :
        # màj le groupe de Inscription avec le groupe de la dernière InscriptionPeriode <=> groupe actuel
        derniere_inscription_periode=instance.inscription.inscription_periodes.all().order_by('periodepgm__periode__ordre').last()
        if derniere_inscription_periode==instance:
            instance.inscription.groupe=derniere_inscription_periode.groupe
            instance.inscription.save(update_fields=['groupe'])
    
        periode_=instance.periodepgm
        modules_suivis_=ModulesSuivis.objects.filter(groupe=instance.groupe)
        ue_list=[]
        for ue_ in periode_.ues.filter(nature='OBL'):
            ue_list.append(ue_)
        for ue_ in instance.groupe.option.filter(periode=periode_):
            ue_list.append(ue_) 
        for ue_ in ue_list:
            resultat_ue, created = ResultatUE.objects.get_or_create(inscription_periode=instance, ue=ue_, defaults={
                    'inscription_periode':instance,
                    'ue':ue_,
                })
            
            
            for matiere_ in ue_.matieres.all():
                    resultat_, created = Resultat.objects.get_or_create(ancien_resultat__isnull=True, inscription=instance.inscription, module__matiere__code=matiere_.code, defaults={
                        'inscription':instance.inscription,
                        'resultat_ue':resultat_ue,
                        # On suppose qu'on ne peut avoir deux modules  diff�rents avec le m�me code matiere
                        'module': modules_suivis_.get(module__matiere__code=matiere_.code, module__periode__in=instance.inscription.all_periodes()).module,
                        #'module': modules_suivis_.get(module__matiere__code=matiere_.code).module,
                    })
                    
                    if created :
                        #si semestre acquis alors copier l'ancien dans le nouveau
                        sem_=InscriptionPeriode.objects.filter(inscription__etudiant=instance.inscription.etudiant, acquis=True, periodepgm=instance.periodepgm)

                        if sem_.exists():
                            old_resultat_=Resultat.objects.filter(ancien_resultat__isnull=True, inscription__etudiant=instance.inscription.etudiant, module__matiere__code=matiere_.code, inscription__decision_jury='R').order_by('-inscription__formation__annee_univ__annee_univ')
                            if old_resultat_.exists():
                               # considérer le dernier resultat et le copier dans le nouveau
                              old_resultat_=old_resultat_[0]
                              resultat_.moy=old_resultat_.moy
                              resultat_.moy_rattrapage=old_resultat_.moy_rattrapage
                              resultat_.entree_rattrapage=old_resultat_.entree_rattrapage
                              resultat_.moy_post_delib=old_resultat_.moy_post_delib
                              resultat_.ects=old_resultat_.ects
                              resultat_.acquis=True
                              resultat_.save(update_fields=['moy','moy_rattrapage', 'entree_rattrapage', 'moy_post_delib', 'ects', 'acquis'])
                          
                        else:
                           # Si module acquis alors copier l'ancien dans le nouveau
                           old_resultat_=Resultat.objects.filter(ancien_resultat__isnull=True, inscription__etudiant=instance.inscription.etudiant, module__matiere__code=matiere_.code, inscription__decision_jury='R', acquis=True).order_by('-inscription__formation__annee_univ__annee_univ') 
                           if old_resultat_.exists():
                             # considérer le dernier resultat et le copier dans le nouveau
                             old_resultat_=old_resultat_[0]
                             resultat_.moy=old_resultat_.moy
                             resultat_.moy_rattrapage=old_resultat_.moy_rattrapage
                             resultat_.entree_rattrapage=old_resultat_.entree_rattrapage
                             resultat_.moy_post_delib=old_resultat_.moy_post_delib
                             resultat_.ects=old_resultat_.ects
                             resultat_.acquis=True
                             resultat_.save(update_fields=['moy','moy_rattrapage', 'entree_rattrapage', 'moy_post_delib', 'ects', 'acquis'])
                          
                    else:
                        # ici on gère le cas d'un changement de groupe vers un groupe compatible (suivant les mêmes modules que
                        # l'ancien groupe, mais pour certaines matières elles sont suivies à des périodes différentes
                        # ATTENTION: on ne gère pas bien le changement de groupe vers un groupe incompatible: on crée les nouveaux modules mais
                        # on ne supprime pas les anciens par peur de perdre des notes et résultats intermédiaires
                    
                        # On suppose qu'on ne peut avoir deux modules  différents avec le mème code matiere
                        resultat_.module=modules_suivis_.get(module__matiere=matiere_, module__periode__in=instance.inscription.all_periodes()).module                    
                        #resultat_.module=modules_suivis_.get(module__matiere=matiere_).module
                        resultat_.resultat_ue=resultat_ue
                        resultat_.save(update_fields=['module', 'resultat_ue'])
                   
            
@receiver(post_save, sender=Note)
def update_resultat_moy(sender, update_fields, instance, created, **kwargs):
    resultat=get_object_or_404(Resultat, id=instance.resultat.id)
    activation_rattrapage=resultat.module.activation_rattrapage()
    if not resultat.inscription.formation.archive and not resultat.acquis and not resultat.inscription.is_admis():
        resultat.moy=resultat.moyenne()
        resultat.save(update_fields=['moy'])
        if not activation_rattrapage:
            resultat.moy_post_delib=resultat.moy
            resultat.save(update_fields=['moy_post_delib'])
        else :
            resultat.moy_rattrapage=resultat.moyenne_rattrapage()
            resultat.save(update_fields=['moy_rattrapage'])
            if resultat.entree_rattrapage :
                if resultat.module.activation_max_moy_normale_et_rattrapage :
                    resultat.moy_post_delib=max(resultat.moy_rattrapage, resultat.moy)
                else :
                    resultat.moy_post_delib=resultat.module.ponderation_moy_rattrapage*resultat.moy_rattrapage + resultat.module.ponderation_moy*resultat.moy
                resultat.save(update_fields=['moy_post_delib'])
            else :
                resultat.moy_post_delib=resultat.moy
                resultat.save(update_fields=['moy_post_delib'])
            
        #print('Calcul Moy déclenché:', resultat)
 
@login_required 
def notes_module_import_view(request, module_pk, groupe_pk):
    module_=get_object_or_404(Module, id=module_pk)
    groupe_=get_object_or_404(Groupe, id=groupe_pk)
    
    if request.user.has_perm('scolar.fonctionnalite_pedagogie_modificationnotes') or request.user.has_acces_gestion_notes_programme(module_.formation.programme):
            pass
    elif module_.formation.archive  or module_.pv_existe():
        messages.error(request, "La saisie des notes est clôturée pour cette formation.")
        return HttpResponseRedirect(reverse('note_list', kwargs={'groupe_pk': groupe_pk, 'matiere_pk': module_.matiere.id}))
    elif request.user.is_enseignant():
        if not assure_module(request.user.enseignant, module_):
            messages.error(request, "Vous n'êtes pas autorisés à accéder à cette fonction.")
            return redirect('/accounts/login/?next=%s' % request.path)
    else:
        messages.error(request, "Vous n'êtes pas autorisés à accéder à cette fonction.")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    # Cette condition permet de tester si on doit passer par le SMS pour envoyer un code secret à usage unique
    sms_=settings.SMS_ENABLED and not request.user.has_perm('scolar.fonctionnalite_pedagogie_modificationnotes')
    # if this is a POST request we need to process the form data
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        if sms_:
            form = OTPImportFileForm(request.POST, request.FILES)
        else:
            form = ImportFileForm(request.POST, request.FILES)
        
        # check whether it's valid:
        if form.is_valid():
            # Vérifier que l'OTP est correct
            if sms_:
                otp_=form.cleaned_data['otp']
            else:
                otp_="-1"
            
            if not sms_ or request.user.enseignant.check_otp(otp_):
                try:
                    notes_file = request.FILES['file']
                    dataset = Dataset()
                    imported_data = dataset.load(notes_file.read(), format ='xlsx')
                    # insert imported_data in resultat table
                    t = threading.Thread(target=task_notes_module_import,args=[module_, groupe_, imported_data, request.user])
                    t.setDaemon(True)
                    t.start()
                except Exception:
                    if settings.DEBUG:
                        raise Exception
                    else:
                        messages.error(request, "ERREUR: L'import des notes n'a pas réussit. Il doit y avoir un problème de format du fichier.")
                        return HttpResponseRedirect(reverse('note_list', kwargs={'groupe_pk': groupe_pk, 'matiere_pk': module_.matiere.id}))
                messages.info(request, "Votre demande d'importation de notes a été prise en compte. Une notification vous sera transmise une fois la tâche terminée.")
            else:
                messages.error(request, "Le Mot de Passe à usage unique saisi est incorrect.")         
        else:
            messages.error(request, "Le formulaire est incorrect.")
        # redirect to a new URL:
        return HttpResponseRedirect(reverse('note_list', kwargs={'groupe_pk': groupe_pk, 'matiere_pk': module_.matiere.id})) 
    # if a GET (or any other method) we'll create a blank form
    else:
        if sms_ and not request.user.enseignant.tel:
            messages.error(request, "Votre numéro de téléphone n'est pas enregsitré dans la base. Il est nécessaire pour vous envoyer un Mot de passe à Usage Unique.")
            messages.info(request, "Merci de communiquer votre numéro à l'administration afin que vous puissiez saisir les notes.")
            return HttpResponseRedirect(reverse('note_list', kwargs={'groupe_pk': groupe_pk, 'matiere_pk': module_.matiere.id}))
        else:
            # Génération et envoie de l'OTP pour sécuriser la saisie des notes
            url_=settings.SMS_URL
            params_={
                'function':'sms_send', 
                'apikey':settings.SMS_API_KEY, 
                'userkey':settings.SMS_USER_KEY, 
                'message':'Talents Code Secret: '+request.user.enseignant.set_otp() if request.user.is_enseignant() else None, 
                'message_priority':'Urgent',
                'to':request.user.enseignant.tel if request.user.is_enseignant() else None
                }
            if sms_:
                requests.get(url=url_, params=params_)
                form = OTPImportFileForm()
                messages.warning(request, "Nous avons transmis un code secret, à saisir, par SMS sur votre numéro.")
                messages.info(request, "Indiquez le fichier .xlsx contenant les notes de "+str(module_.matiere.code)+' '+str(groupe_.code))
                messages.info(request, "La première ligne du fichier doit contenir au moins les colonnes: Matricule, et une colonne par évaluation prévue comme CC, CF, etc.")
                return render(request, 'scolar/import_notes_form.html', {'form': form, 'sms' : sms_, 'titre':'Importer des notes'})
            else:
                form = ImportFileForm()
                messages.info(request, "Indiquez le fichier .xlsx contenant les notes de "+str(module_.matiere.code)+' '+str(groupe_.code))
                messages.info(request, "La première ligne du fichier doit contenir au moins les colonnes: Matricule, et une colonne par évaluation prévue par exemple CC, CF, CI, etc.")
                return render(request, 'scolar/import_notes_form.html', {'form': form, 'sms' : sms_, 'titre':'Importer des notes'})
                

@transaction.atomic
def task_notes_module_import(module_, groupe_, imported_data, user):
    try:
        activation_rattrapage=module_.activation_rattrapage()
        evaluation_list=module_.evaluations.all()
        non_modifie=''
        for row in imported_data.dict :
            etudiant_=Etudiant.objects.none()
            try:
                etudiant_=Etudiant.objects.get(matricule=str(row['Matricule']).strip())
                # récupérer le résultat de l'étudiant correspondant au module
                resultat_=get_object_or_404(Resultat, inscription__decision_jury__in=['C','DR'], inscription__etudiant=etudiant_, module=module_)
                if not resultat_.acquis and not resultat_.inscription.is_admis():
                    for eval_ in evaluation_list:
                        if eval_.type in row.keys() :
                            try:
                                ancienne_note_qs=Note.objects.filter(resultat=resultat_, evaluation=eval_)
                                if ancienne_note_qs.exists() :
                                    ancienne_note=ancienne_note_qs.first().note
                                else :
                                    ancienne_note=0
                                note_, created= Note.objects.update_or_create(evaluation=eval_, resultat=resultat_, defaults={
                                    'evaluation':eval_,
                                    'resultat':resultat_,
                                    'note': round(decimal.Decimal(str(row.get(eval_.type))),2) if row.get(eval_.type) else 0 
                                    })
                                if round(decimal.Decimal(ancienne_note),2)!=round(decimal.Decimal(note_.note),2) :
                                    trace_create(user, etudiant_, "Modification de la note (en importation pour le module) de "+str(eval_)+" de "+str(ancienne_note)+" vers "+str(round(decimal.Decimal(note_.note),2)))
                                    
                            except Exception:
                                non_modifie+=str(etudiant_)+'Note de '+eval_.type+' Incorrecte\n'
                                continue
                            
                    if not evaluation_list.exists():
                        try:
                            header_moy='Moy'+module_.matiere.code
                            if header_moy in row.keys():
                                ancienne_moy=resultat_.moy
                                resultat_.moy=round(decimal.Decimal(str(row.get(header_moy))),2)
                                resultat_.moy_post_delib=resultat_.moy
                                resultat_.save(update_fields=['moy','moy_post_delib'])
                                if ancienne_moy != resultat_.moy :
                                    trace_create(user, etudiant_, "Modification de la moyenne (en importation pour le module) de "+str(resultat_.module)+" de "+str(ancienne_moy)+" vers "+str(resultat_.moy))
                                    
                        except Exception:
                            non_modifie+=str(etudiant_)+header_moy+' Incorrecte\n'
                            continue
                        
                        if activation_rattrapage :
                            try:
                                header_moy_rattrapage='Moy_Rattrapage_'+module_.matiere.code
                                if header_moy_rattrapage in row.keys():
                                    ancienne_moy_rattrapage=resultat_.moy_rattrapage
                                    resultat_.moy_rattrapage=round(row.get(header_moy_rattrapage),2)     
                                    resultat_.save(update_fields=['moy_rattrapage'])
                                    if ancienne_moy_rattrapage != resultat_.moy_rattrapage :
                                        trace_create(user, etudiant_, "Modification de la moyenne de rattrapage (en importation pour le module) de "+str(resultat_.module)+" de "+str(ancienne_moy_rattrapage)+" vers "+str(resultat_.moy_rattrapage))

                            except Exception:
                                non_modifie+=str(etudiant_)+header_moy_rattrapage+' Incorrecte\n'
                                continue
                        if not activation_rattrapage :
                            resultat_.moy_post_delib=resultat_.moy
                            resultat_.save(update_fields=['moy_post_delib'])                         
                        elif resultat_.entree_rattrapage :
                            if resultat_.module.activation_max_moy_normale_et_rattrapage :
                                resultat_.moy_post_delib=max(resultat_.moy_rattrapage, resultat_.moy)
                            else :
                                resultat_.moy_post_delib=resultat_.module.ponderation_moy_rattrapage*resultat_.moy_rattrapage + resultat_.module.ponderation_moy*resultat_.moy
                            resultat_.save(update_fields=['moy_post_delib'])
                else :
                    if resultat_.acquis:
                        non_modifie+=str(etudiant_)+' Module déjà acquis\n'
                    if not resultat_.acquis and resultat_.inscription.is_admis() :
                        non_modifie+=str(etudiant_)+' Etudiant déjà admis\n'
                    
            except Exception:
                if etudiant_:
                    non_modifie+=str(etudiant_)+' En situation d\'Abandon ou Maladie\n'
                    continue
                else:
                    non_modifie+='Ligne vide! Merci de vérifier qu\'il n\'y a pas de notes non importées après cette ligne.\n'
                    break
        
        ModulesSuivis.objects.update_or_create(groupe=groupe_, module=module_, defaults={
                'groupe':groupe_,
                'module':module_,
                'saisie_notes':'T'
            })
     
        if non_modifie != '':
            non_modifie='Les notes de ces étudiants n\'ont pas été modifiées:\n'+non_modifie
        trace_create(user, user, 'L\'enregistrement des notes de '+str(module_.matiere.code)+' du groupe '+str(groupe_)+' a bien été effectué \n'+
                                 non_modifie)
        if activation_emails():
            email = EmailMessage('[Talents] Confirmation de l\'enregistrement des notes de '+str(module_.matiere.code)+' '+str(groupe_),
                                 'Bonjour,\n'+ 
                                 'L\'enregistrement des notes de '+str(module_.matiere.code)+' du groupe '+str(groupe_)+' a bien été effectué \n'+
                                 non_modifie+
                                 'Modification effectuée via le compte '+user.email+'\n'+
                                 'Bien cordialement.\n'+
                                 signature_emails(), to=[user.get_email(), module_.formation.programme.get_email_responsable_autorite_cycle()])
            email.send(fail_silently=True)
        else:
            print('Non modifiés: ', non_modifie)

    except Exception as e:
        trace_create(user, user, 'Une erreur s\'est produite lors de l\'enregistrement des notes de '+str(module_))
        if settings.DEBUG:
            raise Exception
        else:
            if activation_emails():
                email = EmailMessage('[Talents] Erreur lors de l\'enregistrement des notes de '+str(module_),
                                     'Bonjour,\n'+ 
                                     'Une erreur s\'est produite lors de l\'enregistrement des notes de '+str(module_)+'\n'+
                                     'Veuillez réessayer l\'importation \n'+
                                     'Bien cordialement.\n'+
                                     signature_emails(), to=[user.get_email(), module_.formation.programme.get_email_responsable_autorite_cycle()] )
                email.send(fail_silently=True)
        
        
@login_required
def notes_import_view(request):
    if not request.user.has_perm('scolar.fonctionnalite_pedagogie_modificationnotes') :
        messages.error(request, "Vous n'êtes pas autorisés à accéder à cette fonction.")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    # if this is a POST request we need to process the form data
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = ImportNotesForm(request.POST, request.FILES)
        
        # check whether it's valid:
        if form.is_valid():
            try:
                pv_file = request.FILES['file']
                dataset = Dataset()
                #imported_data = dataset.load(pv_file.read().decode('utf-8'), format ='csv')
                imported_data = dataset.load(pv_file.read(), format ='xlsx')
                # insert imported_data in resultat table
                form_data=form.cleaned_data
                formation_=form_data['formation']
                t = threading.Thread(target=task_notes_import,args=[formation_, imported_data, request.user])
                t.setDaemon(True)
                t.start()
                        
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: L'import des notes n'a pas réussit. Il doit y avoir un problème de format du fichier.")
                    messages.info(request, "Indiquez le fichier .xlsx contenant les notes qui correspondent à la formation indiquée ci-dessous.")
                    messages.info(request, "La première ligne du fichier doit contenir au moins les colonnes: Matricule et une colonne par matière qui associe le code de matière (ex: ALSDD, URSI, etc) et un préfixée Moy( pour la moyenne du module ex: MoyALSDD,MoyURSI...) et éventuellement une autre colonne avec un préfixe RACMoy (pour la note après rachat  ex: RACMoyALSDD, RACMoyURSI...)") 
                    if request.user.institution().has_one_or_more_cycle_rattrapage() :
                        messages.info(request, "Dans le cas de sélection d'une formation avec rattrapage activé, il faut rajouter deux colonnes supplémentaires par Matière, avec le code de la matière préfixé par RMoy et FMoy, désignant respectivement la moyenne du module à la session de rattrapage (exemple : RMoyALSDD, RMoyURSI) ainsi que la moyenne finale retenue pour le module (exemple : FMoyALSDD, FMoyURSI)")
                    if request.user.institution().has_one_or_more_matiere_validable() :
                        messages.info(request, "Dans le cas de sélection d'une formation qui contient des matières/stages sans notes pouvant être marqués uniquement comme 'Validé' ou 'Non Validé', alors renseigner V pour Validé ou N pour Non Validé, au lieu de la note.")
   
                    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer des notes'})
            messages.info(request, "Votre demande d'importation de notes a été prise en compte. Une notification vous sera transmise une fois la tâche terminée.")         
            # redirect to a new URL:
            return HttpResponseRedirect(reverse('notes_formation_list')) 
    # if a GET (or any other method) we'll create a blank form
    else:
        form = ImportNotesForm()
        messages.info(request, "La première ligne du fichier doit contenir au moins les colonnes: Matricule et une colonne par matière qui associe le code de matière (ex: ALSDD, URSI, etc) et un préfixée Moy( pour la moyenne du module ex: MoyALSDD,MoyURSI...) et éventuellement une autre colonne avec un préfixe RACMoy (pour la note après rachat  ex: RACMoyALSDD, RACMoyURSI...)") 
        if request.user.institution().has_one_or_more_cycle_rattrapage() :
            messages.info(request, "Dans le cas de sélection d'une formation avec rattrapage activé, il faut rajouter deux colonnes supplémentaires par Matière, avec le code de la matière préfixé par RMoy et FMoy, désignant respectivement la moyenne du module à la session de rattrapage (exemple : RMoyALSDD, RMoyURSI) ainsi que la moyenne finale retenue pour le module (exemple : FMoyALSDD, FMoyURSI)")
        if request.user.institution().has_one_or_more_matiere_validable() :
            messages.info(request, "Dans le cas de sélection d'une formation qui contient des matières/stages sans notes pouvant être marqués uniquement comme 'Validé' ou 'Non Validé', alors pour chaque étudiant une colonne avec le code de la matière préfixé par le mot 'Validation' doit être spécifiée, les valeurs sont : V pour Validé ou N pour Non Validé. (exemple de colonnes : ValidationALSDD, ValidationURSI, ...)")
            
    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer des notes'})

def task_notes_import(formation_, imported_data, user):
    try:
        with transaction.atomic() :
            rattrapage=formation_.activation_rattrapage()
            for row in imported_data.dict :
                etudiant_=Etudiant.objects.get(matricule=str(row['Matricule']).strip())
                inscription_=Inscription.objects.get(etudiant=etudiant_, formation=formation_)
                #modules_suivis=ModulesSuivis.objects.filter(groupe=inscription_.groupe).values_list('module')
                # les resultats d'un étudiant sont déjà créés lors de son affectation à un groupe (on sait ce qu'il doit suivre
                for resultat_ in Resultat.objects.filter(ancien_resultat__isnull=True, inscription=inscription_) : #, module__in=modules_suivis            
                    # pour les matières de type stage validé ou non validé, sans note (on exploite les colonnes ValidationALSDD, ValidationURSI, ..)
                    if resultat_.module.matiere.validable :
                        validation_=row.get('Validation'+resultat_.module.matiere.code)
                        if validation_ :
                            if (str(validation_) == "V") :
                                acquis_=True
                            elif (str(validation_) == "N") :
                                acquis_=False
                            else :
                                acquis_=resultat_.acquis
                            if resultat_.acquis != acquis_ :
                                resultat_.acquis=acquis_
                                resultat_.save(update_fields=['acquis',])
                                if resultat_.acquis :
                                    trace_create(user, resultat_.inscription.etudiant, str(resultat_)+ " : Passage de l'état Non Validé à Validé")
                                else :
                                    trace_create(user, resultat_.inscription.etudiant, str(resultat_)+ " : Passage de l'état Validé à Non Validé")
                    else :
                        # on tente de récupérer la note du module du fichier excel
                        moy_=row.get('Moy'+resultat_.module.matiere.code)
                        # si une telle colonne existe dans le fichier excel alors on récupère la moyenne
                        
                        if moy_:
                            moy_=str(moy_)
                            ancienne_moy=resultat_.moy
                            resultat_.moy=decimal.Decimal(moy_.replace(",","."))
                            if not rattrapage :
                                resultat_.moy_post_delib=resultat_.moy
                                resultat_.save(update_fields=['moy','moy_post_delib'])
                            else :
                                resultat_.save(update_fields=['moy'])
                                
                            if ancienne_moy != resultat_.moy :
                                trace_create(user, etudiant_, "Modification de la moyenne (en importation globale) de "+str(resultat_.module)+" de "+str(ancienne_moy)+" vers "+str(resultat_.moy))

                                                            
                        if rattrapage :
                            
                            moy_rattrapage=row.get('RMoy'+resultat_.module.matiere.code)
                            if moy_rattrapage :
                                moy_rattrapage=str(moy_rattrapage)
                                ancienne_moy_rattrapage=resultat_.moy_rattrapage
                                resultat_.moy_rattrapage=decimal.Decimal(moy_rattrapage.replace(",","."))
                                resultat_.entree_rattrapage=True
                                resultat_.save(update_fields=['moy_rattrapage', 'entree_rattrapage'])
                                if ancienne_moy_rattrapage != resultat_.moy_rattrapage :
                                    trace_create(user, etudiant_, "Modification de la moyenne de rattrapage (en importation globale) de "+str(resultat_.module)+" de "+str(ancienne_moy_rattrapage)+" vers "+str(resultat_.moy_rattrapage))
                            
                            moy_finale=row.get('FMoy'+resultat_.module.matiere.code)
                            if moy_finale :
                                moy_finale=str(moy_finale)
                                resultat_.moy_post_delib=decimal.Decimal(moy_finale.replace(",","."))
                                resultat_.save(update_fields=['moy_post_delib',])     
                        
                        moy_post_delib_=row.get('RACMoy'+resultat_.module.matiere.code)
                        #Récupérer la note de rachat si elle existe            
                        if moy_post_delib_:
                            moy_post_delib_=str(moy_post_delib_)
                            ancienne_moy_post_delib=resultat_.moy_post_delib
                            resultat_.moy_post_delib=decimal.Decimal(moy_post_delib_.replace(",","."))
                            resultat_.save(update_fields=['moy_post_delib'])
                            if ancienne_moy_post_delib != resultat_.moy_post_delib :
                                trace_create(user, etudiant_, "Modification de la note de rachat (en importation globale) de "+str(resultat_.module)+" de "+str(ancienne_moy_post_delib)+" vers "+str(resultat_.moy_post_delib)) 
                                                            
                # traiter le cas particulier du PFE        
                mention_=row.get('Mention')
                if mention_:
                    inscription_.mention=mention_
                    moy_pfe=str(row.get('PFE')).replace(",",".")
                    inscription_.moy=decimal.Decimal(moy_pfe)
                    if inscription_.moy>=10.0:
                        inscription_.decision_jury='A'
                    inscription_.save(update_fields=['mention', 'moy', 'decision_jury'])
    except Exception:
        trace_create(user, user, 'Une erreur s\'est produite lors de l\'enregistrement des notes de '+str(formation_))
        if settings.DEBUG:
            raise Exception
        else:
            if activation_emails():
                email = EmailMessage('[Talents] Erreur lors de l\'enregistrement des notes de '+str(formation_),
                                     'Bonjour,\n'+ 
                                     'Une erreur s\'est produite lors de l\'enregistrement des notes de '+str(formation_)+'\n'+
                                     'Veuillez réessayer l\'importation \n'+
                                     'Bien cordialement.\n'+
                                     signature_emails(), to=[user.get_email()] )
                email.send(fail_silently=True)
    else :
        trace_create(user, user, 'L\'importation des notes de '+str(formation_)+' a bien été effectuée')
        if activation_emails():
            email = EmailMessage('[Talents] Confirmation de l\'enregistrement des notes de '+str(formation_),
                                 'Bonjour,\n'+ 
                                 'L\'importation des notes de '+str(formation_)+' a bien été effectuée \n'+
                                 'Nous vous en remercions \n'+
                                 'Bien cordialement.\n'+
                                 signature_emails(), to=[user.get_email()] )
            email.send(fail_silently=True)
    
def access_table_view():
    group_names=Group.objects.all().order_by('name').values_list('name', flat=True)
    groups_count=group_names.count()
    
    permissions=Permission.objects.filter(codename__startswith='fonctionnalite').annotate(bloc=Cast(Substr("codename", StrIndex("codename", Value("_"))), output_field=CharField())).order_by('bloc')
    access_table={}
    cpt_permissions_par_fonctionnalite=0
    permissions_par_fonctionnalite=[]
    code_fonctionnalite_precedent=''
    groups_par_permission={}
    for permission_ in permissions :
        code_fonctionnalite=permission_.codename.split('_')[1]
        if not code_fonctionnalite in access_table.keys():
            if cpt_permissions_par_fonctionnalite!=0 :
                access_table[code_fonctionnalite_precedent].append(permissions_par_fonctionnalite)
                access_table[code_fonctionnalite_precedent].append(cpt_permissions_par_fonctionnalite)
                cpt_permissions_par_fonctionnalite=0
                permissions_par_fonctionnalite=[]
            access_table[code_fonctionnalite]=[]
            permission_et_groups=[]
            permission_et_groups.append(permission_.codename)
            permission_et_groups.append(permission_.name)                
            groups_par_permission={}
            for group_name in group_names :
                groups_par_permission[group_name]=Group.objects.filter(name=group_name, permissions=permission_).exists()
            permission_et_groups.append(groups_par_permission)
            if permission_.codename.split('_')[0].find("nav")!=-1:
                permission_et_groups.append(True)
            else :
                permission_et_groups.append(False)
            permissions_par_fonctionnalite.append(permission_et_groups)
            cpt_permissions_par_fonctionnalite+=1
        else :
            permission_et_groups=[]
            permission_et_groups.append(permission_.codename)
            permission_et_groups.append(permission_.name)
            groups_par_permission={}
            for group_name in group_names :
                groups_par_permission[group_name]=Group.objects.filter(name=group_name, permissions=permission_).exists()
            permission_et_groups.append(groups_par_permission)
            if permission_.codename.split('_')[0].find("nav")!=-1:
                permission_et_groups.append(True)
            else :
                permission_et_groups.append(False)
            permissions_par_fonctionnalite.append(permission_et_groups)
            cpt_permissions_par_fonctionnalite+=1
        code_fonctionnalite_precedent=code_fonctionnalite
    #Sauvegarde de la dernière itération
    if cpt_permissions_par_fonctionnalite!=0 :
        access_table[code_fonctionnalite_precedent].append(permissions_par_fonctionnalite)
        access_table[code_fonctionnalite_precedent].append(cpt_permissions_par_fonctionnalite)
    return access_table

def user_access_table_view(user_):    
    permissions=Permission.objects.filter(codename__startswith='fonctionnalite').annotate(bloc=Cast(Substr("codename", StrIndex("codename", Value("_"))), output_field=CharField())).order_by('bloc')
    access_table={}
    permissions_user=Permission.objects.filter(codename__startswith='fonctionnalite', user=user_)
    
    cpt_permissions_par_fonctionnalite=0
    permissions_par_fonctionnalite=[]
    code_fonctionnalite_precedent=''
    for permission_ in permissions :
        code_fonctionnalite=permission_.codename.split('_')[1]
        if not code_fonctionnalite in access_table.keys():
            if cpt_permissions_par_fonctionnalite!=0 :
                access_table[code_fonctionnalite_precedent].append(permissions_par_fonctionnalite)
                access_table[code_fonctionnalite_precedent].append(cpt_permissions_par_fonctionnalite)
                cpt_permissions_par_fonctionnalite=0
                permissions_par_fonctionnalite=[]
            access_table[code_fonctionnalite]=[]
            permissions_et_affectations=[]
            permissions_et_affectations.append(permission_.codename)
            permissions_et_affectations.append(permission_.name)   
            permissions_et_affectations.append(permissions_user.filter(id=permission_.id).exists())             
            if permission_.codename.split('_')[0].find("nav")!=-1:
                permissions_et_affectations.append(True)
            else :
                permissions_et_affectations.append(False)
            permissions_par_fonctionnalite.append(permissions_et_affectations)
            cpt_permissions_par_fonctionnalite+=1
        else :
            permissions_et_affectations=[]
            permissions_et_affectations.append(permission_.codename)
            permissions_et_affectations.append(permission_.name)
            permissions_et_affectations.append(permissions_user.filter(id=permission_.id).exists())                
            if permission_.codename.split('_')[0].find("nav")!=-1:
                permissions_et_affectations.append(True)
            else :
                permissions_et_affectations.append(False)
            permissions_par_fonctionnalite.append(permissions_et_affectations)
            cpt_permissions_par_fonctionnalite+=1
        code_fonctionnalite_precedent=code_fonctionnalite
    #Sauvegarde de la dernière itération
    if cpt_permissions_par_fonctionnalite!=0 :
        access_table[code_fonctionnalite_precedent].append(permissions_par_fonctionnalite)
        access_table[code_fonctionnalite_precedent].append(cpt_permissions_par_fonctionnalite)
    
    return access_table

class SettingsDetailView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, TemplateView):

    template_name = 'scolar/settings.html'
    success_message = "Utilisez cette page pour configurer Talents"
    
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalite_configurationetablissement_visualisation')
        
    def get_context_data(self, **kwargs):
        context = super(SettingsDetailView, self).get_context_data(**kwargs)
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalite_configurationetablissement_modification'):
            exclude_.append('edit')
            exclude_.append('admin')
        table = ActiviteChargeConfigTable(ActiviteChargeConfig.objects.all().order_by('type'), exclude=exclude_)
        RequestConfig(self.request).configure(table)
        
        context['activite_charge_config_table'] = table

        context['titre'] = 'Paramètres de Talents'
        table = ResidenceUnivTable(ResidenceUniv.objects.all().order_by('nom'), exclude=exclude_)
        RequestConfig(self.request).configure(table)     
        context['residence_univ_table'] = table
        
        qs = Institution.objects.all()
        
        if len(qs)>0:
            institution_=qs[0]
        else:
            institution_=Institution.objects.create(nom='Aucune Institution', sigle='Absent')
        context['form'] = InstitutionDetailForm(instance=institution_)
        context['institution'] = institution_
        groups_=Group.objects.all().order_by('name')
        group_names=groups_.values_list('name', flat=True)
        groups_count=group_names.count()
        context['access_table']=access_table_view()
        group_names_et_nb_users={}
        for group_ in groups_ :
            nb_users=User.objects.filter(groups__id=group_.id).count()
            group_names_et_nb_users[group_.id]=[]
            group_names_et_nb_users[group_.id].append(group_.name)
            group_names_et_nb_users[group_.id].append(nb_users)
            
        context['groups_et_nb_users']=group_names_et_nb_users
        context['group_names']=group_names
        context['groups_count']=groups_count
        
        table_autorite = AutoriteTable(Autorite.objects.all(), exclude=exclude_) 
        RequestConfig(self.request).configure(table_autorite)
        context['table_autorite'] = table_autorite
        
        return context
    
@login_required
def permissions_update_view(request):

    if not request.user.has_perm('scolar.fonctionnalite_configurationetablissement_modification'):
        messages.error(request,"Vous n'avez pas les permissions d'accès à cette opération")
        return redirect('/accounts/login/?next=%s' % request.path)
    group_names=Group.objects.all().order_by('name').values_list('name', flat=True)
    groups_count=group_names.count()
    access_table=access_table_view()
    
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = PermissionsUpdateForm(access_table, group_names, request, request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:
                # process the data in form.cleaned_data as required
                data=form.cleaned_data
                access_table=access_table_view()
                for fonctionnalite, permissions_par_fonctionnalite_et_cpt in access_table.items() :
                    for code_et_nom_et_groups in permissions_par_fonctionnalite_et_cpt[0] :
                        for group_name, permission_du_group in code_et_nom_et_groups[2].items() :
                            key_=str(group_name)+'_'+code_et_nom_et_groups[0]
                            if data[key_]!=permission_du_group : # La permission a changé
                                group_=get_object_or_404(Group, name=group_name)
                                permission_=get_object_or_404(Permission, codename=code_et_nom_et_groups[0])
                                if data[key_]==True :
                                    group_.permissions.add(permission_)
                                    trace_create(request.user, None, "Ajout d'une permission au rôle "+str(group_)+" : "+str(permission_.name))
                                else :
                                    group_.permissions.remove(permission_)
                                    trace_create(request.user, None, "Suppression d'une permission au rôle "+str(group_)+" : "+str(permission_.name))
                                                     
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: lors de l'enregistrement des nouvelles permissions. Merci de le signaler à l'administrateur.")
                    return render(request, 'scolar/permissions_update.html', {'form': form, 'access_table':access_table })
                
            return HttpResponseRedirect(reverse('settings'))
    # if a GET (or any other method) we'll create a blank form
    else:
        form = PermissionsUpdateForm(access_table, group_names, request)
        messages.info(request, "Utilisez cette table pour définir les permissions. Les fonctionnalités précédées par NAV sont celles prévues à être affichées dans la barre de navigation. Toutes les permissions suivantes sont globales et peuvent être affectées à n'importe quel rôle. Les espaces personnels des enseignants, étudiants et partenaires ne sont pas concernés par ces permissions, mais leurs rôles peuvent être enrichis avec ces permissions globales.")
            
    context={}
    context['form']=form
    context['access_table']=access_table
    context['group_names']=group_names
    context['groups_count']=groups_count
    return render(request, 'scolar/permissions_update.html', context)

@login_required
def permissions_user_choice_view(request):
    if not request.user.has_perm('scolar.fonctionnalite_configurationetablissement_visualisation'):
        messages.error(request,"Vous n'avez pas les permissions d'accès à cette opération")
        return redirect('/accounts/login/?next=%s' % request.path)
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = UserChoiceForm(request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:
                # process the data in form.cleaned_data as required
                data=form.cleaned_data
                user_=get_object_or_404(User, username=data['username'])
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "Erreur")
                    return render(request, 'scolar/form.html', {'form': form })
                
            return HttpResponseRedirect(reverse('permissions_user', kwargs={'pk':user_.id }))
    # if a GET (or any other method) we'll create a blank form
    else:
        form = UserChoiceForm()
        messages.info(request, "Choisissez un utilisateur")
    context={}
    context['form']=form
    return render(request, 'scolar/form.html', context)

class PermissionsUserView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):

    template_name = 'scolar/permissions_user.html'
    
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalite_configurationetablissement_visualisation')
    
    def get_context_data(self, **kwargs):
        context = super(PermissionsUserView, self).get_context_data(**kwargs)
        user_=get_object_or_404(User, id=int(self.kwargs.get('pk')))
        groups_=Group.objects.all().order_by('name')
        group_names=groups_.values_list('name', flat=True)
        #context['user_access_table']=user_access_table_view()
        groups_affectations=[]
        for group_ in groups_ :
            affectation=Group.objects.filter(id=group_.id, user__in=[user_]).exists()
            groups_affectations.append(affectation)
        
        context['titre']="Rôles et droits d'accès de : "+str(user_)
        context['groups_affectations']=groups_affectations
        context['access_table']=user_access_table_view(user_)
        context['user_']=user_
        
        context['group_names']=group_names
        
        return context
    
@login_required
def permissions_user_update_view(request, pk):

    if not request.user.has_perm('scolar.fonctionnalite_configurationetablissement_modification'):
        messages.error(request,"Vous n'avez pas les permissions d'accès à cette opération")
        return redirect('/accounts/login/?next=%s' % request.path)
    group_names=Group.objects.all().order_by('name').values_list('name', flat=True)
    groups_count=group_names.count()
    user_=get_object_or_404(User, id=pk)
    access_table=user_access_table_view(user_)
    
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = PermissionsUserUpdateForm(access_table, user_, request, request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:
                # process the data in form.cleaned_data as required
                data=form.cleaned_data
                
                for group_ in Group.objects.all().order_by('name') :
                    is_user_in_group=Group.objects.filter(id=group_.id, user=user_).exists()
                    key_='group_'+group_.name
                    if data[key_]!=is_user_in_group : #màj uniquement si modification
                        if data[key_]==True :
                            user_.groups.add(group_)
                            trace_create(request.user, user_, "Ajout d'un rôle à l'utilisateur "+str(user_)+" : "+str(group_))
                        else :
                            user_.groups.remove(group_) 
                            trace_create(request.user, user_, "Suppression d'un rôle à l'utilisateur "+str(user_)+" : "+str(group_))
                           
                for fonctionnalite, permissions_par_fonctionnalite_et_cpt in access_table.items() :
                    for code_et_nom_et_affectation in permissions_par_fonctionnalite_et_cpt[0] :
                        key_='permission_'+code_et_nom_et_affectation[0]
                        if data[key_]!=code_et_nom_et_affectation[2] : # La permission a changé
                            permission_=get_object_or_404(Permission, codename=code_et_nom_et_affectation[0])
                            if data[key_]==True :
                                user_.user_permissions.add(permission_)
                                trace_create(request.user, user_, "Ajout d'une permission à l'utilisateur "+str(user_)+" : "+str(permission_.name))
                            else :
                                user_.user_permissions.remove(permission_)     
                                trace_create(request.user, user_, "Suppression d'une permission à l'utilisateur "+str(user_)+" : "+str(permission_.name))                               
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: lors de l'enregistrement des nouvelles permissions. Merci de le signaler à l'administrateur.")
                    return render(request, 'scolar/permissions_update.html', {'form': form, 'access_table':access_table })
                
            return HttpResponseRedirect(reverse('permissions_user', kwargs={'pk':user_.id}))
    # if a GET (or any other method) we'll create a blank form
    else:
        form = PermissionsUserUpdateForm(access_table, user_, request)
        messages.info(request, "Utilisez ces deux tables pour définir les rôles et les droits d'accès supplémentaires de l'utilisateur : "+user_.username)
            
    context={}
    context['form']=form
    context['access_table']=access_table
    context['group_names']=group_names
    context['groups_count']=groups_count
    return render(request, 'scolar/permissions_user_update.html', context)

def validate_nom_role(value) :
    if '_' in str(value) :
        raise ValidationError("Le nom du rôle ne peut pas contenir le caractère _")


class RoleCreateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, CreateView):
    permission_required = 'scolar.fonctionnalite_configurationetablissement_modification'
    model = Group
    fields = ['name']
    template_name = 'scolar/create.html'
    success_message = "Le rôle (group) a été bien créé."
     
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.fields['name'].validators=[validate_nom_role]
        form.helper.add_input(Submit('submit','Ajouter', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('settings')
        return form

    def get_context_data(self, **kwargs):
        context = super(RoleCreateView, self).get_context_data(**kwargs)
        
        titre='Créer une rôle'        
        context['titre'] = titre
        return context

class RoleDeleteView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, DeleteView):
    model = Group
    template_name = 'scolar/delete.html'
    success_message = "Le rôle (group) a bien été supprimé."
    
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalite_configurationetablissement_modification')

    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression du rôle : "+str(object_))
        return super(RoleDeleteView, self).delete(*args, **kwargs)
        
    def get_success_url(self):
        return reverse('settings')

class RoleUserListView(LoginRequiredMixin, PermissionRequiredMixin, TemplateView):

    template_name = 'scolar/list.html'
    permission_required='scolar.fonctionnalite_configurationetablissement_visualisation'
    
    def get_context_data(self, **kwargs):
        context = super(RoleUserListView, self).get_context_data(**kwargs)
        table = UserTable(User.objects.filter(groups__id__in=[int(self.kwargs.get('group_id'))]).order_by('username'), exclude=['edit'])
        
        RequestConfig(self.request, paginate={"per_page": 100}).configure(table)
        context['titre'] = 'Liste des utilisateurs du rôle : '+get_object_or_404(Group, id=int(self.kwargs.get('group_id'))).name
        context['table'] = table
        context['back'] = reverse('settings')
        return context

class SettingsUpdateView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, UpdateView):
    model = Institution
    fields = ['nom_plateforme', 'nom', 'nom_a', 'sigle', 'adresse', 'ville', 'ville_a', 'wilaya_institution', 'tel', 'fax', 'web', 'email_domain', 'color', 'illustration_cursus', 'banniere', 'logo', 'logo_bis', 'header', 'footer','reference','identifiant_progres', 'code_etablissement', 'users_direction', 'users_scolarite', 'users_stage', 'email_futurs_stagiaires', 'users_theses', 'users_offres', 'users_demandes_comptes', 'email_webmaster', 'signature_emails', 'activation_emails', 'activation_ddc', 'activation_competences', 'activation_livret_competences', 'activation_charges', 'activation_google_agenda', 'activation_authentification_google', 'activation_feedback', 'activation_theses', 'activation_webhelp', 'activation_lettres_recommandation', 'activation_enregistrement_etudiants', 'activation_offres', 'activation_demandes_comptes', 'activation_public_stages', 'activation_public_projets', 'activation_public_equipesrecherche']
    template_name = 'scolar/settings.html'
    success_message = "Utilisez cette page pour configurer Talents"
    
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalite_configurationetablissement_modification')

    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
#         form.fields['illustration_cursus']=forms.ImageField(label='Illustration du cursus', required=False, widget=forms.FileInput(attrs={'class':"custom-file-input"}))
#         form.fields['banniere']=forms.ImageField(label='Banniere', required=False, widget=forms.FileInput(attrs={'class':"custom-file-input"}))
#         form.fields['logo']=forms.ImageField(label='Logo', required=False, widget=forms.FileInput(attrs={'class':"custom-file-input"}))
#         form.fields['logo_bis']=forms.ImageField(label='Logo bis', required=False, widget=forms.FileInput(attrs={'class':"custom-file-input"}))
#         form.fields['header']=forms.ImageField(label='Entête', required=False, widget=forms.FileInput(attrs={'class':"custom-file-input"}))
#         form.fields['footer']=forms.ImageField(label='Pied de page', required=False, widget=forms.FileInput(attrs={'class':"custom-file-input"}))
        form.fields['wilaya_institution'] = forms.ModelChoiceField(
            queryset=Wilaya.objects.all().order_by('nom'),
            label=u"Wilaya",
            widget=ModelSelect2Widget(
                model=Wilaya,
                search_fields=['nom__icontains',],
            ),
            required=False,
            help_text = "Choisir une wilaya. Tapez deux espaces pour avoir toute la liste.",
            )
        form.fields['users_direction']=forms.ModelMultipleChoiceField(
            queryset=User.objects.all().order_by('username'),
            label=u"Utilisateurs qui seront notifiés par e-mail en tant que direction",
            widget=ModelSelect2MultipleWidget(
                    model=User,
                    search_fields=['username__icontains', 'email__icontains'],

                ),
            help_text = "Tapez un nom d'utilisateur/email ou une partie du nom d'utilisateur/email pour faire une recherche",
            required = False
        )
        form.fields['users_scolarite']=forms.ModelMultipleChoiceField(
            queryset=User.objects.all().order_by('username'),
            label=u"Utilisateurs qui seront notifiés par e-mail en tant que scolarité",
            widget=ModelSelect2MultipleWidget(
                    model=User,
                    search_fields=['username__icontains', 'email__icontains'],

                ),
            help_text = "Tapez un nom d'utilisateur/email ou une partie du nom d'utilisateur/email pour faire une recherche",
            required = False
        )
        form.fields['users_stage']=forms.ModelMultipleChoiceField(
            queryset=User.objects.all().order_by('username'),
            label=u"Utilisateurs qui seront notifiés par le déroulement du processus de validation des stages de fin d'études",
            widget=ModelSelect2MultipleWidget(
                    model=User,
                    search_fields=['username__icontains', 'email__icontains'],

                ),
            help_text = "Tapez un nom d'utilisateur/email ou une partie du nom d'utilisateur/email pour faire une recherche",
            required = False
        )
        form.fields['users_offres']=forms.ModelMultipleChoiceField(
            queryset=User.objects.all().order_by('username'),
            label=u"Utilisateurs qui seront notifiés par le déroulement des processus de gestion des offres (emplois, thèses, stages pratiques, etc.)",
            widget=ModelSelect2MultipleWidget(
                    model=User,
                    search_fields=['username__icontains', 'email__icontains'],

                ),
            required = False,
        )
        form.fields['users_demandes_comptes']=forms.ModelMultipleChoiceField(
            queryset=User.objects.all().order_by('username'),
            label=u"Utilisateurs qui seront notifiés par les nouvelles demandes de compte (pour publier des offres, stages, etc.) (la fonctionnalité doit d'abord être activée)",
            widget=ModelSelect2MultipleWidget(
                    model=User,
                    search_fields=['username__icontains', 'email__icontains'],

                ),
            required = False,
        )
        form.fields['users_theses']=forms.ModelMultipleChoiceField(
            queryset=User.objects.all().order_by('username'),
            label=u"Utilisateurs qui seront notifiés par le déroulement du processus de gestion des thèses de post-graduation",
            widget=ModelSelect2MultipleWidget(
                    model=User,
                    search_fields=['username__icontains', 'email__icontains'],

                ),
            help_text = "Tapez un nom d'utilisateur/email ou une partie du nom d'utilisateur/email pour faire une recherche",
            required = False
        )
        form.helper.add_input(Submit('submit','Enregistrer', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url =  reverse('settings')
        return form

    
    def get_context_data(self, **kwargs):
        context = super(SettingsUpdateView, self).get_context_data(**kwargs)
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalite_configurationetablissement_modification'):
            exclude_.append('edit')
            exclude_.append('admin')
        
        if activation_charges() :        
            table = ActiviteChargeConfigTable(ActiviteChargeConfig.objects.all().order_by('type'), exclude=exclude_)
            RequestConfig(self.request).configure(table)
            
            context['activite_charge_config_table'] = table

        table = ResidenceUnivTable(ResidenceUniv.objects.all().order_by('nom'), exclude=exclude_)
        RequestConfig(self.request).configure(table)
        
        context['residence_univ_table'] = table
        
        table_autorite = AutoriteTable(Autorite.objects.all(), exclude=exclude_) 
        RequestConfig(self.request).configure(table_autorite)
        context['table_autorite'] = table_autorite

        context['titre'] = 'Paramètres de Talents'
        
        return context

def organismes_import_view(request):
    if not request.user.has_perm('scolar.fonctionnalite_stages_gestionpartenaires'):
        messages.error(request, "Vous n'avez pas les permissions d'accès à cette opération")
        return redirect('/accounts/login/?next=%s' % request.path)
    # if this is a POST request we need to process the form data
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = ImportFileForm(request.POST, request.FILES)
        
        # check whether it's valid:
        if form.is_valid():
            try:
                organismes_file = request.FILES['file']
                dataset = Dataset(headers=['SIGLE','NOM','ADRESSE','PAYS','TYPE','NATURE','STATUT','SECTEUR','TAILLE']) 
                imported_data = dataset.load(organismes_file.read(), format ='xlsx')
                # insert imported_data in Organisme table
                lignes_problemes=[]
                for row in imported_data.dict :
                    try:
                        organisme_, created=Organisme.objects.update_or_create(sigle=row['SIGLE'], defaults={
                            'sigle':row['SIGLE'],
                            'nom':row['NOM'],
                            'adresse':row['ADRESSE'],
                            'pays':get_object_or_404(Pays, code=row['PAYS']),
                            'type':row['TYPE'],
                            'nature':row['NATURE'],
                            'statut':row['STATUT'],
                            'secteur':row['SECTEUR'],
                            'taille':str(row['TAILLE'])
                     
                            })
                    except Exception:
                        lignes_problemes.append(row['sigle'])
                        continue
                    #vérifier que le nom est identique à l'existant
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "L'importation du fichier des organisme n'a pas réussit. Il doit y avoir un problème de format du fichier.")
                    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer des Organismes d\'accueil en Stage'})
            # redirect to a new URL:
            messages.success(request, "L'importation du fichier des Organismes s'est faite avec succès!")
            if len(lignes_problemes)>0:
                messages.warning(request,"Ces organismes n'ont pu être importées")
                for pb in lignes_problemes:
                    messages.warning(request, pb)
                  
            return HttpResponseRedirect(reverse('organisme_list')) 
    # if a GET (or any other method) we'll create a blank form
    else:
        form = ImportFileForm()
        messages.info(request, "Indiquer un fichier .xlsx des Organismes à importer dans la base de Talents.")
        messages.info(request, "le fichier doit avoir comme entête les colonnes suivantes: SIGLE, NOM, ADRESSE, PAYS, TYPE, NATURE, STATUT, SECTEUR, TAILLE")
    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer des Organismes'})

def pays_import_view(request):
    if not request.user.has_perm('scolar.fonctionnalite_configurationetablissement_modification'):
        return redirect('/accounts/login/?next=%s' % request.path)
    # if this is a POST request we need to process the form data
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = ImportFileForm(request.POST, request.FILES)
        
        # check whether it's valid:
        if form.is_valid():
            try:
                pays_file = request.FILES['file']
                dataset = Dataset(headers=['code','nom'])
                imported_data = dataset.load(pays_file.read(), format ='xlsx')
                # insert imported_data in Wilaya table
                lignes_problemes=[]
                for row in imported_data.dict :
                    try:
                        pays_, created=Pays.objects.update_or_create(code=str(row['code']), defaults={
                            'code':str(row['code']),
                            'nom':row['nom']
                            })
                    except Exception:
                        lignes_problemes.append(str(row['code']))
                        continue
                    #vérifier que le nom est identique à l'existant
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "L'importation du fichier des pays n'a pas réussit. Il doit y avoir un problème de format du fichier.")
                    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer des Pays'})
            # redirect to a new URL:
            messages.success(request, "L'importation du fichier des Pays s'est faite avec succès!")
            if len(lignes_problemes)>0:
                messages.warning(request,"Ces Pays n'ont pu être importées")
                for pb in lignes_problemes:
                    messages.warning(request, pb)
            return HttpResponseRedirect(reverse('pays_list')) 
    # if a GET (or any other method) we'll create a blank form
    else:
        form = ImportFileForm()
        messages.info(request, "Indiquer un fichier .xlsx des Pays à importer dans la base de Talents.")
    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer des Pays'})

def wilayas_import_view(request):
    if not request.user.has_perm('scolar.fonctionnalite_configurationetablissement_modification'):
        return redirect('/accounts/login/?next=%s' % request.path)
    # if this is a POST request we need to process the form data
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = ImportFileForm(request.POST, request.FILES)
        
        # check whether it's valid:
        if form.is_valid():
            try:
                wilaya_file = request.FILES['file']
                dataset = Dataset(headers=['code','nom'])
                imported_data = dataset.load(wilaya_file.read(), format ='xlsx')
                # insert imported_data in Wilaya table
                lignes_problemes=[]
                for row in imported_data.dict :
                    try:
                        wilaya_, created=Wilaya.objects.update_or_create(code=str(int(row['code'])), defaults={
                            'code':str(int(row['code'])),
                            'nom':row['nom']
                            })
                    except Exception:
                        lignes_problemes.append(str(row['code']))
                        continue
                    #vérifier que le nom est identique à l'existant
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "L'importation du fichier des wilayas n'a pas réussit. Il doit y avoir un problème de format du fichier.")
                    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer des Wilayas'})
            # redirect to a new URL:
            messages.success(request, "L'importation du fichier des Wilayas s'est faite avec succès!")
            if len(lignes_problemes)>0:
                messages.warning(request,"Ces Wilayas n'ont pu être importées")
                for pb in lignes_problemes:
                    messages.warning(request, pb)
            return HttpResponseRedirect(reverse('wilaya_list')) 
    # if a GET (or any other method) we'll create a blank form
    else:
        form = ImportFileForm()
        messages.info(request, "Indiquer un fichier .xlsx des Wilayas à importer dans la base de Talents.")
        messages.info(request, "L'entête du fichier doit avoir comme colonnes : 'code', 'nom'. Le code doit être un entier ou deux caractères décimaux.")
    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer des Wilayas'})

def communes_import_view(request):
    if not request.user.has_perm('scolar.fonctionnalite_configurationetablissement_modification'):
        return redirect('/accounts/login/?next=%s' % request.path)
    # if this is a POST request we need to process the form data
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = ImportFileForm(request.POST, request.FILES)
        
        # check whether it's valid:
        if form.is_valid():
            try:
                commune_file = request.FILES['file']
                dataset = Dataset(headers=['code','nom', 'wilaya'])
                imported_data = dataset.load(commune_file.read(), format ='xlsx')
                # insert imported_data in Wilaya table
                lignes_problemes=[]
                for row in imported_data.dict :
                    try:
                        commune_, created=Commune.objects.update_or_create(code_postal=row['code'], defaults={
                            'code_postal':row['code'],
                            'nom':row['nom'],
                            'wilaya':Wilaya.objects.get(code=row['wilaya'])
                            })
                    except Exception:
                        lignes_problemes.append(row['code'])
                        continue
                    #vérifier que le nom est identique à l'existant
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "L'importation du fichier des communes n'a pas réussit. Il doit y avoir un problème de format du fichier.")
                    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer des Commune'})
            # redirect to a new URL:
            messages.success(request, "L'importation du fichier des communes s'est faite avec succès!")
            if len(lignes_problemes)>0:
                messages.warning(request,"Ces communes n'ont pu être importées")
                for pb in lignes_problemes:
                    messages.warning(request,pb)
            return HttpResponseRedirect(reverse('commune_list')) 
    # if a GET (or any other method) we'll create a blank form
    else:
        form = ImportFileForm()
        messages.info(request, "Indiquer un fichier .xlsx des Communes à importer dans la base de Talents.")
        messages.info(request, "L'entête du fichier doit avoir comme colonnes : 'code', 'nom', 'wilaya'. Le code doit être un champs texte, que ce soit le code ONS, postal, etc.")
    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer des Communes'})

'''
def etudiants_import_maj_view(request):
    if not request.user.has_perm('scolar.fonctionnalite_etudiants_gestion'):
        return redirect('/accounts/login/?next=%s' % request.path)
    # if this is a POST request we need to process the form data
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = ImportFileForm(request.POST, request.FILES)
        
        # check whether it's valid:
        if form.is_valid():
            try:
                etudiant_file = request.FILES['file']
                dataset = Dataset(headers=['Matricule','NomEtud', 'Prenoms', 'Ddn', 
                                           'LieuNaissance', 'WilayaNaissance', 'NomEtudA', 'PrenomsA', 'LieuNaissanceA', 
                                           'Telephone', 'AdressePrincipale', 'WilayaResidence', 'CommuneResidence',
                                           'Interne', 'ResidenceU'])
                imported_data = dataset.load(etudiant_file.read(), format ='xlsx')
                # insert imported_data in Etudiant table
                lignes_problemes=[]
                for row in imported_data.dict :
                    try:
                        etudiant_=Etudiant.objects.get(matricule=str(row['Matricule']).strip())
                    except Exception:
                        lignes_problemes.append(row['Matricule']+' Indexistant')
                        continue
                    #vérifier que le nom est identique à l'existant
                    new_nom=row['NomEtud']
                    #new_Ddn=datetime.datetime.strptime(row['Ddn'],'%Y-%m-%d').date()
                    new_Ddn=row['Ddn'].date() if row['Ddn'] else None
                    if row['Interne'] :
                        interne_= True if row['Interne']=="Oui" else False
                    else :
                        interne_=etudiant_.interne
                    if etudiant_.date_naissance==new_Ddn and etudiant_.nom.lower().replace(' ','')==new_nom.lower().replace(' ',''):
                        # mettre à jour le dossier étudiant avec les infos
                        Etudiant.objects.filter(matricule=str(row['Matricule']).strip()).update(
                            nom=row['NomEtud'].upper(),
                            nom_a=row['NomEtudA'] if row['NomEtudA']!='' else etudiant_.nom_a,
                            prenom=row['Prenoms'].upper() if row['Prenoms']!=''  else etudiant_.prenom.upper(),
                            prenom_a=row['PrenomsA']  if row['PrenomsA']!=''  else etudiant_.prenom_a,
                            lieu_naissance=row['LieuNaissance'].upper()  if row['LieuNaissance']!=''  else etudiant_.lieu_naissance.upper(),
                            lieu_naissance_a=row['LieuNaissanceA'] if row['LieuNaissanceA']!=''  else etudiant_.lieu_naissance_a,
                            wilaya_naissance=Wilaya.objects.get(code=str(row['WilayaNaissance']).split()[0]) if row['WilayaNaissance'] else etudiant_.wilaya_naissance,
                            tel=str(row['Telephone']) if row['Telephone'] else etudiant_.tel,
                            addresse_principale=row['AdressePrincipale'].upper() if row['AdressePrincipale'] else etudiant_.addresse_principale,
                            wilaya_residence=Wilaya.objects.get(code=row['WilayaResidence'].split()[0]) if row['WilayaResidence'] else etudiant_.wilaya_residence,
                            commune_residence=Commune.objects.get(code_postal=row['CommuneResidence'].split().pop()) if row['CommuneResidence'] else etudiant_.commune_residence,
                            interne= interne_,
                            residence_univ=row['ResidenceU'].upper() if row['ResidenceU'] else etudiant_.residence_univ
                            )
                    else:
                        lignes_problemes.append(row['Matricule']+' Noms ou Ddn différents.')
                        continue
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "L'importation du fichier des étudiants n'a pas réussit. Il doit y avoir un problème de format du fichier.")
                    messages.info(request, mark_safe("La première ligne du fichier .xlsx doit comprendre au moins les colonnes: 'Matricule' (non modifiable),'NomEtud' (non modifiable), 'Prenoms' , 'Ddn' (non modifiable),"+ 
                                                             "'LieuNaissance', 'WilayaNaissance', 'NomEtudA' , 'PrenomsA' , 'LieuNaissanceA',"+
                                                             "'Telephone', 'AdressePrincipale', 'WilayaResidence', 'CommuneResidence',"+
                                                             "'Interne', 'ResidenceU'.<br><br>Matricule : Texte ou nombre, peu importe il sera converti en texte <br>Ddn : Colonne en format date sur excel <br>Interne : 'Oui' ou 'Non' <br> Tel : Colonne texte de préférence (nombre accepté)<br>WilayaNaissance et WilayaResidence : Code Wilaya nombre ou texte sans zéro à gauche, ou bien nom de la wilaya peu importe la casse <br> CommuneResidence : Code ONS ou postal ou autre selon votre configuration (laissez vide en cas d'incertitude) <br> ResidenceU : Texte<br><br>Tous les champs non précisés si modifiables ou non, sont modifiables."))
                    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer des étudiants'})
            # redirect to a new URL:
            messages.success(request, "L'importation du fichier des étudiants s'est faite avec succès!")
            if len(lignes_problemes)>0:
                messages.warning(request,"Ces étudiants n'ont pu être importé")
                for pb in lignes_problemes:
                    messages.warning(request,pb)
            return HttpResponseRedirect(reverse('etudiant_list')) 
    # if a GET (or any other method) we'll create a blank form
    else:
        form = ImportFileForm()
        messages.info(request, "Indiquer un fichier .xlsx des étudiants à modifier dans la base de Talents.")
        messages.info(request, mark_safe("La première ligne du fichier .xlsx doit comprendre au moins les colonnes: 'Matricule' (non modifiable),'NomEtud' (non modifiable), 'Prenoms' , 'Ddn' (non modifiable),"+ 
                                                 "'LieuNaissance', 'WilayaNaissance', 'NomEtudA' , 'PrenomsA' , 'LieuNaissanceA',"+
                                                 "'Telephone', 'AdressePrincipale', 'WilayaResidence', 'CommuneResidence',"+
                                                 "'Interne', 'ResidenceU'.<br><br>Matricule : Texte ou nombre, peu importe il sera converti en texte <br>Ddn : Colonne en format date sur excel <br>Interne : 'Oui' ou 'Non' <br> Tel : Colonne texte de préférence (nombre accepté)<br>WilayaNaissance et WilayaResidence : Code Wilaya en nombre ou texte sans zéro à gauche, ou bien nom de la wilaya peu importe la casse <br> CommuneResidence : Code ONS ou postal ou autre selon votre configuration (laissez vide en cas d'incertitude) <br> ResidenceU : Texte<br><br>Tous les champs non précisés si modifiables ou non, sont modifiables."))
    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer des étudiants'})
'''
     
    
def etudiants_import_view(request):
    if not request.user.has_perm('scolar.fonctionnalite_etudiants_gestion'):
        return redirect('/accounts/login/?next=%s' % request.path)
    # if this is a POST request we need to process the form data
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = ImportFileForm(request.POST, request.FILES)        
        # check whether it's valid:
        if form.is_valid():
            try:
                etudiant_file = request.FILES['file']
                dataset = Dataset(headers=['Matricule','NomEtud', 'Prenoms', 'Genre', 'Ddn', 
                                           'LieuNaissance', 'WilayaNaissance', 'NomEtudA', 'PrenomsA', 'LieuNaissanceA', 
                                           'Email', 'Telephone', 'AdressePrincipale', 'WilayaResidence', 'CommuneResidence',
                                           'Interne', 'ResidenceU','MatriculeBac','AnneeBac','SerieBac','MoyenneBac','Pere','PereA','NomMere','NomMereA','PrenomMere','PrenomMereA','MatriculeProgres'])
                imported_data = dataset.load(etudiant_file.read(), format ='xlsx')
                # insert imported_data in Etudiant table
                group=Group.objects.get(name='etudiant')
                lignes_pb=''                
                for row in imported_data.dict :
                    try:
                        if not row['Matricule'] :
                            raise Exception('Le matricule est obligatoire')
                    
                        wilaya_naissance_=None 
                        if row['WilayaNaissance'] and Wilaya.objects.filter(code=str(row['WilayaNaissance'])).exists():
                            wilaya_naissance_=Wilaya.objects.filter(code=str(row['WilayaNaissance']))[0]
                        elif row['WilayaNaissance'] and Wilaya.objects.filter(nom__icontains=str(row['WilayaNaissance'])).exists():
                            wilaya_naissance_=Wilaya.objects.filter(nom__icontains=str(row['WilayaNaissance']))[0]if row['WilayaNaissance'] else None
                                                                       
                        wilaya_residence_=None
                        if row['WilayaResidence'] and Wilaya.objects.filter(code=str(row['WilayaResidence'])).exists():
                            wilaya_residence_=Wilaya.objects.filter(code=str(row['WilayaResidence']))[0]
                        elif row['WilayaResidence'] and Wilaya.objects.filter(nom__icontains=str(row['WilayaResidence'])).exists():
                            wilaya_residence_=Wilaya.objects.filter(nom__icontains=str(row['WilayaResidence']))[0]
                        else:
                            wilaya_residence_= None                         
                            
                        serie_bac_=None 
                        if row['SerieBac']=='N03':
                            serie_bac_='Sciences Experimentales'
                        elif row['SerieBac']=='N04':
                            serie_bac_='Mathematiques'
                        elif row['SerieBac']=='N05':
                            serie_bac_='Techniques Mathematiques'      
                        else: 
                            serie_bac_=None       
                         
                        user_object=User.objects.none() 
                        etudiant_object=Etudiant.objects.filter(matricule=str(row['Matricule']).strip())
                    
                        if etudiant_object.exists() :
                            etudiant_object=etudiant_object.first()
                            if etudiant_object.user :
                                user_object=etudiant_object.user
                                email_=etudiant_object.get_email() if etudiant_object.get_email() else None
                            else :
                                email_=row['Email'].strip() if row['Email'] else None                           
                        else :
                            email_=row['Email'].strip() if row['Email'] else None 
                            etudiant_object=Etudiant.objects.none()
                    
                        created=False
                        if not etudiant_object :
                            etudiant_=Etudiant.objects.create(          
                                matricule=str(row['Matricule']).strip(),
                                nom=row['NomEtud'].upper(),                                
                                prenom=row['Prenoms'].upper(),                                
                                sexe=row['Genre'] if row['Genre'] else None,
                                date_naissance=row['Ddn'] if row['Ddn'] else None,
                                lieu_naissance=row['LieuNaissance'].upper()if row['LieuNaissance'] else None,
                                nom_a=row['NomEtudA'] if row['NomEtudA'] else None,
                                prenom_a=row['PrenomsA'] if row['PrenomsA'] else None,
                                lieu_naissance_a=row['LieuNaissanceA'] if row['LieuNaissanceA'] else None,
                                wilaya_naissance=wilaya_naissance_,
                                tel=str(row['Telephone']) if row['Telephone'] else None,
                                addresse_principale=row['AdressePrincipale'].upper()if row['AdressePrincipale'] else None,
                                wilaya_residence=wilaya_residence_,
                                commune_residence=Commune.objects.filter(code_postal=str(row['CommuneResidence']))[0] if Commune.objects.filter(code_postal=str(row['CommuneResidence'])).exists() else None,
                                interne=True if row['Interne']=="Oui" else False,
                                residence_univ=row['ResidenceU'].upper()if row['ResidenceU'] else None,
                                annee_bac=str(row['AnneeBac']).replace(" ", "") if row['AnneeBac'] else None,
                                n_inscription_bac=str(row['MatriculeBac']).replace(" ", "") if row['MatriculeBac'] else None,
                                serie_bac=serie_bac_,                                     
                                moyenne_bac=decimal.Decimal(str(row['MoyenneBac']).replace(',','.')) if row['MoyenneBac'] else None,
                                prenom_pere=row['Pere'].upper()if row['Pere'] else None,
                                prenom_pere_a=row['PereA'] if row['PereA'] else None,
                                nom_mere=row['NomMere'].upper()if row['NomMere'] else None,
                                nom_mere_a=row['NomMereA'] if row['NomMereA'] else None,
                                prenom_mere=row['PrenomMere'].upper()if row['PrenomMere'] else None,
                                prenom_mere_a=row['PrenomMereA'] if row['PrenomMereA'] else None,                                
                                matricule_progres=str(row['MatriculeProgres']).replace(" ", "") if row['MatriculeProgres'] else None                                                                                  
                            )
                            created=True                        
                        else :                        
                            if row['Interne'] :
                                interne_= True if row['Interne']=="Oui" else False
                            else :
                                interne_=etudiant_object.interne
                            
                            etudiant_, created=Etudiant.objects.update_or_create(matricule=str(row['Matricule']).strip(), defaults={
                                    'nom':row['NomEtud'].upper()if row['NomEtud'] else etudiant_object.nom,                            
                                    'nom_a':row['NomEtudA'] if row['NomEtudA'] else etudiant_object.nom_a,
                                    'prenom':row['Prenoms'].upper() if row['Prenoms'] else etudiant_object.prenom,
                                    'prenom_a':row['PrenomsA']  if row['PrenomsA'] else etudiant_object.prenom_a,
                                    'sexe' : row['Genre'] if row['Genre'] else etudiant_object.sexe,               
                                    'lieu_naissance':row['LieuNaissance'].upper()  if row['LieuNaissance'] else etudiant_object.lieu_naissance,
                                    'date_naissance':row['Ddn']if row['Ddn'] else etudiant_object.date_naissance,
                                    'lieu_naissance_a':row['LieuNaissanceA'] if row['LieuNaissanceA'] else etudiant_object.lieu_naissance_a,
                                    'wilaya_naissance':wilaya_naissance_ if row['WilayaNaissance'] else etudiant_object.wilaya_naissance,
                                    'tel':str(row['Telephone']) if row['Telephone'] else etudiant_object.tel,
                                    'addresse_principale':row['AdressePrincipale'].upper() if row['AdressePrincipale'] else etudiant_object.addresse_principale,                                
                                    'wilaya_residence':wilaya_residence_ if row['WilayaResidence'] else etudiant_object.wilaya_residence,
                                    'commune_residence':Commune.objects.get(code_postal=row['CommuneResidence'].split().pop()) if row['CommuneResidence'] else etudiant_object.commune_residence,                                
                                    'interne':interne_,
                                    'residence_univ':row['ResidenceU'].upper() if row['ResidenceU'] else etudiant_object.residence_univ,
                                    'annee_bac':str(row['AnneeBac']).replace(" ", "") if row['AnneeBac'] else etudiant_object.annee_bac,
                                    'n_inscription_bac':str(row['MatriculeBac']).replace(" ", "") if row['MatriculeBac'] else etudiant_object.n_inscription_bac,
                                    'moyenne_bac':decimal.Decimal(str(row['MoyenneBac']).replace(',','.')) if row['MoyenneBac'] else etudiant_object.moyenne_bac,                                    
                                    'serie_bac':serie_bac_,                            
                                    'prenom_pere':row['Pere'].upper() if row['Pere'] else etudiant_object.prenom_pere,    
                                    'prenom_pere_a':row['PereA'] if row['PereA'] else etudiant_object.prenom_pere_a,                            
                                    'prenom_mere':row['PrenomMere'].upper() if row['PrenomMere'] else etudiant_object.prenom_mere,
                                    'prenom_mere_a':row['PrenomMereA'] if row['PrenomMereA'] else etudiant_object.prenom_mere_a,                          
                                    'nom_mere':row['NomMere'].upper() if row['NomMere'] else etudiant_object.nom_mere,
                                    'nom_mere_a':row['NomMereA'] if row['NomMereA'] else etudiant_object.nom_mere_a,                                    
                                    'matricule_progres':str(row['MatriculeProgres']).replace(" ", "") if row['MatriculeProgres'] else etudiant_object.matricule_progres,                                    
                                }                                                 
                            )                    
                        if email_ :
                            if not user_object :
                                qs = User.objects.filter(username__iexact=row['Email'].strip())
                                if qs.exists() :
                                    user=qs.first()
                                else :
                                    psw=User.objects.make_random_password()
                                    user=User.objects.create_user(
                                        username=row['Email'].strip(),
                                        first_name= row['Prenoms'].upper(),
                                        last_name= row['NomEtud'].upper(),
                                        is_active=True,
                                        is_superuser= False,
                                        is_staff= False,
                                        email=row['Email'].strip()
                                        )
                                    user.set_password(psw)
                                user.groups.add(group)
                                user.save()
                                
                                if not etudiant_.photo :
                                    imagefilename=etudiant_.photo.field.upload_to
                                    if default_storage.exists(settings.MEDIA_ROOT+'/'+etudiant_.photo.field.upload_to+'/'+etudiant_.matricule.replace('/','-')+'.jpg'):
                                        imagefilename+='/'+etudiant_.matricule.replace('/','-')+'.jpg'
                                    else:
                                        imagefilename+='/'+'anonymous-user.jpg'
                            
                                    etudiant_.photo.name=imagefilename
                            else :
                                user=user_object
                            etudiant_.user=user                       
                        etudiant_.save()
                    except Exception:
                        lignes_pb+=str(row['Matricule'])+'\n'
                        if settings.DEBUG:
                            raise Exception
                        continue 
            except Exception:
                if settings.DEBUG:
                    raise Exception                   
                else:
                    messages.error(request, "L'importation du fichier des étudiants n'a pas réussit. Il doit y avoir un problème de format du fichier.")
                    messages.info(request, "Le minimum des champs obligatoires sont : Matricule, NomEtud, Prenoms (le reste étant facultatif, l'adresse e-mail est aussi facultative, l'étudiant sera identifié principalement par son matricule unique). Si une adresse e-mail est spécifiée à l'étudiant un compte d'utilisateur lui sera créé, son nom d'utilisateur sera son e-mail.")
                    messages.info(request, mark_safe("La première ligne du fichier .xlsx doit comprendre au moins les colonnes: 'Matricule','NomEtud', 'Prenoms', 'Ddn',"+ 
                                                             "'LieuNaissance', 'WilayaNaissance', 'NomEtudA', 'PrenomsA', 'LieuNaissanceA',"+
                                                             "'Telephone', 'AdressePrincipale', 'WilayaResidence', 'CommuneResidence',''AnneeBac,"+
                                                             "'MatriculeBac','SerieBac','MoyenneBac','Pere','PereA','PrenomMere','PrenomMereA','NomMere',<br>"+
                                                             "'NomMereA','Interne', 'ResidenceU', 'Email','Genre','MatriculeProgres'.<br><br>Matricule : Texte ou nombre, peu importe il sera converti en texte <br>Ddn : Colonne date sur excel, peu importe le format <br>Interne : 'Oui' ou 'Non' <br>Genre : 'M' ou 'F' <br> Telephone : Colonne texte de préférence (nombre accepté) <br>WilayaNaissance et WilayaResidence : Code Wilaya en nombre ou texte sans zéros à gauche, ou bien nom de la wilaya peu importe la casse <br> CommuneResidence : Code ONS ou postal ou autre selon votre configuration (laissez vide en cas d'incertitude)<br> ResidenceU : Texte<br> MatriculeBac : Matricule de l'étudiant au baccalauréat<br> SerieBac : N03, N04 ou N05 (N03=Sciences Experimentales, N04=Mathématiques, N05=Techniques Mathematiques.)<br> Pere : Prénom du père<br> PereA : Prénom du père en arabe<br> PrenomMere/NomMere : Prénom/Nom de la mère <br> PrenomMereA/NomMereA : Prénom/Nom de la mère en arabe<br> MatriculeProgres : Matricule unique de l'étudiant sur la plateforme Progres"))
                                                             
                    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer des étudiants'})                      
                   
            # redirect to a new URL:
            messages.success(request, "L'importation du fichier des étudiants s'est faite avec succès!")
            if lignes_pb != '':
                messages.warning(request, "Les lignes suivantes n'ont pas été insérées à cause d'erreurs:\n"+
                    lignes_pb)               
            return HttpResponseRedirect(reverse('etudiant_list'))             
    # if a GET (or any other method) we'll create a blank form
    else:
        form = ImportFileForm()
        messages.info(request, "Indiquer un fichier .xlsx des étudiants à importer/modifier dans la base de Talents.")
        messages.info(request, "Le minimum des champs obligatoires sont : Matricule, NomEtud, Prenoms (le reste étant facultatif, l'adresse e-mail est aussi facultative, l'étudiant sera identifié principalement par son matricule unique). Si une adresse e-mail est spécifiée à l'étudiant un compte d'utilisateur lui sera créé, son nom d'utilisateur sera son e-mail.")
        messages.info(request, mark_safe("La première ligne du fichier .xlsx doit comprendre au moins les colonnes: 'Matricule','NomEtud', 'Prenoms', 'Ddn',"+ 
                                                             "'LieuNaissance', 'WilayaNaissance', 'NomEtudA', 'PrenomsA', 'LieuNaissanceA',"+
                                                             "'Telephone', 'AdressePrincipale', 'WilayaResidence', 'CommuneResidence',''AnneeBac,"+
                                                             "'MatriculeBac','SerieBac','MoyenneBac','Pere','PereA','PrenomMere','PrenomMereA','NomMere',<br>"+
                                                             "'NomMereA','Interne', 'ResidenceU', 'Email','Genre','MatriculeProgres'.<br><br>Matricule : Texte ou nombre, peu importe il sera converti en texte <br>Ddn : Colonne date sur excel, peu importe le format <br>Interne : 'Oui' ou 'Non' <br>Genre : 'M' ou 'F' <br> Telephone : Colonne texte de préférence (nombre accepté) <br>WilayaNaissance et WilayaResidence : Code Wilaya en nombre ou texte sans zéros à gauche, ou bien nom de la wilaya peu importe la casse <br> CommuneResidence : Code ONS ou postal ou autre selon votre configuration (laissez vide en cas d'incertitude)<br> ResidenceU : Texte<br> MatriculeBac : Matricule de l'étudiant au baccalauréat<br> SerieBac : N03, N04 ou N05 (N03=Sciences Experimentales, N04=Mathématiques, N05=Techniques Mathematiques.)<br> Pere : Prénom du père<br> PereA : Prénom du père en arabe<br> PrenomMere/NomMere : Prénom/Nom de la mère <br> PrenomMereA/NomMereA : Prénom/Nom de la mère en arabe<br> MatriculeProgres : Matricule unique de l'étudiant sur la plateforme Progres"))
        messages.info(request, "Dans le cas de modification: les champs vides n'écrasent pas l'existant.")
    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer des étudiants'})

@login_required
def export_etudiants_list(request):
    if not( request.user.has_perm('scolar.fonctionnalite_etudiants_export')):
        messages.error(request, "ERREUR: Vous n'êtes pas autorisés à exécuter cette opération")
        return redirect('/accounts/login/?next=%s' % request.path)
    try:
    # Create the HttpResponse object with the appropriate  header.
        filter = EtudiantFilter(request.GET, queryset=Etudiant.objects.all().order_by('nom', 'prenom'))
        etudiant_list=filter.qs
        header=['Matricule','NomEtud', 'Prenoms', 'Genre', 'Ddn', 
                                           'LieuNaissance', 'WilayaNaissance', 'NomEtudA', 'PrenomsA', 'LieuNaissanceA', 
                                           'Email', 'Telephone', 'AdressePrincipale', 'WilayaResidence', 'CommuneResidence',
                                           'Interne', 'ResidenceU','MatriculeBac','AnneeBac','SerieBac','MoyenneBac','Pere','PereA','NomMere','NomMereA','PrenomMere','PrenomMereA','MatriculeProgres']
               
     
        sheet=Dataset()
        sheet.headers = header    
        for etudiant_ in etudiant_list :
            row_=[]
            row_.append(str(etudiant_.matricule))
            row_.append(etudiant_.nom)
            row_.append(etudiant_.prenom)
            row_.append(etudiant_.sexe if etudiant_.sexe else '')
            row_.append(etudiant_.date_naissance if etudiant_.date_naissance else '')
            row_.append(etudiant_.lieu_naissance if etudiant_.lieu_naissance else '')
            row_.append(etudiant_.wilaya_naissance.code if etudiant_.wilaya_naissance else '')            
            row_.append(etudiant_.nom_a if etudiant_.nom_a else '')
            row_.append(etudiant_.prenom_a if etudiant_.prenom_a else '')
            row_.append(etudiant_.lieu_naissance_a if etudiant_.lieu_naissance_a else '')
            row_.append(etudiant_.get_email())
            row_.append(str(etudiant_.tel) if etudiant_.tel else '')
            row_.append(etudiant_.addresse_principale if etudiant_.addresse_principale else '')            
            row_.append(etudiant_.wilaya_residence.code if etudiant_.wilaya_residence else '')
            row_.append(etudiant_.commune_residence.code_postal if etudiant_.commune_residence else '')
            row_.append("Oui" if etudiant_.interne else "Non")
            row_.append(etudiant_.residence_univ if etudiant_.residence_univ else '')
            row_.append(etudiant_.n_inscription_bac if etudiant_.n_inscription_bac else '')
            row_.append(etudiant_.annee_bac if etudiant_.annee_bac else '')
            row_.append(dict(Serie_bac)[etudiant_.serie_bac] if etudiant_.serie_bac and dict(Serie_bac)[etudiant_.serie_bac] else '')
            row_.append(etudiant_.moyenne_bac if etudiant_.moyenne_bac else '')
            row_.append(etudiant_.prenom_pere if etudiant_.prenom_pere else '')
            row_.append(etudiant_.prenom_pere_a if etudiant_.prenom_pere_a else '')
            row_.append(etudiant_.nom_mere if etudiant_.nom_mere else '')
            row_.append(etudiant_.nom_mere_a if etudiant_.nom_mere_a else '')
            row_.append(etudiant_.prenom_mere if etudiant_.prenom_mere else '')
            row_.append(etudiant_.prenom_mere_a if etudiant_.prenom_mere_a else '')
            row_.append(etudiant_.matricule_progres if etudiant_.matricule_progres else '')   
            
            
            sheet.append(row_)            
        filename='Liste_Etudiants.xlsx'
        response = HttpResponse(content_type='application/vnd.ms-excel')
        response['Content-Disposition'] = 'attachment; filename='+filename+";"
        response.write(sheet.xlsx)
    except Exception :
        if settings.DEBUG: 
            raise Exception
        else :
            messages.error(request, "ERREUR: Il y a eu une erreur lors de l'export du fichier des Etudiants")      
    return response 
     
def inscriptions_import_view(request):
    if not request.user.has_perm('scolar.fonctionnalite_etudiants_gestion'):
        return redirect('/accounts/login/?next=%s' % request.path)
    
    # if this is a POST request we need to process the form data
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = ImportFileForm(request.POST, request.FILES)
        
        # check whether it's valid:
        if form.is_valid():
            try:
                inscription_file = request.FILES['file']
                dataset = Dataset(headers=['Matricule','NomEtud', 'Prenoms', 'AnScol', 'Promo', 'Situation'])
                imported_data = dataset.load(inscription_file.read(), format ='xlsx')
                # insert imported_data in Etudiant table
                group=Group.objects.get(name='etudiant')
                for row in imported_data.dict :
                    etudiant_, created=Etudiant.objects.get_or_create(matricule=str(row['Matricule']).strip(), defaults={
                            'matricule':str(row['Matricule']).strip(),
                            'nom':row['NomEtud'],
                            'prenom':row['Prenoms'],
                        }
                    )
                    # Inscription de l'étudiant
                    annee_univ_, created=AnneeUniv.objects.get_or_create(annee_univ=row['AnScol'], defaults={
                            'annee_univ':str(row['AnScol'])
                        })
                    programme_=get_object_or_404(Programme, code=row['Promo'])
                    formation_, created=Formation.objects.get_or_create(programme=programme_, annee_univ=annee_univ_, defaults={
                            'programme':programme_,
                            'annee_univ':annee_univ_
                        })
                    inscription_, created=Inscription.objects.update_or_create(etudiant=etudiant_, formation=formation_, defaults={
                        'etudiant':etudiant_,
                        'formation':formation_,
                        'decision_jury':row['Situation'] if row['Situation'] else 'X'
                        })
                    # créer inscription_periodes selon le programme
                    for periode_ in formation_.programme.periodes.all():
                        InscriptionPeriode.objects.update_or_create(inscription=inscription_, periodepgm=periode_, defaults={
                                'inscription':inscription_,
                                'periodepgm':periode_,
                            })
                    
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: Echec de l'importation des inscriptions.")
                    messages.info(request, "La première ligne du fichier .xlsx doit comprendre au moins les colonnes: 'Matricule','NomEtud', 'Prenoms', 'AnScol', 'Promo', 'Situation'")
                    messages.info(request, "La colonne AnScol indique l'année universitaire, par ex. 2019")
                    messages.info(request, mark_safe("La colonne Promo doit correspondre au code d'un programme, par ex : 1CP, 2CP, 1CS, 2SL, 2SQ, 2ST, 3SL, 3ST, 3SQ, MSL, MSQ, MST, ... etc.<br><br>"+
                                            "La colonne Situation doit avoir une des valeurs suivantes : X pour Non Inscrit, C pour Inscrit, F pour Abandon, FT pour Transfert, M pour Maladie, M1 pour Congé académique (année blanche) pour raisons médicales, M2 pour Congé académique (année blanche) pour raisons personnelles, M3 pour Congé académique (année blanche) pour raisons personnelles (Covid 19), M4 pour Congé académique (année blanche) pour raisons familiales, M5 pour un congé académique, etc "))
                    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer des inscriptions'})
            # redirect to a new URL:
            messages.success(request, "L'importation des inscriptions s'est faite avec succès!")
            return HttpResponseRedirect(reverse('inscription_list')) 
    # if a GET (or any other method) we'll create a blank form
    else:
        form = ImportFileForm()
        messages.info(request, "Indiquer un fichier .xlsx des inscriptions à importer dans la base de Talents.")
        messages.info(request, "La première ligne du fichier .xlsx doit comprendre au moins les colonnes: 'Matricule','NomEtud', 'Prenoms', 'AnScol', 'Promo', 'Situation'")
        messages.info(request, "La colonne AnScol indique l'année universitaire, par ex. 2019")
        messages.info(request, mark_safe("La colonne Promo doit correspondre au code d'un programme, par ex : 1CP, 2CP, 1CS, 2SL, 2SQ, 2ST, 3SL, 3ST, 3SQ, MSL, MSQ, MST, ... etc.<br><br>"+
                                        "La colonne Situation doit avoir une des valeurs suivantes : X pour Non Inscrit, C pour Inscrit, F pour Abandon, FT pour Transfert, M pour Maladie, M1 pour Congé académique (année blanche) pour raisons médicales, M2 pour Congé académique (année blanche) pour raisons personnelles, M3 pour Congé académique (année blanche) pour raisons personnelles (Covid 19), M4 pour Congé académique (année blanche) pour raisons familiales, M5 pour un congé académique, etc "))
    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer des inscriptions'})


@login_required
def enseignants_import_view(request):
    if not request.user.has_perm('scolar.fonctionnalite_enseignants_gestion'):
        return redirect('/accounts/login/?next=%s' % request.path)
    
    additional_headers=""
    additional_message=""
    if activation_charges() :
        additional_headers+=", 'Charge'"
        additional_message+="<br> Charge : Nombre entier ou texte avec caractères décimaux formant un entier. La charge doit être obligatoirement spécifiée (elle est par défaut fixée à 288)"
    # if this is a POST request we need to process the form data
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = ImportFileForm(request.POST, request.FILES)
        
        # check whether it's valid:
        if form.is_valid():
            try:
                enseignant_file = request.FILES['file']
                headers=['Nom', 'Eps', 'Prenom', 'NomA', 'EpsA', 'PrenomA', 'Sexe','Ddn', 'Dde', 'Grade', 'Situation', 'Tel', 'Bureau', 'Bal', 'Email', 'Charge','Matricule', 'Organisme']
                if not activation_charges() :
                    headers.remove('Charge')
                dataset = Dataset(headers)
                imported_data = dataset.load(enseignant_file.read(), format ='xlsx')
                # insert imported_data in Enseignant table
                group=Group.objects.get(name='enseignant')
                for row in imported_data.dict :
                    enseignant_object=Enseignant.objects.none()
                    user_object=User.objects.none()
                    if row['Email'] :
                        enseignant_object=Enseignant.objects.filter(user__email__iexact=row['Email'].strip())
                    else :
                        if not row['Nom'] or not row['Prenom'] :
                            raise Exception("Si le champs Email n'est pas spécifié dans le fichier excel, alors Nom et Prenom doivent être spécifiés pour retrouver l'enseignant à mettre à jour")
                        else :
                            enseignant_object=Enseignant.objects.filter(nom__iexact=row['Nom'], prenom__iexact=row['Prenom'])
                    
                    organisme_=None
                    if row['Organisme'] :
                        organismes_qs=Organisme.objects.filter(interne=True, sigle__iexact=row['Organisme'])
                        if organismes_qs.exists() :
                            organisme_=organismes_qs.first()
                    
                    if enseignant_object.exists() :
                        enseignant_object=enseignant_object.first()
                        if enseignant_object.user :
                            user_object=enseignant_object.user
                            email_=enseignant_object.user.email
                        else :
                            email_=row['Email'].strip() if row['Email'] else None
                    else :
                        email_=row['Email'].strip() if row['Email'] else None
                        enseignant_object=Enseignant.objects.none()
                        
                    created=False        
                    if not enseignant_object :
                        enseignant_=Enseignant.objects.create(
                                nom=row['Nom'],
                                eps=row['Eps'] if row['Eps'] else None,
                                prenom=row['Prenom'],
                                nom_a=row['NomA'] if row['NomA'] else None,
                                eps_a=row['EpsA'] if row['EpsA'] else None,
                                prenom_a=row['PrenomA'] if row['PrenomA'] else None,
                                sexe=row['Sexe'] if row['Sexe'] else None,
                                date_naissance=row['Ddn'] if row['Ddn'] else None,
                                date_embauche=row['Dde'] if row['Dde'] else None,
                                grade=row['Grade'] if row['Grade'] else None,
                                situation=row['Situation'] if row['Situation'] else None,
                                bureau=str(row['Bureau']) if row['Bureau'] else None,
                                tel=str(row['Tel']) if row['Tel'] else None,
                                #'bal':int(str(row['Bal'])) if str(row['Bal'])!='' else 0,
                                bal=int(row['Bal']) if row['Bal']else None,
                                charge_statut=int(row['Charge']) if (activation_charges() and row['Charge']) else 288,
                                matricule=str(row['Matricule']).strip() if row['Matricule'] else None,
                                organisme=organisme_
                        )
                        created=True
                    else :
                        enseignant_, created=Enseignant.objects.update_or_create(id=enseignant_object.id, defaults={
                                'nom':row['Nom'] if row['Nom'] else enseignant_object.nom,
                                'eps':row['Eps'] if row['Eps'] else enseignant_object.eps,
                                'prenom':row['Prenom'] if row['Prenom'] else enseignant_object.prenom,
                                'nom_a':row['NomA'] if row['NomA'] else enseignant_object.nom_a,
                                'eps_a':row['EpsA'] if row['EpsA'] else enseignant_object.eps_a,
                                'prenom_a':row['PrenomA'] if row['PrenomA'] else enseignant_object.prenom_a,
                                'sexe':row['Sexe'] if row['Sexe'] else enseignant_object.sexe,
                                'date_naissance':row['Ddn'] if row['Ddn'] else enseignant_object.date_naissance,
                                'date_embauche':row['Dde'] if row['Dde'] else enseignant_object.date_embauche,
                                'grade':row['Grade'] if row['Grade'] else enseignant_object.grade,
                                'situation':row['Situation'] if row['Situation'] else enseignant_object.situation,
                                'bureau':str(row['Bureau']) if row['Bureau'] else enseignant_object.bureau,
                                'tel':str(row['Tel']) if row['Tel'] else enseignant_object.tel,
                                'bal':int(row['Bal']) if row['Bal']else enseignant_object.bal,
                                'charge_statut':int(row['Charge']) if (activation_charges() and row['Charge']) else enseignant_object.charge_statut,
                                'matricule':str(row['Matricule']).strip() if row['Matricule'] else enseignant_object.matricule,
                                'organisme' : organisme_ if organisme_ else enseignant_object.organisme,
                    
                            }
                        )  
                        
                    if email_ :
                        if not user_object :
                            user_qs=User.objects.filter(username__iexact=email_)
                            if user_qs.exists() :
                                user=user_qs.first()
                            else :
                                psw=User.objects.make_random_password()
                                user=User.objects.create_user(email_, email_, psw)
                            user.groups.add(group)
                            user.save()
                        else :
                            user=user_object
                        enseignant_.user=user
                        enseignant_.edt='<iframe src="https://calendar.google.com/calendar/embed?src='+user.email+'&ctz=Africa%2FAlgiers" style="border: 0" width="800" height="600" frameborder="0" scrolling="no"></iframe>'
                    enseignant_.save()                   
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: l'importation du fichier des enseignants s'est arrêtée avec echec.")
                    messages.info(request, mark_safe("La première ligne doit comporter au moins les colonnes suivantes: 'Nom', 'Eps', 'Prenom', 'NomA', 'EpsA', 'PrenomA', 'Sexe','Ddn', 'Dde', 'Grade', 'Situation', 'Tel', 'Bureau', 'Bal', 'Email', 'Matricule', 'Organisme'"+additional_headers+"<br><br>"+
                                                     "Sexe : 'M' ou 'F' <br>Ddn : Date de naissance de type date sur Excel<br>Dde : Date d'embauche de type date sur excel<br>Grade : MA, MA.B, MA.A, MC, MC.B, MC.A, PR <br>Situation : 'A' = En activité , 'D'= Mise en disponibilité, 'T'= Détachement, 'M'= Congé de Maladie, 'I'= Invalidité, 'R'= Retraité, 'X'= Départ ou Mutation ou Démission .. <br>Tel: Colonne nombre ou texte  <br>Bureau (numéro du bureau de l'enseignant) : Colonne en nombre ou texte  <br>Bal (numéro de boite aux lettres) : Colonne en nombre ou texte  <br>Matricule : Matricule de l'enseignant<br>"+
                                                     "Organisme : sigle du laboratoire/service/.. Si l'enseignant fait partie d'un service, laboratoire, il faudra d'abord créer les organismes dans la page de création des organismes et les marquer comme internes, c'est utile lors de la post-graduation avec des laboratoires internes qui font office d'organismes. 'Organisme' est donc une notion abstraite. (Ne pas renseigner au départ si ce n'est pas maîtrisé)"+additional_message))
                    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer des enseignants'})
            # redirect to a new URL:
            messages.success(request, "L'importation du fichier des enseignants s'est faite avec succès!")
            return HttpResponseRedirect(reverse('enseignant_list')) 
    # if a GET (or any other method) we'll create a blank form
    else:
        form = ImportFileForm()
        messages.info(request, "Indiquer le fichier .xlsx des enseignants. L'email, le nom et le prénom en latin sont des champs obligatoires, les autres champs peuvent être omis pour chaque ligne mais la colonne excel doit être présente. L'ordre des colonnes n'est pas important.")
        messages.info(request, mark_safe("La première ligne doit comporter au moins les colonnes suivantes: 'Nom', 'Eps', 'Prenom', 'NomA', 'EpsA', 'PrenomA', 'Sexe','Ddn', 'Dde', 'Grade', 'Situation', 'Tel', 'Bureau', 'Bal', 'Email', 'Matricule, 'Organisme'"+additional_headers+"<br><br>"+
                                         "Sexe : 'M' ou 'F' <br>Ddn : Date de naissance de type date sur Excel<br>Dde : Date d'embauche de type date sur excel<br>Grade : MA, MA.B, MA.A, MC, MC.B, MC.A, PR <br>Situation : 'A' = En activité , 'D'= Mise en disponibilité, 'T'= Détachement, 'M'= Congé de Maladie, 'I'= Invalidité, 'R'= Retraité, 'X'= Départ ou Mutation ou Démission .. <br>Tel: Colonne nombre ou texte  <br>Bureau (numéro du bureau de l'enseignant) : Colonne en nombre ou texte <br>Bal (numéro de boite aux lettres) : Colonne en nombre ou texte <br>Matricule : Matricule de l'enseignant<br>"+
                                         "Organisme : sigle du laboratoire/service/.. Si l'enseignant fait partie d'un service, laboratoire, il faudra d'abord créer les organismes dans la page de création des organismes et les marquer comme internes, c'est utile lors de la post-graduation avec des laboratoires internes qui font office d'organismes. 'Organisme' est donc une notion abstraite. (Ne pas renseigner au départ si ce n'est pas maîtrisé)"+additional_message))
    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer des enseignants'})

def feedback_import_view(request, module_pk):
    if not request.user.has_perm('scolar.fonctionnalite_pedagogie_importationfeedbacks'):
        return redirect('/accounts/login/?next=%s' % request.path)
    
    # if this is a POST request we need to process the form data
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = ImportFeedbackForm(module_pk, request.POST, request.FILES)
        # check whether it's valid:
        if form.is_valid():
            try:
                feedback_file = request.FILES['file']
                
                dataset = Dataset()
                imported_data = dataset.load(feedback_file.read(), format ='xlsx')
                # insert imported_data in Feebdback table
                form_data=form.cleaned_data
                module_=form_data['module']
                
                for row in imported_data.dict :
                    
                    feedback_=Feedback.objects.create(module=module_)
                    for question_ in Question.objects.all():
                        if row.get(question_.code):
                            reponse_=Reponse.objects.create(feedback=feedback_, question=question_)
                            reponse_.reponse=row[question_.code]
                            reponse_.save()
                    feedback_.comment=str(row['Comment']) if row['Comment'] else None
                    feedback_.show=False
                    feedback_.save()
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: L'importation des feedbacks s'est terminée avec echec!")      
                    messages.info(request,"La première ligne du fichier .xlsx doit comprendre les colonnes: Q01, Q02, Q03, ... Q10, Comment")
                    messages.info(request,"Les cellules comprennent les évaluations sous la forme de ++, +, -, --")
                    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer des feedbacks'})
            # redirect to a new URL:
            messages.success(request, "L'importation des feedback s'est faite avec succès!")
            return HttpResponseRedirect(reverse('module_list')) 
    # if a GET (or any other method) we'll create a blank form
    else:
        form = ImportFeedbackForm(module_pk)
        messages.info(request,"Indiquer le fichier .xlsx contenant les évaluations du module indiqué ci-dessous.")
        messages.info(request,"La première ligne du fichier .xlsx doit comprendre les colonnes: Q01, Q02, Q03, ... Q10, Comment")
        messages.info(request,"Les cellules comprennent les évaluations sous la forme de ++, +, -, --")
    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer des feedbacks'})


class FeedbackChart(Chart):
    chart_type='bar'
    options= {
        'scales': {
            'xAxes': [{
                'stacked': True
            }],
            'yAxes': [{
                'stacked': True,
                 'ticks': {
                     'suggestedMin': 0.0,
                     'suggestedMax': 1.0
                },
                 'offset':True
            }]
        }
    }
    
    def __init__(self, module_pk, *args, **kwargs):
        super(FeedbackChart, self).__init__(*args, **kwargs)
        self.labels=[]
        self.data=[]
        try:
            self.module_=get_object_or_404(Module, id=module_pk)
            feedback_list=Reponse.objects.filter(feedback__module=self.module_).exclude(reponse='')
            very_good_count=Count('reponse', filter=Q(reponse='++'))
            good_count=Count('reponse', filter=Q(reponse='+'))
            bad_count=Count('reponse', filter=Q(reponse='-'))
            very_bad_count=Count('reponse', filter=Q(reponse='--'))

            total_count=Count('reponse')
            feedback_data=feedback_list.values('feedback__module','question__code').order_by('question__code').annotate(very_good=very_good_count).annotate(good=good_count).annotate(bad=bad_count).annotate(very_bad=very_bad_count).annotate(total=total_count)
                
            reponse_list=[
                {
                    'label':'very_bad',
                    'reponse':'--',
                    'color':(256,0,0)
                },
                {
                    'label':'bad',
                    'reponse':'-',
                    'color':(256,256,0)
                },
                {
                    'label':'good',
                    'reponse':'+',
                    'color':(0,256,0)
                },
                {
                    'label':'very_good',
                    'reponse':'++',
                    'color':(0,128,0)
                }
                
            ]
            
            for reponse in reponse_list :
                data_=[]
                for question in feedback_data :
                    if question['total'] != 0 :
                        data_.append(round(question[reponse['label']]/question['total'],2))
                        if not question['question__code'] in self.labels:
                            self.labels.append(question['question__code'])
                dataset=DataSet(label=reponse['reponse'], data=data_, color=reponse['color'])
                
                self.data.append(dataset)
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: echec de création du graphique des feedbacks.")
        
    def get_labels(self, *args, **kwargs):
        return self.labels
    
    def get_datasets(self, **kwargs):
        return self.data


class DeliberationListView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, TemplateView):

    template_name = 'scolar/filter_list.html'
    success_message = "Choisir la formation pour les délibérations. Privilégiez le format Résumé plus rapide à générer."
    
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalitenav_pedagogie_generationpvsdeliberation')


    def get_queryset(self, **kwargs):
        return Formation.objects.all().order_by('-annee_univ__annee_univ','programme__ordre')
    
    
    def get_context_data(self, **kwargs):
        context = super(DeliberationListView, self).get_context_data(**kwargs)

        filter_ = FormationFilter(self.request.GET, queryset=self.get_queryset(**kwargs))
        filter_.form.helper = FormHelper()
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalitenav_pedagogie_generationpvsdeliberation'):
            exclude_.append('edit')
            exclude_.append('admin')
        table = DeliberationFormationTable(filter_.qs, exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['titre'] = 'Délibérations'
        context['filter'] = filter_
        context['table'] = table
        context['back'] = reverse('home')
        return context

def get_resultat_list_context(formation_pk):
    """
    cette fonction fabrique le context des résultats détaillés par période/UE/matière pour chaque inscrit
    """
    formation_=Formation.objects.get(id = formation_pk)
    inscription_list=formation_.inscriptions_pour_deliberations().order_by('rang')
    
    resultat_list={}
    for inscription_ in inscription_list:
        for periode_ in formation_.programme.periodes.all() :
            ue_list=[]
            for ue in periode_.ues.filter(nature='OBL') :
                ue_list.append(ue)
            inscription_periode_=inscription_.inscription_periodes.get(periodepgm=periode_)
            for ue in inscription_periode_.groupe.option.filter(periode=periode_):
                if not ue in ue_list:
                    ue_list.append(ue)
            for ue in ue_list:
                for matiere in ue.matieres.all() :
                    resultat_=Resultat.objects.get(ancien_resultat__isnull=True, inscription=inscription_, module__matiere__code=matiere.code)
                    key_=inscription_.etudiant.matricule+'_'+periode_.periode.code+'_'+str(ue.id)+'_'+matiere.code
                    resultat_list[key_]=resultat_
                key_=inscription_.etudiant.matricule+'_'+str(ue.id)+'_moy'
                resultat_list[key_]=round(resultat_.resultat_ue.moyenne(),2)
            key_=inscription_.etudiant.matricule+'_'+periode_.periode.code+'_moy'
            resultat_list[key_]=round(resultat_.resultat_ue.inscription_periode.moy,2)
            key_=inscription_.etudiant.matricule+'_'+periode_.periode.code+'_ne'
            resultat_list[key_]=resultat_.resultat_ue.inscription_periode.nb_ne()
            key_=inscription_.etudiant.matricule+'_'+periode_.periode.code+'_rang'
            resultat_list[key_]=resultat_.resultat_ue.inscription_periode.rang

        key_=inscription_.etudiant.matricule+'_moy'
        resultat_list[key_]=round(inscription_.moy,2)
    return resultat_list

class PVDeleteView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, DeleteView):
    model = PV
    template_name = 'scolar/delete.html'
    success_message = "Le PV a bien été supprimé."
    
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalitenav_pedagogie_generationpvsdeliberation')

    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression du PV : "+str(object_))
        return super(PVDeleteView, self).delete(*args, **kwargs)
        
    def get_success_url(self):
        return reverse('deliberation_list')

class PVListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    login_url= settings.LOGIN_URL
    template_name = 'scolar/filter_list.html'
     
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalitenav_pedagogie_visualisationpvsdeliberation')
    
    def get_queryset(self, **kwargs):
        return PV.objects.filter(reserve=False).order_by('-formation__annee_univ__annee_univ', '-date', 'formation__programme__ordre', 'periode__ordre',)
    
    def get_context_data(self, **kwargs):
        context = super(PVListView, self).get_context_data(**kwargs)
        filter_ = PVFilter(self.request.GET, queryset=self.get_queryset(**kwargs))
        filter_.form.helper = FormHelper()
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalitenav_pedagogie_generationpvsdeliberation'):
            exclude_.append('edit')
            exclude_.append('admin')
        pv_list = PVEnseignantTable(filter_.qs, exclude=exclude_)
        RequestConfig(self.request).configure(pv_list)
        context['filter'] = filter_
        context['table'] = pv_list
        context['titre'] = 'Liste des procès verbaux de délibérations'
        return context
    
class DeliberationDetailView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    login_url= settings.LOGIN_URL
    template_name = 'scolar/deliberation_detail.html'
     
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalitenav_pedagogie_generationpvsdeliberation')
     
    def get_context_data(self, **kwargs):
        context = super(DeliberationDetailView, self).get_context_data(**kwargs)
        formation_=Formation.objects.get(id = self.kwargs.get('formation_pk'))

        context['formation'] = formation_
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalitenav_pedagogie_generationpvsdeliberation'):
            exclude_.append('edit')
            exclude_.append('admin')
        if not formation_.activation_rattrapage() :
            exclude_.append('post_rattrapage')
            
        pv_list = PVTable(PV.objects.filter(formation=formation_), exclude=exclude_)
        RequestConfig(self.request).configure(pv_list)
        context['pv_list'] = pv_list
        context['webhelp']=format_html(HELP_DELIBERATION)
        return context

@login_required
def confirmer_deliberation_view(request, formation_pk):
    if not request.user.has_perm('scolar.fonctionnalitenav_pedagogie_generationpvsdeliberation'):
        messages.error(request,"Vous n'avez pas les permissions pour accéder à cette vue.")
        return redirect('/accounts/login/?next=%s' % request.path)
    try:
        formation_=get_object_or_404(Formation, id=formation_pk)
        # submit as background task
        t = threading.Thread(target=task_confirmer_deliberation, args=[formation_, request.user])
        t.setDaemon(True)
        t.start()
        messages.info(request, "Votre demande de confirmation du PV de délibérations est prise en compte. Vous recevrez une notification aussitôt effectuée.")         
        # redirect to a new URL:
        return HttpResponseRedirect(reverse('deliberation_detail', kwargs={'formation_pk':formation_pk,}))
    except Exception: 
        if settings.DEBUG:
            raise Exception
        else:
            messages.error(request, "ERREUR: lors de la demande de confirmation des délibérations.")
    return HttpResponseRedirect(reverse('deliberation_detail', kwargs={'formation_pk':formation_pk,}))


@login_required
def confirmer_deliberation_confirmation(request, formation_pk):
    
    context={}
    context['info']="La confirmation des décisions de délibération est définitive. Ne la faîtes que si la délibération est terminée et que le PV est final. Les décisions finales seront sauvegardées dans les profils des étudiants."
    context['lien']=reverse('confirmer_deliberation', kwargs={'formation_pk': formation_pk}) 
    return render(request, 'scolar/confirmation.html', context)

    
@transaction.atomic
def task_confirmer_deliberation(formation_, user):
    try:

        for inscription_ in formation_.inscriptions_pour_deliberations():
            inscription_.decision_jury=inscription_.proposition_decision_jury
            inscription_.save(update_fields=['decision_jury',])
            
            #marquer les modules acquis
            Resultat.objects.filter(ancien_resultat__isnull=True, inscription=inscription_, moy_post_delib__gte=10).update(acquis=True)
        
        trace_create(user, user, "Confirmation des décisions de délibération : "+str(formation_))                       
        if activation_emails():
            email = EmailMessage('[Talents] Confirmation des délibérations de la formation '+str(formation_),
                                 'Bonjour,\n'+ 
                                 'La confirmation du PV de délibération de '+str(formation_)+' est terminée \n'+
                                 'Nous vous en remercions \n'+
                                 'Bien cordialement.\n'+
                                 signature_emails(), to=[user.get_email()] )
            email.send(fail_silently=False)

    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            if activation_emails():
                email = EmailMessage('[Talents] Erreur lors de la confirmation du PV de délibération la formation '+str(formation_),
                                     'Bonjour,\n'+ 
                                     'Une erreur s\'est produite lors de la confirmation des délibérations de la formation '+str(formation_)+'\n'+
                                     'Bien cordialement.\n'+
                                     signature_emails(), to=[user.get_email()] )
                email.send(fail_silently=True)

@login_required
def envoi_deliberation_view(request, formation_pk):
    if not request.user.has_perm('scolar.fonctionnalitenav_pedagogie_generationpvsdeliberation'):
        messages.error(request,"Vous n'avez pas les permissions pour accéder à cette vue.")
        return redirect('/accounts/login/?next=%s' % request.path)
    try:
        formation_=get_object_or_404(Formation, id=formation_pk)
        # submit as background task
        t = threading.Thread(target=task_envoi_deliberation, args=[formation_, request.user])
        t.setDaemon(True)
        t.start()
        messages.info(request, "Votre demande d'envoi du PV de délibérations est prise en compte. Vous recevrez une notification aussitôt effectuée.")         
        # redirect to a new URL:
        return HttpResponseRedirect(reverse('deliberation_detail', kwargs={'formation_pk':formation_pk,}))
    except Exception: 
        if settings.DEBUG:
            raise Exception
        else:
            messages.error(request, "ERREUR: lors de la demande d'envoi des délibérations.")
    return HttpResponseRedirect(reverse('deliberation_detail', kwargs={'formation_pk':formation_pk,}))

@login_required
def envoi_deliberation_confirmation(request, formation_pk):
    
    context={}
    context['info']="Cette action enverra les décisions de délibération aux étudiants par mail."    
    context['lien']=reverse('envoi_deliberation', kwargs={'formation_pk': formation_pk})
    return render(request, 'scolar/confirmation.html', context)


@transaction.atomic
def task_envoi_deliberation(formation_, user):
    try:
        non_envoye=''
        for inscription_ in formation_.inscriptions_pour_deliberations():
            
            moyenne_rachat_str = 'Moyenne de Rachat' + str(inscription_.moyenne_post_delib())+'\n' if inscription_.decision_jury in ['AR', 'CR'] else ''
            Observation='Observation de jurry:  '+ str(inscription_.observation)+'\n' if inscription_.observation else ''
            
            try:
                if activation_emails():
                    email = EmailMessage('[Talents] Décision du Jury de Déliberation',
                                         'Bonjour '+str(inscription_.etudiant.nom)+' '+str(inscription_.etudiant.prenom)+',\n'+ 
                                         'Le jury a délibéré\n'+
                                         'Identification: '+str(inscription_.etudiant)+'\n'+
                                         'Décision du jury: '+dict(DECISIONS_JURY)[inscription_.decision_jury]+'\n'+
                                         'Moyenne Annuelle: '+str(inscription_.moy)+'\n'+
                                          moyenne_rachat_str +
                                         'Rang: '+str(inscription_.rang)+'\n'+
                                          Observation+ 
                                         'Vous pouvez avoir accès à tous les détails concernant vos résultats dans votre compte Talents.\n'+
                                         'Ceci est un message automatique. Il ne peut servir pour faire valoir vos droits. Seul le PV signé par le conseil fait foi.\n'+
                                         'Bien cordialement.\n'+
                                         signature_emails(), 
                                          to=[inscription_.etudiant.get_email()])
                    email.send(fail_silently=False)
                    sleep(1)

            except Exception:
                non_envoye+=str(inscription_)+'\n'
                continue
            
        erreur_envoi= 'Erreurs d\'envoi de notifications :\n'+ non_envoye if non_envoye != '' else ''
         
        trace_create(user, user, "Envoi des décisions de délibération : "+str(formation_))                         
        if activation_emails():
            email = EmailMessage('[Talents] Envoi des délibérations de la formation '+str(formation_),
                                 'Bonjour,\n'+ 
                                 'L\'envoi du PV de délibération de '+str(formation_)+' est terminé \n'+
                                 erreur_envoi+
                                 'Nous vous en remercions \n'+
                                 'Bien cordialement.\n'+
                                 signature_emails(), to=[user.get_email()] )
            email.send(fail_silently=False)
            sleep(1)

    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            if activation_emails():
                email = EmailMessage('[Talents] Erreur lors de l\'envoi du PV de délibération la formation '+str(formation_),
                                     'Bonjour,\n'+ 
                                     'Une erreur s\'est produite lors de l\'envoi des délibérations de la formation '+str(formation_)+'\n'+
                                     'Bien cordialement.\n'+
                                     signature_emails(), to=[user.get_email()] )
                email.send(fail_silently=True)
                sleep(1)

# def task_confirmer_deliberation(formation_, user):
#     try:
#         non_envoye=''
#         for inscription_ in formation_.inscriptions_pour_deliberations():
#             inscription_.decision_jury=inscription_.proposition_decision_jury
#             inscription_.save(update_fields=['decision_jury',])
#             
#             #marquer les modules acquis
#             Resultat.objects.filter(inscription=inscription_, moy_post_delib__gte=10).update(acquis=True)
#             
#             moyenne_rachat_str = 'Moyenne de Rachat' + str(inscription_.moyenne_post_delib())+'\n' if inscription_.decision_jury in ['AR', 'CR'] else ''
#             
#             
#             try:
#                 email_= inscription_.etudiant.get_email()
#                 email = EmailMessage('[Talents] Décision du Jury de Déliberation',
#                                      'Bonjour '+str(inscription_.etudiant.nom)+' '+str(inscription_.etudiant.prenom)+',\n'+ 
#                                      'Le jury a délibéré\n'+
#                                      'Identification: '+str(inscription_.etudiant)+'\n'+
#                                      'Décision du jury: '+dict(DECISIONS_JURY)[inscription_.decision_jury]+'\n'+
#                                      'Moyenne Annuelle: '+str(inscription_.moy)+'\n'+
#                                       moyenne_rachat_str +
#                                      'Rang: '+str(inscription_.rang)+'\n'+
#                                      'Vous pouvez avoir accès à tous les détails concernant vos résultats dans votre compte Talents.\n'+
#                                      'Ceci est un message automatique. Il ne peut servir pour faire valoir vos droits. Seul le PV signé par le conseil fait foi.\n'+
#                                      'Bien cordialement.\n'+
#                                      signature_emails(), to=[email_] )
#                 if activation_emails() :
#                     email.send(fail_silently=False)
#             except Exception:
#                 non_envoye+=str(inscription_)+'\n'
#                 continue
#             
#         erreur_envoi= 'Erreurs d\'envoi de notifications :\n'+ non_envoye if non_envoye != '' else ''
#                                
#         email = EmailMessage('[Talents] Confirmation des délibérations de la formation '+str(formation_),
#                              'Bonjour,\n'+ 
#                              'La confirmation du PV de délibération de '+str(formation_)+' et envoi des décisions est terminée \n'+
#                              erreur_envoi+
#                              'Nous vous en remercions \n'+
#                              'Bien cordialement.\n'+
#                              signature_emails(), to=[user.get_email()] )
#         if activation_emails():
#             email.send(fail_silently=False)
# 
#     except Exception:
#         if settings.DEBUG:
#             raise Exception
#         else:
#             email = EmailMessage('[Talents] Erreur lors de la confirmation du PV de délibération la formation '+str(formation_),
#                                  'Bonjour,\n'+ 
#                                  'Une erreur s\'est produite lors de la confirmation des délibérations de la formation '+str(formation_)+'\n'+
#                                  'Bien cordialement.\n'+
#                                  signature_emails(), to=[user.get_email()] )
#             if activation_emails():
#                 email.send(fail_silently=True)

def passage_settings_view(request, formation_pk):
    if not request.user.has_perm('scolar.fonctionnalitenav_pedagogie_generationpvsdeliberation'):
        messages.error(request,"Vous n'avez pas les permissions pour accéder à cette vue.")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    # if this is a POST request we need to process the form data
    formation_=Formation.objects.get(id=formation_pk)
    
    if request.method == 'POST':
        # create a form instance and populate it with data from the request
        form = PassageSettingsForm(formation_pk, request.POST)
        if form.is_valid():
            data = form.cleaned_data
            formation_.moyenne_passage=data['moyenne_passage']
            formation_.save(update_fields=['moyenne_passage'])
            if formation_.activation_rattrapage() :
                module_list=Module.objects.filter(formation=formation_).distinct()
                if formation_.activation_rattrapage() :
                    for module_ in module_list: 
                        module_.seuil_rattrapage=data['seuil_'+str(module_.id)]
                        module_.save(update_fields=['seuil_rattrapage'])
            # check whether it's valid:

   
            # redirect to a new URL:
            return HttpResponseRedirect(reverse('deliberation_detail', kwargs={'formation_pk':formation_pk,}))
    # if a GET (or any other method) we'll create a blank form
    else:
        form = PassageSettingsForm(formation_pk)
        messages.info(request, "Indiquez la configuration du passage.")
    return render(request, 'scolar/form.html', {'form': form, 'formation':formation_})

def deliberation_annuelle_settings_view(request, formation_pk):
    if not request.user.has_perm('scolar.fonctionnalitenav_pedagogie_generationpvsdeliberation'):
        messages.error(request,"Vous n'avez pas les permissions pour accéder à cette vue.")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    # if this is a POST request we need to process the form data
    formation_=Formation.objects.get(id=formation_pk)
    
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = SelectPVAnnuelSettingsForm(formation_pk, request.POST)
        # check whether it's valid:
        if form.is_valid():
            # submit as background task
            t = threading.Thread(target=task_deliberation_annuelle, args=[form, formation_, request.user])
            t.setDaemon(True)
            t.start()
            messages.info(request, "Votre demande de génération du PV est prise en compte. Vous recevrez une notification aussitôt généré.")         
            # redirect to a new URL:
            return HttpResponseRedirect(reverse('deliberation_detail', kwargs={'formation_pk':formation_pk,}))
    # if a GET (or any other method) we'll create a blank form
    else:
        form = SelectPVAnnuelSettingsForm(formation_pk)
        messages.info(request, "Indiquez la configuration du PV de délibération annuelle à générer.")
    return render(request, 'scolar/deliberation_annuelle_settings.html', {'form': form, 'formation':formation_})

# @transaction.atomic
# def task_deliberation_annuelle(form_, formation_, user):
#     context={}
#     data=form_.cleaned_data
#     try:    
#         sort_=data['sort'] # indique comment trier les étudiants par rang (pour délibérer) ou par groupe (pour vérifier les notes) 
#         
#         periode_list ={}
#         for periode_ in formation_.programme.periodes.all():
#             periode_list[periode_.id]={} 
#             periode_list[periode_.id]['periode']=periode_
#             periode_list[periode_.id]['ues']=[]
#             for ue in periode_.ues.filter(nature='OBL'):
#                 if not ue in periode_list[periode_.id]['ues']:
#                     periode_list[periode_.id]['ues'].append(ue)
#             for groupe_ in Groupe.objects.filter(section__formation=formation_):
#                 for ue in groupe_.option.filter(periode=periode_):
#                     if not ue in  periode_list[periode_.id]['ues']:
#                         periode_list[periode_.id]['ues'].append(ue)
#         if sort_:
#             inscription_list=formation_.inscriptions_pour_deliberations().order_by('rang')
#         else:
#             inscription_list=formation_.inscriptions_pour_deliberations().order_by('groupe__code', 'etudiant__nom', 'etudiant__prenom')
# 
#         context['resultat_list']=get_resultat_list_context(formation_.id)
#         context['formation'] = formation_
#         context['inscription_list']=inscription_list
#         context['decisions_jury']=dict(DECISIONS_JURY)    
#         context['signatures']=data['signatures']
#         context['date'] = datetime.date.today()
#         context['photo'] = data['photo']
#         context['anonyme'] = data['anonyme']
#         context['ne'] = data['ne']
#         context['moy_ue'] = data['moy_ue']
#         context['rang'] = data['rang']
#         context['rachat'] = data['rachat']
#         context['periode_list'] = periode_list
#         context['institution'] = user.institution()        
#     
#         pv, created=PV.objects.update_or_create(formation=formation_, annuel=True, tri_rang=data['sort'], anonyme=data['anonyme'],
#                                     photo=data['photo'], note_eliminatoire=data['ne'], moy_ue=data['moy_ue'],
#                                     reserve=data['reserve'], rang=data['rang'], signature=data['signatures'], defaults={
#                                         'formation':formation_, 
#                                         'annuel':True, 
#                                         'tri_rang':data['sort'], 
#                                         'anonyme':data['anonyme'],
#                                         'photo':data['photo'], 
#                                         'note_eliminatoire':data['ne'], 
#                                         'moy_ue':data['moy_ue'],
#                                         'rang':data['rang'],
#                                         'reserve':data['reserve'], 
#                                         'signature':data['signatures'],
#                                         'content': loader.render_to_string('scolar/deliberation_annuelle.html', context)
#                                         })         
#     except Exception:
#         if settings.DEBUG:
#             raise Exception
#         else:
#             email = EmailMessage('[Talents] Erreur lors de la génération du PV de  la formation '+str(formation_),
#                                  'Bonjour,\n'+ 
#                                  'Une erreur s\'est produite lors de la génération de la formation '+str(formation_)+'\n'+
#                                  'Veuillez vérifier les notes et réessayer \n'+
#                                  'Bien cordialement.\n'+
#                                  signature_emails(), to=[user.get_email()] )
#             if activation_emails():
#                 email.send(fail_silently=True)
#     else:
#         print('[Talents] Confirmation de la génération du PV de la formation '+str(formation_))
#         email = EmailMessage('[Talents] Confirmation de la génération du PV de la formation '+str(formation_),
#                              'Bonjour,\n'+ 
#                              'La génération du PV de délibération de '+str(formation_)+' est terminée \n'+
#                              'Nous vous en remercions \n'+
#                              'Bien cordialement.\n'+
#                              signature_emails(), to=[user.get_email()] )
#         if activation_emails():
#             email.send(fail_silently=True)



@transaction.atomic
def task_deliberation_annuelle(form_, formation_, user):
    context={}
    data=form_.cleaned_data
    try:    
        activation_credits=formation_.activation_credits()
        activation_ues=formation_.activation_ues()
        periode_annuelle_only=formation_.has_periode_annuelle_only()
        
        sort_=data['sort'] # indique comment trier les étudiants par rang (pour délibérer) ou par groupe (pour vérifier les notes) 
        
        header=['Matricule','Nom','Prenom']
        if data['dates_naissance'] :
            header = header + ['Ddn']
        periode_list ={}
        for periode_ in formation_.programme.periodes.all():
            header.append("Groupe_"+periode_.periode.code)
            periode_list[periode_.id]={} 
            periode_list[periode_.id]['periode']=periode_
            periode_list[periode_.id]['ues']=[]
            for ue in periode_.ues.filter(nature='OBL'):
                if not ue in periode_list[periode_.id]['ues']:
                    periode_list[periode_.id]['ues'].append(ue)
                    for matiere_ in ue.matieres.all():
                        if data['affichage_titres_matieres'] :
                            header.append(matiere_.titre)
                        else :
                            header.append(matiere_.code)
                    if activation_ues :
                        header.append(ue.code)
                    
            for groupe_ in Groupe.objects.filter(section__formation=formation_):
                for ue in groupe_.option.filter(periode=periode_):
                    if not ue in  periode_list[periode_.id]['ues']:
                        periode_list[periode_.id]['ues'].append(ue)
                        for matiere_ in ue.matieres.all():
                            if data['affichage_titres_matieres'] :
                                header.append(matiere_.titre)
                            else :
                                header.append(matiere_.code)
                        header.append(ue.code)
            if not periode_annuelle_only :
                header.append("Ne_"+periode_.periode.code)
                header.append("Rang_"+periode_.periode.code)
                header.append("Moy_"+periode_.periode.code)
                header.append("Moy_rachat"+periode_.periode.code)
                if activation_credits :
                    header.append("Crd_"+periode_.periode.code)
        header.append("Rang_annuel")
        header.append("Moy_annuelle")
        if data['affichage_moy_rachat'] :
            header.append("Moy_rachat")
        if activation_credits :
            header.append("Crd_annuel")
        header.append("Decision_jury")
        if data['observations'] :
            header.append("Observation")
                    
        if sort_:
            inscription_list=formation_.inscriptions_pour_deliberations().order_by('rang')
        elif data['tri_nom']:
            inscription_list=formation_.inscriptions_pour_deliberations().order_by('etudiant__nom', 'etudiant__prenom')
        else :
            inscription_list=formation_.inscriptions_pour_deliberations().order_by('groupe__code', 'etudiant__nom', 'etudiant__prenom')
            
        if not data['conges'] :
            inscription_list=inscription_list.exclude(Q(proposition_decision_jury__startswith='M'))

        if not data['abandons'] :
            inscription_list=inscription_list.exclude(Q(proposition_decision_jury='F'))

        if Inscription.objects.filter(proposition_decision_jury="FD").exists() and not data['defaillants'] :
            inscription_list=inscription_list.exclude(Q(proposition_decision_jury='FD'))
            
        if not data['non_inscrits'] : 
            inscription_list=inscription_list.exclude(Q(decision_jury='X'))
            
        context['resultat_list']=get_resultat_list_context(formation_.id)
        context['formation'] = formation_
        context['inscription_list']=inscription_list
        context['decisions_jury']=dict(DECISIONS_JURY)    
        context['signatures']=data['signatures']
        context['date'] = datetime.date.today()
        context['photo'] = data['photo']
        context['anonyme'] = data['anonyme']
        context['ne'] = data['ne']
        context['moy_ue'] = data['moy_ue']
        context['rang'] = data['rang']
        context['rachat'] = data['rachat']
        context['affichage_moy_rachat'] = data['affichage_moy_rachat']
        context['periode_list'] = periode_list
        context['institution'] = user.institution()
        context['dates_naissance']=data['dates_naissance'] 
        context['infos_etudiants_en_premier']=data['infos_etudiants_en_premier']
        context['situation_complete']=data['situation_complete']
        context['affichage_groupe']=data['affichage_groupe']
        context['affichage_final_chaque_periode']=data['affichage_final_chaque_periode']
        context['affichage_titres_matieres']=data['affichage_titres_matieres']
        context['provisoire']=data['provisoire']
        context['nb_lignes_signatures']=data['nb_lignes_signatures']
        context['nb_cases_par_ligne']=data['nb_cases_par_ligne']
        context['longueur']=data['longueur']
        context['largeur']=data['largeur']
        context['affichage_pied_de_page']=data['affichage_pied_de_page']
        context['police']=data['police']
        context['police_entete']=data['police_entete']
        context['repeter_entete']=data['repeter_entete']
        context['signatures_modules']=data['signatures_modules']
        context['observations']=data['observations']
    
        pv, created=PV.objects.update_or_create(formation=formation_, annuel=True, tri_rang=data['sort'], anonyme=data['anonyme'],
                                    photo=data['photo'], note_eliminatoire=data['ne'], moy_ue=data['moy_ue'],
                                    reserve=data['reserve'], rang=data['rang'], signature=data['signatures'], post_rattrapage=data['post_rattrapage'], defaults={
                                        'date':datetime.date.today(),
                                        'formation':formation_, 
                                        'annuel':True, 
                                        'tri_rang':data['sort'], 
                                        'anonyme':data['anonyme'],
                                        'photo':data['photo'], 
                                        'note_eliminatoire':data['ne'], 
                                        'moy_ue':data['moy_ue'],
                                        'rang':data['rang'],
                                        'reserve':data['reserve'], 
                                        'signature':data['signatures'],
                                        'post_rattrapage':data['post_rattrapage'],
                                        'content': loader.render_to_string('scolar/deliberation_annuelle.html', context)
                                        })
        if data['xlsx'] or data['xlsxemail']:
            #inscription_list=formation_.inscriptions_pour_deliberations().order_by('rang')
    
            sheet=Dataset()
            sheet.headers = header
    
            for inscrit_ in inscription_list :
                row_=[]
                row_.append(inscrit_.etudiant.matricule)
                row_.append(inscrit_.etudiant.nom)
                row_.append(inscrit_.etudiant.prenom)
                if data['dates_naissance'] :
                    row_.append(inscrit_.etudiant.date_naissance if inscrit_.etudiant.date_naissance else '')
                    
    
                for key_, periode_ in periode_list.items():
                    inscription_periode_= inscrit_.inscription_periodes.get(periodepgm=periode_['periode'])
                    row_.append(inscription_periode_.groupe.code)
                    for ue_ in periode_['ues']:
                        resultat_=None
                        for matiere_ in ue_.matieres.all():
                            try:
                                resultat_=Resultat.objects.get(inscription=inscrit_, resultat_ue__ue=ue_, module__matiere__code=matiere_.code)
                                row_.append(resultat_.moy_post_delib)
                            except Exception:
                                row_.append('')
                        if activation_ues :
                            if resultat_:
                                row_.append(resultat_.resultat_ue.moyenne_post_delib())
                            else:
                                row_.append('')
                    if not periode_annuelle_only :
                        row_.append(inscription_periode_.nb_ne())
                        row_.append(inscription_periode_.rang)
                        row_.append(inscription_periode_.moy)
                        row_.append(inscription_periode_.moyenne_post_delib())
                        if activation_credits :
                            row_.append(inscription_periode_.credits_obtenus())
                row_.append(inscrit_.rang)
                row_.append(inscrit_.moy)
                if data['affichage_moy_rachat'] :
                    row_.append(inscrit_.moyenne_post_delib())
                if activation_credits :
                    row_.append(inscrit_.credits_obtenus())
                if inscrit_.proposition_decision_jury.startswith('M') and not data['situation_complete']:
                    row_.append("Maladie")
                else:
                    row_.append(dict(DECISIONS_JURY)[inscrit_.proposition_decision_jury])
                if data['observations'] :
                    row_.append(inscrit_.observation if inscrit_.observation else '')
                    
                sheet.append(row_)
                
            filename="PV_"+str(formation_)+'.xlsx'
            filename=filename.replace(' ','_')
            
            if data['xlsx'] :
                random_string=''.join(random.choices(string.ascii_uppercase + string.digits, k=10))
                filename_saved = "PV_"+str(formation_)
                filename_saved=filename_saved.replace(' ','_')
                filename_saved=filename_saved+'_'+random_string
                filename_saved=filename_saved+'.xlsx'
                pv.xlsx.save(filename_saved, io.BytesIO(sheet.xlsx)) 
            
            if data['xlsxemail'] :
                if activation_emails():
                    email = EmailMessage('[Talents] Génération du PV de '+str(formation_),
                                         'Bonjour,\n'+ 
                                         'La génération du PV de délibération de '+str(formation_)+' est terminée \n'+
                                         'Veuillez trouver ci-joint le PV au format Excel\n'+
                                         'Bien cordialement.\n'+
                                         signature_emails(), to=[user.get_email(), formation_.programme.get_email_responsable_autorite_cycle()])
                    email.attach(filename, sheet.xlsx, 'application/vnd.ms-excel' )
                    email.send(fail_silently=True)
        
    except Exception as e:
        trace_create(user, user, 'Une erreur s\'est produite lors de la génération de la formation '+str(formation_))
        if settings.DEBUG:
            raise Exception
        else:
            if activation_emails():
                email = EmailMessage('[Talents] Erreur lors de la génération du PV de  la formation '+str(formation_),
                                     'Bonjour,\n'+ 
                                     'Une erreur s\'est produite lors de la génération de la formation '+str(formation_)+'\n'+
                                     'Veuillez vérifier les notes et réessayer \n'+
                                     'Bien cordialement.\n'+
                                     signature_emails()+'\n'+
                                     str(e), to=[user.get_email()] )
                email.send(fail_silently=True)
    else:
        trace_create(user, user, 'La génération du PV de délibération de '+str(formation_)+' est terminée \n')
        if not (data['xlsxemail']):
            if activation_emails():
                email = EmailMessage('[Talents] Confirmation de la Génération du PV de '+str(formation_),
                                     'Bonjour,\n'+ 
                                     'La génération du PV de délibération de '+str(formation_)+' est terminée \n'+
                                     'Bien cordialement.\n'+
                                     signature_emails(), to=[user.get_email()] )
                email.send(fail_silently=True)
    
@login_required
def export_pv_view(request, formation_pk):
    if not request.user.has_perm('scolar.fonctionnalitenav_pedagogie_generationpvsdeliberation'):
        messages.error(request, "Vous n'êtes pas autorisé à excéuter cette opération.")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    try:
        # Create the HttpResponse object with the appropriate CSV header.
        formation_=get_object_or_404(Formation, id=formation_pk)
        header=['Matricule','Nom','Prenom']        
        periode_list ={}
        for periode_ in formation_.programme.periodes.all():
            header.append("Groupe_"+periode_.periode.code)
            periode_list[periode_.id]={} 
            periode_list[periode_.id]['periode']=periode_
            periode_list[periode_.id]['ues']=[]
            for ue in periode_.ues.filter(nature='OBL'):
                if not ue in periode_list[periode_.id]['ues']:
                    periode_list[periode_.id]['ues'].append(ue)
                    for matiere_ in ue.matieres.all():
                        header.append(matiere_.code)
                    header.append(ue.code)
                    
            for groupe_ in Groupe.objects.filter(section__formation=formation_):
                for ue in groupe_.option.filter(periode=periode_):
                    if not ue in  periode_list[periode_.id]['ues']:
                        periode_list[periode_.id]['ues'].append(ue)
                        for matiere_ in ue.matieres.all():
                            header.append(matiere_.code)
                        header.append(ue.code)
            header.append("Ne_"+periode_.periode.code)
            header.append("Rang_"+periode_.periode.code)
            header.append("Moy_"+periode_.periode.code)
        header.append("Rang_annuel")
        header.append("Moy_annuelle")
        header.append("Moy_rachat")
        header.append("Decision_jury")
        
        inscription_list=formation_.inscriptions_pour_deliberations().order_by('rang')

        sheet=Dataset()
        sheet.headers = header

        for inscrit_ in inscription_list :
            row_=[]
            row_.append(inscrit_.etudiant.matricule)
            row_.append(inscrit_.etudiant.nom)
            row_.append(inscrit_.etudiant.prenom)

            for key_, periode_ in periode_list.items():
                inscription_periode_= inscrit_.inscription_periodes.get(periodepgm=periode_['periode'])
                row_.append(inscription_periode_.groupe.code)
                for ue_ in periode_['ues']:
                    resultat_=None
                    for matiere_ in ue_.matieres.all():
                        try:
                            resultat_=Resultat.objects.get(ancien_resultat__isnull=True, inscription=inscrit_, module__matiere__code=matiere_.code)
                            row_.append(resultat_.moy_post_delib)
                        except Exception:
                            row_.append('')
                    if resultat_:
                        row_.append(resultat_.resultat_ue.moyenne_post_delib())
                    else:
                        row_.append('')
                row_.append(inscription_periode_.ne)
                row_.append(inscription_periode_.rang)
                row_.append(inscription_periode_.moy)
            row_.append(inscrit_.rang)
            row_.append(inscrit_.moy)
            row_.append(inscrit_.moyenne_post_delib())
            row_.append(dict(DECISIONS_JURY)[inscrit_.decision_jury])

            sheet.append(row_)


        filename=str(formation_)+'.xlsx'
        filename=filename.replace(' ','_')
        
        response = HttpResponse(content_type='application/vnd.ms-excel')
        response['Content-Disposition'] = 'attachment; filename='+filename+";"
        response.write(sheet.xlsx)
    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            messages.error(request, "ERREUR: Il y a eu une erreur lors de l'export du PV. Merci de le signaler à l'administrateur.")
    return response




# def get_resultat_list_provisoire_context(formation_pk, matieres_moyenne, periode_cible):
#     """
#     cette fonction fabrique le context des résultats détaillés par période/UE/matière pour chaque inscrit
#     """
#     formation_=Formation.objects.get(id = formation_pk)
#     inscription_list=formation_.inscriptions_pour_deliberations()
#     
#     resultat_list={}
#     for inscription_ in inscription_list:
#         for periode_ in formation_.programme.periodes.all() :
#             moy=0
#             sum_coef=0
#             ue_list=[]
#             for ue in periode_.ues.filter(nature='OBL') :
#                 ue_list.append(ue)
#             inscription_periode_=inscription_.inscription_periodes.get(periodepgm=periode_)
#             for ue in inscription_periode_.groupe.option.filter(periode=periode_):
#                 if not ue in ue_list:
#                     ue_list.append(ue)
#             for ue in ue_list:
#                 for matiere in ue.matieres.all() :
#                     resultat_=Resultat.objects.get(inscription=inscription_, module__matiere__code=matiere.code)
#                     key_=inscription_.etudiant.matricule+'_'+periode_.periode.code+'_'+matiere.code
#                     resultat_list[key_]=resultat_
#                     if resultat_.module.matiere.code in matieres_moyenne:
#                         moy+=resultat_.moy*resultat_.module.matiere.coef
#                         sum_coef+=resultat_.module.matiere.coef
#             key_=inscription_.etudiant.matricule+'_'+periode_.periode.code+'_moy'
#             moy_=round(moy/sum_coef,2) if sum_coef!=0 else 0
#             resultat_list[key_]=moy_
# 
#             
#             key_=inscription_.etudiant.matricule+'_'+periode_.periode.code+'_ne'
#             ne_=resultat_.resultat_ue.inscription_periode.nb_ne_parmis_matieres(matieres_moyenne)
#             resultat_list[key_]=ne_
#             
#             if inscription_periode_.periode==periode_cible:
#                 inscription_periode_.moy=moy_
#                 inscription_periode_.ne=ne_
#                 inscription_periode_.save(update_fields=['moy','ne'])
# 
#     for inscription_ in inscription_list:
#         inscription_periode_=inscription_.inscription_periodes.get(periodepgm__periode=periode_cible)    
#         key_=inscription_.etudiant.matricule+'_'+inscription_periode_.periodepgm.code+'_rang'
#         rang_=inscription_periode_.ranking()
#         resultat_list[key_]=rang_
#         inscription_periode_.rang=rang_
#         inscription_periode_.save(update_fields=['rang'])
#         
#         #key_=inscription_.etudiant.matricule+'_moy'
#         #resultat_list[key_]=round(inscription_.moy,2)
#     return resultat_list

def get_resultat_list_provisoire_context(formation_pk, matieres_moyenne):
    """
    cette fonction fabrique le context des résultats détaillés par période/UE/matière pour chaque inscrit
    """
    formation_=Formation.objects.get(id = formation_pk)
    inscription_list=formation_.inscriptions_pour_deliberations()
    
    resultat_list={}
    for inscription_ in inscription_list:
        try:
            for periode_ in formation_.programme.periodes.all() :
                moy=0
                sum_coef=0
                ue_list=[]
                for ue in periode_.ues.filter(nature='OBL') :
                    ue_list.append(ue)
                inscription_periode_=inscription_.inscription_periodes.get(periodepgm=periode_)
                for ue in inscription_periode_.groupe.option.filter(periode=periode_):
                    if not ue in ue_list:
                        ue_list.append(ue)
                for ue in ue_list:
                    for matiere in ue.matieres.all() :
                        resultat_=Resultat.objects.get(ancien_resultat__isnull=True, inscription=inscription_, module__matiere__code=matiere.code)
                        key_=inscription_.etudiant.matricule+'_'+periode_.periode.code+'_'+matiere.code
                        resultat_list[key_]=resultat_
                        if resultat_.module.matiere.code in matieres_moyenne:
                            moy+=resultat_.moy*resultat_.module.matiere.coef
                            sum_coef+=resultat_.module.matiere.coef
                key_=inscription_.etudiant.matricule+'_'+periode_.periode.code+'_moy'
                moy_=round(moy/sum_coef,2) if sum_coef!=0 else 0
                resultat_list[key_]=moy_
                # inscrire cette moyenne provisioire dans inscription_periode_
                # inscription_periode_.moy=moy_
                key_=inscription_.etudiant.matricule+'_'+periode_.periode.code+'_ne'
                resultat_list[key_]=resultat_.resultat_ue.inscription_periode.nb_ne_parmis_matieres(matieres_moyenne)
                # ERROR: TO DO Le calcul du rang ne peut se faire ici car il doit se faire après le calcul et sauvegarde de toutes les moyennes
                key_=inscription_.etudiant.matricule+'_'+periode_.periode.code+'_rang'
                resultat_list[key_]=resultat_.resultat_ue.inscription_periode.ranking()
    
            key_=inscription_.etudiant.matricule+'_moy'
            resultat_list[key_]=round(inscription_.moy,2)
        except Exception as e:
            if settings.DEBUG:
                raise Exception("Erreur: lors de la construction du context de résultat de : "+ str(inscription_))
            else:
                if activation_emails():
                    email = EmailMessage('[Talents] Erreur lors de la construction du contexte de résultat de '+str(inscription_),
                                         'Bonjour,\n'+ 
                                         'Une erreur s\'est produite lors de la construction du contexte de résultat de '+str(inscription_)+'\n'+
                                         'Bien cordialement.\n'+
                                         signature_emails()+'\n'+
                                         str(e), to=[formation_.programme.get_email_responsable_autorite_cycle()] )
                    email.send(fail_silently=True)
                continue
                
    return resultat_list
        

def deliberation_provisoire_settings_view(request, formation_pk, periode_pk):
    if not request.user.has_perm('scolar.fonctionnalitenav_pedagogie_generationpvsdeliberation'):
        messages.error(request,"Vous n'avez pas les permissions pour accéder à cette vue.")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    # if this is a POST request we need to process the form data
    formation_=Formation.objects.get(id=formation_pk)
    periode_=Periode.objects.get(id=periode_pk)
    
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = SelectPVSettingsForm(formation_pk, request.POST)
        # check whether it's valid:
        if form.is_valid():
            # submit as background task
            t = threading.Thread(target=task_deliberation_provisoire, args=[form, formation_, periode_, request.user])
            t.setDaemon(True)
            t.start()
            messages.info(request, "Votre demande de génération du PV est prise en compte. Vous recevrez une notification aussitôt généré.")         
            # redirect to a new URL:
            return HttpResponseRedirect(reverse('deliberation_detail', kwargs={'formation_pk':formation_pk,}))
            #return HttpResponseRedirect("%s?%s" % (reverse('deliberation_provisoire', kwargs={'formation_pk':formation_pk, 'periode_pk':periode_pk}), 
            #                                        urllib.parse.urlencode(form.cleaned_data)))
    # if a GET (or any other method) we'll create a blank form
    else:
        form = SelectPVSettingsForm(formation_pk)
        messages.info(request, "Indiquez la configuration du PV de délibération à générer pour la période.")
    return render(request, 'scolar/deliberation_provisoire_settings.html', {'form': form, 'formation':formation_, 'periode':periode_})


@transaction.atomic
def task_deliberation_provisoire(form_, formation_, periode, user):
    context={}
    data=form_.cleaned_data
    try:    
        header=['Matricule','Nom','Prenom']
        if data['affichage_decisions_jury'] :
            header.append('Situation')
        periode_list={}
        for periode_ in formation_.programme.periodes.all():
            header.append("Groupe_"+periode_.periode.code)
            periode_list[periode_.id]={} 
            periode_list[periode_.id]['periode']=periode_
            periode_list[periode_.id]['matieres']=[]
            for ue in periode_.ues.filter(nature='OBL'):
                for matiere in ue.matieres.all():
                    if not matiere in periode_list[periode_.id]['matieres'] :
                        periode_list[periode_.id]['matieres'].append(matiere)
                        if matiere.code in data['matieres_affichage_'+periode_.periode.code]:
                            header.append(matiere.code)

            for groupe_ in Groupe.objects.filter(section__formation=formation_):
                for ue in groupe_.option.filter(periode=periode_):
                    for matiere in ue.matieres.all():
                        if not matiere in periode_list[periode_.id]['matieres'] :
                            periode_list[periode_.id]['matieres'].append(matiere)
                            if matiere.code in data['matieres_affichage_'+periode_.periode.code]:
                                header.append(matiere.code)
            
            if periode_.periode == periode:
                header.append("Ne_"+periode.code)
                header.append("Rang_"+periode.code)
                header.append("Moy_"+periode.code)

        resultat_list=[]
     
        matieres_moyenne=[]
        for periode_ in formation_.programme.periodes.all():
            matieres_moyenne+=data['matieres_moyenne_'+periode_.periode.code]
        #matieres_moyenne = re.split('[ ,\'\[\]]{1}', matieres_moyenne)
        resultat_list=get_resultat_list_provisoire_context(formation_.id, matieres_moyenne)
        context['resultat_list']=resultat_list
     
        #inscription_list=Inscription.objects.filter(formation=formation_).exclude(Q(inscription_periodes__groupe__isnull=True)|Q(decision_jury='X'))
        if data['conges'] :
            inscription_list=formation_.inscriptions_pour_deliberations()
        else :
            inscription_list=formation_.inscriptions_pour_deliberations_sans_conges()
        inscrits_list=[]
        for inscrit in inscription_list:
            #annoter chaque inscrit de sa moyenne
            item={}
            item['id']=inscrit.id
            item['moy']=resultat_list[inscrit.etudiant.matricule+'_'+periode.code+'_moy']
            inscrits_list.append(item)
        #trier les inscrits selon la moyenne portant sur les matières choisies
        inscrits_list.sort(key=operator.itemgetter('moy'), reverse=True)
        #calculer la rang de chaque inscrit et l'annoter avec
        #extraire la liste des moyennes
        moyenne_list=[]
        for inscrit in inscrits_list:
            moyenne_list.append(inscrit['moy'])
        #reconstruire la liste des inscrits triée
        #calculer le rang au même temps
        sorted_inscription_list=[]
        rang_list={}
        for inscrit in inscrits_list:
            rang_list[inscrit['moy']]=moyenne_list.index(inscrit['moy'])+1
            sorted_inscription_list.append(inscription_list.get(id=inscrit['id']))
        context['rang_list']=rang_list
        if data['sort']==True :
            context['inscription_list']=sorted_inscription_list
        else:
            if data['conges'] :
                context['inscription_list']=formation_.inscriptions_pour_deliberations().order_by('groupe__code', 'etudiant__nom', 'etudiant__prenom')
            else :
                context['inscription_list']=formation_.inscriptions_pour_deliberations_sans_conges().order_by('groupe__code', 'etudiant__nom', 'etudiant__prenom')
        context['formation'] = formation_
        context['date'] = datetime.date.today()
        context['photo'] = 1 if data['photo']==True else 0
        context['anonyme'] = 1 if data['anonyme']==True else 0
        context['ne'] = 1 if data['ne']==True else 0
        context['rang'] = 1 if data['rang']==True else 0
        context['signatures'] = 1 if data['signatures']==True else 0
        context['periode_code'] = periode.code
        context['periode_list'] = periode_list
        context['matieres_affichage']={}
        for periode_ in formation_.programme.periodes.all():
            context['matieres_affichage'][periode_.periode.code] = data['matieres_affichage_'+periode_.periode.code]
        context['matieres_moyenne'] = matieres_moyenne
        context['institution'] = user.institution()
        context['absence_periode_chart']= AbsenceFormationPeriodeChart(formation_.id, periode.id)
        context['resultat_chart'] = ResultatChart(moyenne_list)
        context['decisions_jury']=dict(DECISIONS_JURY)
        context['affichage_decisions_jury']=1 if data['affichage_decisions_jury'] else 0

        
        pv, created=PV.objects.update_or_create(formation=formation_, annuel=False, periode=periode, tri_rang=data['sort'], anonyme=data['anonyme'],
                                    photo=data['photo'], note_eliminatoire=data['ne'], rang=data['rang'], signature=data['signatures'], defaults={
                                        'date':datetime.date.today(),
                                        'formation':formation_, 
                                        'annuel':False, 
                                        'periode':periode, 
                                        'tri_rang':data['sort'], 
                                        'anonyme':data['anonyme'],
                                        'photo':data['photo'], 
                                        'note_eliminatoire':data['ne'], 
                                        'rang':data['rang'], 
                                        'signature':data['signatures'],
                                        'content': loader.render_to_string('scolar/deliberation_provisoire_pdf.html', context)
                                        })
        
        if data['xlsx'] or data['xlsxemail']:
            inscription_list=context['inscription_list']
    
            sheet=Dataset()
            sheet.headers = header
    
            for inscrit_ in inscription_list :
                row_=[]
                row_.append(inscrit_.etudiant.matricule)
                row_.append(inscrit_.etudiant.nom)
                row_.append(inscrit_.etudiant.prenom)
                if data['affichage_decisions_jury'] :
                    row_.append(dict(DECISIONS_JURY).get(inscrit_.decision_jury))
    
                for key_, periode_ in periode_list.items():
                    inscription_periode_= inscrit_.inscription_periodes.get(periodepgm=periode_['periode'])
                    row_.append(inscription_periode_.groupe.code)
                    
                    for matiere_ in periode_['matieres']:
                        if matiere_.code in data['matieres_affichage_'+periode_['periode'].periode.code]:
                            resultat_=None
                            try:
                                resultat_=Resultat.objects.get(ancien_resultat__isnull=True, inscription=inscrit_, module__matiere__code=matiere_.code)
                                row_.append(resultat_.moy)
                            except Exception:
                                row_.append('')
                    if periode_['periode'].periode == periode:
                        row_.append(resultat_list[inscrit_.etudiant.matricule+'_'+periode.code+'_ne'])
                        row_.append(rang_list[resultat_list[inscrit_.etudiant.matricule+'_'+periode.code+'_moy']])
                        row_.append(resultat_list[inscrit_.etudiant.matricule+'_'+periode.code+'_moy'])
    
                sheet.append(row_)
                
            filename="PV_"+str(formation_)+'_'+periode.code+'.xlsx'
            filename=filename.replace(' ','_')
            if data['xlsx'] :
                random_string=''.join(random.choices(string.ascii_uppercase + string.digits, k=10))
                filename_saved = "PV_"+str(formation_)+'_'+periode.code
                filename_saved=filename_saved.replace(' ','_')
                filename_saved=filename_saved+'_'+random_string
                filename_saved=filename_saved+'.xlsx'
                pv.xlsx.save(filename_saved, io.BytesIO(sheet.xlsx))           
                
            if data['xlsxemail'] :
                if activation_emails():
                    email = EmailMessage('[Talents] Génération du PV de '+str(formation_)+'_'+periode.code,
                                         'Bonjour,\n'+ 
                                         'La génération du PV de délibération de '+str(formation_)+'_'+periode.code+' est terminée \n'+
                                         'Veuillez trouver ci-joint le PV au format Excel\n'+
                                         'Bien cordialement.\n'+
                                         signature_emails(), to=[user.get_email(), formation_.programme.get_email_responsable_autorite_cycle() ])
                    email.attach(filename, sheet.xlsx, 'application/vnd.ms-excel' )
                    email.send(fail_silently=True)
         
    except Exception as e:
        trace_create(user, user, 'Une erreur s\'est produite lors de la génération de la formation '+str(formation_))
        if settings.DEBUG:
            raise Exception
        else:
            if activation_emails():
                email = EmailMessage('[Talents] Erreur lors de la génération du PV de  la formation '+str(formation_),
                                     'Bonjour,\n'+ 
                                     'Une erreur s\'est produite lors de la génération de la formation '+str(formation_)+'\n'+
                                     'Veuillez vérifier les notes et réessayer \n'+
                                     'Bien cordialement.\n'+
                                     signature_emails()+'\n'+
                                     str(e), to=[user.get_email()] )
                email.send(fail_silently=True)
    else:
        print('[Talents] Confirmation de la génération du PV de la formation ')
        trace_create(user, user, "Génération du PV de délibération : "+str(pv))
        if activation_emails():
            email = EmailMessage('[Talents] Confirmation de la génération du PV de la formation '+str(formation_),
                                 'Bonjour,\n'+ 
                                 'La génération du PV de délibération de '+str(formation_)+' est terminée \n'+
                                 'Nous vous en remercions \n'+
                                 'Bien cordialement.\n'+
                                 signature_emails(), to=[user.get_email()] )
            email.send(fail_silently=True)
 
@transaction.atomic
def import_moyennes_periode_view(request, formation_pk, periode_pk):
    if not request.user.has_perm('scolar.fonctionnalitenav_pedagogie_generationpvsdeliberation'):
        messages.error(request,"Vous n'avez pas les permissions pour accéder à cette vue.")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    # if this is a POST request we need to process the form data
    formation_=Formation.objects.get(id=formation_pk)
    periode_=Periode.objects.get(id=periode_pk)
    periodepgm_=PeriodeProgramme.objects.get(programme=formation_.programme, periode=periode_)
    
    # if this is a POST request we need to process the form data
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = ImportFileForm(request.POST, request.FILES)
        # check whether it's valid:
        if form.is_valid():
            try:    
                moyennes_file = request.FILES['file']
                dataset = Dataset()
                imported_data = dataset.load(moyennes_file.read(), format ='xlsx')
                # la première ligne du fichier doit contenir des entêtes, au moins Matricule, Enseignant
                # update Etudiant with tuteur
                for row in imported_data.dict :
                    if not row.get('Matricule') :
                        raise Exception('Matricule obligatoire')
                    etudiant_=Etudiant.objects.get(matricule=str(row.get('Matricule')).strip())
                    inscription_periode=InscriptionPeriode.objects.get(inscription__etudiant=etudiant_, inscription__formation=formation_, periodepgm=periodepgm_)
                    moy=row.get('Moy')
                    if moy:
                        moy=decimal.Decimal(str(moy).replace(",","."))
                        inscription_periode.moy_importee=moy
                        inscription_periode.is_moy_importee=True
                        inscription_periode.save()
                    moy_post_delib=row.get('RACMoy')     
                    if moy_post_delib:
                        moy_post_delib_importee_=decimal.Decimal(str(moy_post_delib).replace(",","."))                       
                        inscription_periode.moy_post_delib_importee=moy_post_delib_importee_                                                                               
                        inscription_periode.save()                            
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: L'importation des moyennes s'est terminée avec des erreurs." )
                    messages.info(request, "Indiquer le fichier .xlsx des moyennes à importer pour la période (semestre, ..)")
                    messages.info(request, "La première ligne du fichier doit comporter au moins les colonnes suivantes: Matricule, Moy, et éventuellement RACMoy pour la moyenne de rachat")
                    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer des moyennes d\'une période'})
            messages.success(request, "L'importation des moyennes pour la période a été réalisée avec succès!")
            # redirect to a new URL:
            return HttpResponseRedirect(reverse('deliberation_detail', kwargs={'formation_pk':formation_pk, }))
    # if a GET (or any other method) we'll create a blank form
    else:
        form = ImportFileForm()
        messages.info(request, "Indiquer le fichier .xlsx des moyennes à importer pour la période (semestre, ..)")
        messages.info(request, "La première ligne du fichier doit comporter au moins les colonnes suivantes: Matricule, Moy, et éventuellement RACMoy pour la moyenne de rachat")    
    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer des moyennes d\'une période'})


class PVDetailView(LoginRequiredMixin, UserPassesTestMixin, DetailView):
    template_name = 'scolar/pv_detail.html'
    model = PV

    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalitenav_pedagogie_visualisationpvsdeliberation')     
    
@login_required
def entree_rattrapage_view(request, formation_pk):
    if not request.user.has_perm('scolar.fonctionnalitenav_pedagogie_generationpvsdeliberation'):
        return redirect('/accounts/login/?next=%s' % request.path)

    try:
        formation_=get_object_or_404(Formation, id=formation_pk)
        # submit as background task
        formation_.marquer_entree_rattrapage_resultats()
        messages.success(request, "Les étudiants devant passer le rattrapage ont bien été marqués dans le rattrapage des modules concernés")         
        # redirect to a new URL:
    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            messages.error(request, "ERREUR: une erreur s'est produite lors de l'opération.")
    return HttpResponseRedirect(reverse('deliberation_detail', kwargs={'formation_pk':formation_pk, }))


@login_required
def entree_rattrapage_confirmation(request, formation_pk):
    
    context={}
    context['info']="Les étudiants avec une proposition de décision de jury qui est à 'Doit passer le rattrapage'(proposition issue du dernier PV de délibération qui n'est pas encore confirmée) seront automatiquement marqués comme devant passer le rattrapage des modules où ils ont moins de la moyenne seuil du rattrapage pour chaque module. La moyenne seuil du rattrapage peut être paramétrée via une autre page."
    context['lien']=reverse('entree_rattrapage', kwargs={'formation_pk': formation_pk}) 
    return render(request, 'scolar/confirmation.html', context)


@login_required
def deliberation_calcul_view(request, formation_pk):
    if not request.user.has_perm('scolar.fonctionnalitenav_pedagogie_generationpvsdeliberation'):
        return redirect('/accounts/login/?next=%s' % request.path)

    try:
        formation_=get_object_or_404(Formation, id=formation_pk)
        # submit as background task
        t = threading.Thread(target=task_deliberation_calcul, args=[formation_, request.user])
        t.setDaemon(True)
        t.start()
        messages.success(request, "Votre demande de calcul des moyennes et rangs est prise en compte. Une notification vous sera transmise aussitôt terminée.")         
        # redirect to a new URL:
    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            messages.error(request, "ERREUR: une erreur s'est produite lors de la demande de calcul des moyennes et rangs. Merci de le signaler à l'administrateur.")
    return HttpResponseRedirect(reverse('deliberation_detail', kwargs={'formation_pk':formation_pk, }))

@login_required
def deliberation_calcul_confirmation(request, formation_pk):
    
    formation_=get_object_or_404(Formation, id=formation_pk)
    context={}
    context['info']="Cette action permettra de calculer les moyennes, rangs et de proposer des décisions de jury qui seront affichés au prochain PV de délibération généré. "
    if formation_.activation_rattrapage() :
        context['info']=context['info']+"La proposition du jury pour les étudiants ayant au moins un module à rattraper sera 'Doit passer le rattrapage' (Les étudiants concernés sont ceux dont la moyenne annuelle est < 10 et qui ont pour certains modules des moyennes inférieures aux moyennes seuil de rattrapge paramétrées pour les modules). Ces propositions de décisions pourront être modifiées plus tard manuellement pour chaque inscription à travers le PV qui sera généré via une autre option."
    context['lien']=reverse('deliberation_calcul', kwargs={'formation_pk': formation_pk}) 
    return render(request, 'scolar/confirmation.html', context)

@transaction.atomic
def task_deliberation_calcul(formation_, user):
    try:    
        for inscription_ in formation_.inscriptions_pour_deliberations():
            # màj moyenne et rang de chaque période
            for periode_ in inscription_.inscription_periodes.all():
                periode_.moy = periode_.moyenne()
                #periode_.moy_post_delib = periode_.moyenne_post_delib() 
                periode_.ne = periode_.nb_ne()
                #periode_.save(update_fields=['ne', 'moy', 'moy_post_delib'])
                periode_.save(update_fields=['ne', 'moy'])
                for ue_ in periode_.resultat_ues.all():
                    ue_.moy=ue_.moyenne()
                    ue_.save(update_fields=['moy'])
        for inscription_ in formation_.inscriptions_pour_deliberations():
            for periode_ in inscription_.inscription_periodes.all():
                periode_.rang = periode_.ranking()
                periode_.save(update_fields=['rang'])
                
                # màj ECTS pour chaque résultat et indiquer modules acquis
                for ue_ in periode_.resultat_ues.all():
                    for resultat_ in ue_.resultat_matieres.all():
                        resultat_.ects=resultat_.calcul_ects()
                        
                        resultat_.save(update_fields=['ects'])
                        
            inscription_.reset_moy()
            inscription_.reset_moy_ra()
            inscription_.moy=inscription_.moyenne()
            inscription_.moy_ra=inscription_.moyenne_post_delib()
            #inscription_.moy_post_delib=inscription_.moyenne_post_delib()
            # faire une proposition automatique de la décision selon la moyenne et décision actuelle (abandon, maladie ou encours
                       
            if (inscription_.proposition_decision_jury =='X') or (inscription_.proposition_decision_jury =='C') :
                if inscription_.moy>=formation_.moyenne_passage and inscription_.nb_ne()==0 :
                    if formation_.programme.concours:
                        inscription_.proposition_decision_jury='AC'
                    else:
                        inscription_.proposition_decision_jury='A'
                else:
                    if formation_.activation_rattrapage() and inscription_.nb_modules_a_rattraper()>0 and ((inscription_.decision_jury =='C') or (inscription_.decision_jury =='DR'))  :
                        inscription_.proposition_decision_jury = 'DR'
                    # else :
                    #     inscription_.proposition_decision_jury=inscription_.decision_jury
                    
                    elif formation_.activation_rattrapage() and (inscription_.decision_jury =='C') and (inscription_.moy<formation_.moyenne_passage):
                        inscription_.proposition_decision_jury = 'AJ'                        
                    else : 
                        inscription_.proposition_decision_jury=inscription_.decision_jury   

            inscription_.save(update_fields=['moy', 'moy_ra', 'proposition_decision_jury'])
        for inscription_ in formation_.inscriptions_pour_deliberations():
            inscription_.rang=inscription_.ranking()
            inscription_.save(update_fields=['rang'])
    except Exception as e:
        trace_create(user, user,'Une erreur s\'est produite lors du calcul la moyenne et rang de: '+str(inscription_))        
        if settings.DEBUG:
            raise Exception
        else:
            if activation_emails():
                email = EmailMessage('[Talents] Erreur lors du calcul des moyennes et rangs de la formation '+str(formation_),
                                     'Bonjour,\n'+ 
                                     'Une erreur s\'est produite lors du calcul la moyenne et rang de: '+str(inscription_)+'\n'+
                                     'Bien cordialement.\n'+
                                     signature_emails()+'\n'+
                                     str(e), to=[user.get_email()] )
                email.send(fail_silently=True)
    else:
        trace_create(user, user, 'Le calcul du PV de délibération de '+str(formation_)+' est terminée')
        if activation_emails():
            email = EmailMessage('[Talents] Confirmation de calcul du PV de délibération de la formation '+str(formation_),
                             'Bonjour,\n'+ 
                             'Le calcul du PV de délibération de '+str(formation_)+' est terminée \n'+
                             'Nous vous en remercions \n'+
                             'Bien cordialement.\n'+
                             signature_emails(), to=[user.get_email()] )
            email.send(fail_silently=True)
    

@login_required
def deliberation_rattrapage_calcul_view(request, formation_pk):
    try:
        formation_=get_object_or_404(Formation, id=formation_pk)
        if (not request.user.has_perm('scolar.fonctionnalitenav_pedagogie_generationpvsdeliberation')) or not formation_.activation_rattrapage():
            return redirect('/accounts/login/?next=%s' % request.path)

        # submit as background task
        t = threading.Thread(target=task_deliberation_rattrapage_calcul, args=[formation_, request.user])
        t.setDaemon(True)
        t.start()
        messages.success(request, "Votre demande de calcul des propositions de décisions de jury (session de rattrapage) est prise en compte. Une notification vous sera transmise aussitôt terminée.")         
        # redirect to a new URL:
    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            messages.error(request, "ERREUR: une erreur s'est produite lors de la demande de calcul des propositions de décision post-rattrapage. Merci de le signaler à l'administrateur.")
    return HttpResponseRedirect(reverse('deliberation_detail', kwargs={'formation_pk':formation_pk, }))

@login_required
def deliberation_rattrapage_calcul_confirmation(request, formation_pk):
    
    context={}
    context['info']="Cette action permettra de calculer des propositions de jury post-rattrapage qui seront affichés au prochain PV de délibération généré. Les étudiants ayant réussi le rattrapage auront comme proposition de décision 'Admis avec rattrapage'"
    context['lien']=reverse('deliberation_rattrapage_calcul', kwargs={'formation_pk': formation_pk}) 
    return render(request, 'scolar/confirmation.html', context)

@transaction.atomic
def task_deliberation_rattrapage_calcul(formation_, user):
    try:    
        for inscription_ in formation_.inscriptions_pour_deliberations():
            if (inscription_.proposition_decision_jury =='DR'):
                inscription_.reset_moy()
                inscription_.moy = inscription_.moyenne_finale()
                if inscription_.moyenne_finale()>=formation_.moyenne_passage :
                    inscription_.proposition_decision_jury='SR' #Admis à la Session de Rattrapage
                else :
                    inscription_.proposition_decision_jury='C' #Laisser a l'appreciation du jury
                inscription_.save(update_fields=['moy', 'proposition_decision_jury'])
            
    except Exception as e:
        trace_create(user, user, 'Une erreur s\'est produite lors du calcul des propositions de jury post-rattrapage de la formation '+str(formation_))
        if settings.DEBUG:
            raise Exception
        else:
            if activation_emails():
                email = EmailMessage('[Talents] Erreur lors du calcul des propositions de jury post-rattrapage de la formation '+str(formation_),
                                     'Bonjour,\n'+ 
                                     'Une erreur s\'est produite lors du calcul des propositions de jury post-rattrapage de la formation '+str(formation_)+'\n'+
                                     'Bien cordialement.\n'+
                                     signature_emails()+'\n'+
                                     str(e), to=[user.get_email()] )
                email.send(fail_silently=True)
    else:
        trace_create(user, user, 'Le calcul du PV de délibération de '+str(formation_)+' est terminée')
        if activation_emails():
            email = EmailMessage('[Talents] Confirmation de calcul du PV de délibération (session de rattrapage) de la formation '+str(formation_),
                                 'Bonjour,\n'+ 
                                 'Le calcul du PV de délibération de '+str(formation_)+' est terminée \n'+
                                 'Nous vous en remercions \n'+
                                 'Bien cordialement.\n'+
                                 signature_emails(), to=[user.get_email()] )
            email.send(fail_silently=True)
    


    
def note_eliminatoire_update_view(request, formation_pk):
    if not request.user.has_perm('scolar.fonctionnalitenav_pedagogie_generationpvsdeliberation'):
        return redirect('/accounts/login/?next=%s' % request.path)
    
    # if this is a POST request we need to process the form data
    formation_=Formation.objects.get(id=formation_pk)
    module_list=Module.objects.filter(formation=formation_)
    
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = SelectModuleForm(formation_pk, request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:
                data=form.cleaned_data
                
                for periode_ in formation_.programme.periodes.all():
                    module_list_=Module.objects.filter(formation=formation_, periode=periode_)
                    for module_ in module_list_:
                        if data['select_module_'+str(module_.id)]:
                            module_.note_eliminatoire=data['calcul_ne_'+str(module_.id)]  
                            module_.save(update_fields=['note_eliminatoire'])  
            except Exception:
                if settings.DEBUG:
                    raise Exception("Erreur lors de la mise à jour des notes élimibatoire")
                else:
                    messages.error(request, "ERREUR: les notes éliminatoires n'ont pu être mises à jours à cause d'erreurs lors du calcul.")
                    return HttpResponseRedirect(reverse('deliberation_detail', kwargs={'formation_pk':formation_pk, }))
            # redirect to a new URL:
            messages.success(request, "Les notes élimibatoires ont été enregistrées avec succès!")
            messages.info(request, "Vous pouvez lancer le calcul du PV de délibérations.")
            return render(request, 'scolar/note_eliminatoire_update.html', {'form': form, 'module_list':module_list, 'formation':formation_}) 
    # if a GET (or any other method) we'll create a blank form
    else:
        form = SelectModuleForm(formation_pk)
        messages.info(request, "Cochez les modules pour lesquels vous voulez enregistrer la note éliminatoire")
    return render(request, 'scolar/note_eliminatoire_update.html', {'form': form, 'module_list':module_list, 'formation':formation_})


class NotesEliminatoiresPVPDFView(LoginRequiredMixin, UserPassesTestMixin, PDFTemplateView):
    template_name = 'scolar/notes_eliminatoires_pv_pdf.html'
    cmd_options={
        'orientation':'Landscape',
        'page-size':'A4',
        }
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalitenav_pedagogie_visualisationpvsdeliberation')
    
    def get_context_data(self, **kwargs):
        context = super(NotesEliminatoiresPVPDFView, self).get_context_data(**kwargs)
        formation_=Formation.objects.get(id=self.kwargs.get('formation_pk'))
        periode_=PeriodeProgramme.objects.get(id=self.kwargs.get('periode_pk'))
        self.filename='PV_NOTES_ELIMINATOIRES_'+str(formation_)+'_'+periode_.periode.code+'.pdf'
        ue_list = []
        for ue in periode_.ues.filter(nature='OBL'):
            ue_list.append(ue)
        for groupe_ in Groupe.objects.filter(section__formation=formation_):
            for ue in groupe_.option.filter(periode=periode_):
                ue_list.append(ue)
        module_list={}
        for module_ in Module.objects.filter(formation=formation_, periode=periode_):
            if not module_.matiere.code in module_list.keys():
                module_list[module_.matiere.code]=module_
        context['formation'] = formation_
        context['periode'] = periode_
        context['ue_list'] = ue_list
        context['module_list'] = module_list
        context['date'] = datetime.date.today()
        return context


class NotesEliminatoiresPVProvisoirePDFView(NotesEliminatoiresPVPDFView):
    template_name = 'scolar/notes_eliminatoires_pv_provisoire_pdf.html'


class FeedbackModuleView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):

    template_name = 'scolar/feedback_module.html'
    
    def test_func(self):
        if self.request.user.has_perm('scolar.fonctionnalitenav_pedagogie_visualisationfeedbacks'):
            return True
        elif self.request.user.is_enseignant():
            module_=get_object_or_404(Module, id=self.kwargs.get('module_pk'))
            return assure_module(self.request.user.enseignant, module_)
        else:
            return False
        
    def get_context_data(self, **kwargs):
        context = super(FeedbackModuleView, self).get_context_data(**kwargs)
        module_pk_=self.kwargs.get('module_pk')
        module_=get_object_or_404(Module, id=module_pk_)
        feedback_list=Feedback.objects.filter(module=module_, show=True)
        feedback_chart_=FeedbackChart(module_pk=module_pk_)
        question_list=Question.objects.all().order_by('code')
        context['feedback_chart'] = feedback_chart_
        context['module']=module_
        if self.test_func():
            context['feedback_list']=feedback_list
        context['question_list']=question_list
        try:
            context['nb_reponses']=Reponse.objects.filter(feedback__module=module_).exclude(reponse='').distinct('feedback').count()
        except Exception:
            context['nb_reponses']=Feedback.objects.filter(module=module_).count()
        context['nb_inscrits']=module_.formation.inscriptions_actives().count()
        
        if self.request.user.has_perm('scolar.fonctionnalite_pedagogie_visualisationcommentairesfeedbacks'):
            context['show_comments']=True
        elif self.request.user.is_enseignant():
            context['show_comments']=assure_module(self.request.user.enseignant, module_)
            
        return context


class FeedbackModulePDFView(LoginRequiredMixin, UserPassesTestMixin, PDFTemplateView):
     
    template_name = 'scolar/feedback_module_pdf.html'
    #cmd_options=settings.WKHTMLTOPDF_CMD_OPTIONS
    
    def test_func(self):
        if self.request.user.has_perm('scolar.fonctionnalite_pedagogie_visualisationcommentairesfeedbacks'):
            return True
        elif self.request.user.is_enseignant():
            module_=get_object_or_404(Module, id=self.kwargs.get('module_pk'))
            return assure_module(self.request.user.enseignant, module_ )
        else:
            return False
        

    def get_context_data(self, **kwargs):
        context = super(FeedbackModulePDFView, self).get_context_data(**kwargs)
        module_pk_=self.kwargs.get('module_pk')
        module_=get_object_or_404(Module, id=module_pk_)
        self.filename='feedback_'+str(module_)+'.pdf'
        feedback_list=Feedback.objects.filter(module=module_, show=True)
        feedback_chart_=FeedbackChart(module_pk=module_pk_)
        feedback_chart_.width=550
         
        question_list=Question.objects.all()
        context['feedback_chart'] = feedback_chart_
        context['module']=module_
        context['feedback_list']=feedback_list
        context['question_list']=question_list
        context['nb_reponses']=Feedback.objects.filter(module=module_).count()
        context['nb_inscrits']=module_.formation.inscriptions_actives().count()
 
        return context


class FeedbackListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    
    template_name = 'scolar/list.html'
    
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalitenav_pedagogie_visualisationfeedbacks')
    
    def get_queryset(self, **kwargs):
        return Feedback.objects.filter(module=self.kwargs.get('module_pk')).exclude(Q(comment='')|Q(comment__isnull=True))

    def get_context_data(self, **kwargs):
        context = super(FeedbackListView, self).get_context_data(**kwargs)
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalite_pedagogie_validationfeedbacks'):
            exclude_.append('edit')
            exclude_.append('admin')
        table = FeedbackTable(self.get_queryset(**kwargs), exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['table'] = table
        context['titre'] = 'Liste des feedback'
        context['btn_list']={
                'Retour':reverse('module_list')
            }
        return context

class FeedbackPeriodeView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    
    template_name = 'scolar/feedback_periode_detail.html'
    
    def test_func(self):
        if int(self.kwargs.get('with_comments'))==0:
            return self.request.user.has_perm('scolar.fonctionnalitenav_pedagogie_visualisationfeedbacks')
        else:
            return self.request.user.has_perm('scolar.fonctionnalite_pedagogie_visualisationcommentairesfeedbacks')
        
    def get_context_data(self, **kwargs):
        context = super(FeedbackPeriodeView, self).get_context_data(**kwargs)
        periode_=get_object_or_404(Periode, id=self.kwargs.get('periode_pk'))
        with_comments_=self.kwargs.get('with_comments')
        module_list=Module.objects.filter(periode__periode=periode_, formation__annee_univ__annee_univ=self.kwargs.get('annee_univ_pk'))
        programme_list=Programme.objects.exclude(code__startswith='3').exclude(matiere_equipe__isnull=False).exclude(fictif=True).order_by('ordre')
        question_list=Question.objects.all().order_by('code')
        chart_list={}
        feedback_list={}
         
        for module_ in module_list:
            chart_list[module_.id]=FeedbackChart(module_pk=module_.id)
            if with_comments_== '1' :
                feedback_list[module_.id]='<ul>'
                for feedback_ in Feedback.objects.filter(module=module_):
                    if feedback_.show and feedback_.comment :
                        feedback_list[module_.id]+='<li>'+feedback_.comment+'</li>'
                feedback_list[module_.id]+='</ul><br>'
        context['periode_'] = periode_
        context['module_list'] = module_list 
        context['programme_list'] = programme_list
        context['question_list'] = question_list
        context['chart_list']=chart_list
        context['feedback_list']=feedback_list
        context['annee_univ']=AnneeUniv.objects.get(annee_univ=self.kwargs.get('annee_univ_pk'))
        context['taux_reponse'] = {}
        for pgm in programme_list:
            try:
                nb_reponse=Reponse.objects.filter(feedback__module__formation__programme=pgm,
                                              feedback__module__formation__annee_univ__annee_univ=self.kwargs.get('annee_univ_pk'),
                                              feedback__module__periode__periode=self.kwargs.get('periode_pk')
                                              ).exclude(reponse='').distinct('feedback__inscription').count()
            except Exception:
                nb_reponse=Reponse.objects.filter(feedback__module__formation__programme=pgm,
                                              feedback__module__formation__annee_univ__annee_univ=self.kwargs.get('annee_univ_pk'),
                                              feedback__module__periode__periode=self.kwargs.get('periode_pk')
                                              ).exclude(reponse='').distinct().count()
            context['taux_reponse'][pgm.code]=(
                    nb_reponse,
                    Inscription.objects.filter(formation__programme=pgm, formation__annee_univ__annee_univ=self.kwargs.get('annee_univ_pk')).exclude(decision_jury='X').exclude(decision_jury__startswith='M').exclude(decision_jury__startswith='F').exclude(inscription_periodes__groupe__isnull=True).count()
                )

        return context
    

class FeedbackUpdateView(LoginRequiredMixin,SuccessMessageMixin, UserPassesTestMixin, UpdateView):

    model = Feedback
    fields = ['comment', 'show']
    template_name = 'scolar/update.html'
    success_message = "Le feedback a été modifié avec succès!"
    
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalite_pedagogie_validationfeedbacks')
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-warning'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('feedback_list', kwargs={'module_pk':self.kwargs.get('module_pk')})
        return form

@login_required
def feedback_etudiant_update_view(request, inscription_pk, periode_pk):
    #attention il faut évaluer les modules suivis au niveau des activités qui peuvent être différents des modules
    # prévus dans la programmation, par exemple un groupe SQ peut suivre un module TPRO des SL, mais dans son programme on prévoit un autre module TPRO des SQ
    inscription_=get_object_or_404(Inscription, id=inscription_pk)
    #vérifier que l'étudiant connecté est concerné par cette inscription
    if not request.user.is_etudiant():
        messages.error(request, "ERREUR: vous n'avez pas accès à cette opération !")
        return redirect('/accounts/login/?next=%s' % request.path)
    elif not inscription_ in request.user.etudiant.inscriptions_encours():
        messages.error(request, "ERREUR: vous n'avez pas accès à cette opération !")
        return redirect('/accounts/login/?next=%s' % request.path)
        
    periodepgm_=PeriodeProgramme.objects.get(id=periode_pk)
    inscription_periode_=InscriptionPeriode.objects.get(inscription=inscription_, periodepgm=periode_pk)
    # TODO les questions ne sont pas adaptées au PFE, faut donc l'exclure et prévoir d'autres questions dans une maj
    if inscription_periode_.groupe:
        groupe_section=inscription_periode_.groupe.section.groupes.all().filter(code__isnull=True).get() # le groupe qui représente la section
        activites_suivies_list=Activite.objects.filter(cible__in=[inscription_periode_.groupe, groupe_section], module__periode__periode=periodepgm_.periode, module__matiere__pfe=False)
    else:
        activites_suivies_list=[]
    module_list=[]
    module_traite_list=[]
    for activite_suivie in activites_suivies_list:
        if not activite_suivie.module.id in module_traite_list:
            module_traite_list.append(activite_suivie.module.id) 
            if activite_suivie.module.matiere.mode_projet:
                question_list=Question.objects.exclude(projet_na=True).order_by('code')
            else:
                question_list=Question.objects.exclude(cours_na=True).order_by('code')
            module_list.append({
                'module':activite_suivie.module,
                'question_list':question_list
            })
    
    # if this is a POST request we need to process the form data

    if request.method == 'POST':
        # create a form instance and populate it with data from the request:

        form = FeedbackUpdateForm(inscription_pk, periode_pk, request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:
                data=form.cleaned_data
                
                for module_info in module_list:
                    feedback_, created=Feedback.objects.update_or_create(module=module_info['module'], inscription=inscription_, defaults={
                        'module':module_info['module'],
                        'inscription':inscription_,
                        'comment':data[str(module_info['module'].id)],
                        'show':False
                    })
    
                    for question_ in module_info['question_list']:
                        reponse_, created=Reponse.objects.update_or_create(feedback=feedback_, question=question_, defaults={
                            'feedback':feedback_,
                            'question':question_,
                            'reponse':data[str(module_info['module'].id)+'_'+question_.code]
                        })
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: L'introduction de votre avis s'est terminé avec des erreurs. Merci de le signaler à l'administrateur")
                    return HttpResponseRedirect(reverse('etudiant_activite'))
            messages.success(request, "Nous vous remercions. Votre avis sera pris en compte et transféré aux équipes pédagogiques")
            # redirect to a new URL:
            return HttpResponseRedirect(reverse('etudiant_activite')) 
        else:
            messages.error(request,'Votre formulaire contient des erreures. Merci de vérifier que vous avez bien remplis tous les onglets de ce formulaire.')
    # if a GET (or any other method) we'll create a blank form
    else:
        form = FeedbackUpdateForm(inscription_pk, periode_pk)
        messages.error(request,"Merci de renseigner le formulaire pour chacun des modules. Autrement l'évaluation ne sera pas enregistrée!")
    return render(request, 'scolar/feedback_update_form.html', {'form': form, 'module_list':module_list})

class ModuleListView(LoginRequiredMixin, PermissionRequiredMixin, TemplateView):

    template_name = 'scolar/module_list.html'
    permission_required='scolar.fonctionnalitenav_pedagogie_visualisationfeedbacks'
    
    def get_queryset(self, **kwargs):
        return Module.objects.filter(groupes_suivis__groupe__section__formation__programme__matiere_equipe__isnull=True, groupes_suivis__groupe__section__formation__programme__fictif=False).distinct()

    def get_context_data(self, **kwargs):
        context = super(ModuleListView, self).get_context_data(**kwargs)
        periode_list=Periode.objects.all().order_by('ordre')
        annee_univ_list=AnneeUniv.objects.all().order_by('annee_univ')
        filter_ = ModuleFilter(self.request.GET, queryset=self.get_queryset(**kwargs))
        filter_.form.helper = FormHelper()
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalite_pedagogie_validationfeedbacks'):
            exclude_.append('edit')
            exclude_.append('admin')
        table = ModuleFeedbackTable(filter_.qs, exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['filter'] = filter_
        context['table'] = table
        context['periode_list']=periode_list
        context['annee_univ_list']=annee_univ_list
        return context

class ModuleCopyView(LoginRequiredMixin, PermissionRequiredMixin, CreateView):

    model = Module
    fields = ['matiere', 'formation', 'coordinateur', 'periode']
    template_name = 'scolar/create.html'
    permission_required='scolar.fonctionnalitenav_planification_activites'
      
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        module_=get_object_or_404(Module, id=self.kwargs.get('module_pk'))
        form.fields['matiere']=forms.ModelChoiceField(queryset=Matiere.objects.filter(code=module_.matiere.code), initial=0)
        form.fields['formation']=forms.ModelChoiceField(queryset=Formation.objects.filter(id=module_.formation.id), initial=0)
        form.fields['periode']=forms.ModelChoiceField(queryset=PeriodeProgramme.objects.filter(programme=module_.formation.programme.id), initial=0)
        form.helper.add_input(Submit('submit','Créer', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('planification_update', kwargs={'formation_pk':module_.formation.id, 'periode_pk':module_.periode.id})
        return form
    
class ModuleCreateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, CreateView):
    model = Module
    fields = ['matiere', 'formation', 'coordinateur', 'periode']
    template_name = 'scolar/create.html'
    permission_required = 'scolar.fonctionnalitenav_planification_activites'
    success_message = "Le module a bien été créé."
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        formation_=get_object_or_404(Formation, id=self.kwargs.get('formation_pk'))
        periode_=get_object_or_404(PeriodeProgramme, id=self.kwargs.get('periode_pk'))
        matieres_formation=Module.objects.filter(formation=formation_).values('matiere')
        form.fields['formation']=forms.ModelChoiceField(queryset=Formation.objects.filter(id=formation_.id), initial=0)
        form.fields['periode']=forms.ModelChoiceField(queryset=PeriodeProgramme.objects.filter(id=periode_.id), initial=0)
        #form.fields['matiere']=forms.ModelChoiceField(queryset=Matiere.objects.filter(id__in=matieres_formation).order_by('code'))
        form.fields['matiere']=forms.ModelChoiceField(queryset=Matiere.objects.filter(matiere_ues__periode__programme=formation_.programme).order_by('code').distinct())
        form.helper.add_input(Submit('submit','Créer', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('planification_update', kwargs={'formation_pk':formation_.id, 'periode_pk':periode_.id})
        return form


def module_evaluation_copy_view(request, module_pk):
    if not request.user.has_perm('scolar.fonctionnalite_pedagogie_gestioncoordination'):
        return redirect('/accounts/login/?next=%s' % request.path)

    # if this is a POST request we need to process the form data
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = SelectSingleModuleForm(request.POST)
        
        # check whether it's valid:
        if form.is_valid():
            try:
                dst_module_=Module.objects.get(id=module_pk)
                form_data=form.cleaned_data
                src_module_=form_data['module']
                dst_module_.ponderation_moy=src_module_.ponderation_moy
                dst_module_.ponderation_moy_rattrapage=src_module_.ponderation_moy_rattrapage
                dst_module_.activation_max_moy_normale_et_rattrapage=src_module_.activation_max_moy_normale_et_rattrapage
                dst_module_.save(update_fields=['ponderation_moy','ponderation_moy_rattrapage', 'activation_max_moy_normale_et_rattrapage' ])
                for src_eval_ in src_module_.evaluations.all():
                    dst_eval_=Evaluation.objects.create(
                        module=dst_module_,
                        ponderation=src_eval_.ponderation,
                        ponderation_rattrapage=src_eval_.ponderation_rattrapage,
                        type=src_eval_.type
                        )                       
   
                    for src_eval_competence_ in src_eval_.competence_elements.all():
                        dst_eval_competence_=EvaluationCompetenceElement.objects.create(
                            evaluation=dst_eval_,
                            competence_element=src_eval_competence_.competence_element,
                            ponderation=src_eval_competence_.ponderation,
                            commune_au_groupe=src_eval_competence_.commune_au_groupe
                            )

                    #il n'y a qu'un seul objet CompetenceEvalConfig pour chaque itération, qui peut exister ou non donc on peut exploiter la boucle "for" qui traite les deux cas
                    for src_competence_eval_config_ in CompetenceEvalConfig.objects.filter(evaluation=src_eval_) :
                        CompetenceEvalConfig.objects.create(
                            evaluation=dst_eval_,
                            A=src_competence_eval_config_.A,
                            B=src_competence_eval_config_.B,
                            C=src_competence_eval_config_.C,
                            D=src_competence_eval_config_.D,
                            E=src_competence_eval_config_.E,
                            F=src_competence_eval_config_.F
                            )
                        
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: La copie de la fiche d'évaluation n'a pas réussit.")
                    return render(request, 'scolar/import.html', {'form': form, 'titre':'Sélectionner un Module'})
            messages.success(request, "La copie de la fiche d'évaluation s'est faite avec succès!")
            # redirect to a new URL:
            return HttpResponseRedirect(reverse('module_detail', kwargs={'pk':module_pk})) 
    # if a GET (or any other method) we'll create a blank form
    else:
        form = SelectSingleModuleForm()
        messages.info(request, "Indiquez le module à partir duquel vous voulez copier la fiche d'évaluation.")
    return render(request, 'scolar/import.html', {'form': form, 'titre':'Sélectionner un Module'})

class ModuleUpdateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, UpdateView):

    model = Module
    fields = ['coordinateur', 'periode', 'matiere']
    template_name = 'scolar/update.html'
    permission_required = 'scolar.fonctionnalitenav_planification_activites'
    success_message = "Le module a bien été modifié."
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.fields['coordinateur']=forms.ModelChoiceField(queryset=Enseignant.objects.all().order_by('nom', 'prenom'), required=False)
        form.fields['matiere']=forms.ModelChoiceField(queryset=Matiere.objects.all().order_by('code'))
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-warning'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('planification_update', kwargs={'formation_pk':self.kwargs.get('formation_pk'), 'periode_pk':self.kwargs.get('periode_pk')})
        return form

class ModuleDeleteView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, DeleteView):
    model = Module
    template_name = 'scolar/delete.html'
    permission_required='scolar.fonctionnalitenav_planification_activites'
    success_message = "Le module a bien été supprimé."

    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression du module : "+str(object_))
        return super(ModuleDeleteView, self).delete(*args, **kwargs)
        
    def get_success_url(self):
        return reverse('planification_update', kwargs={'formation_pk':self.kwargs.get('formation_pk'), 'periode_pk':self.kwargs.get('periode_pk')})

@receiver(pre_delete, sender=Module)
def update_resultat_module_delete(sender, instance, **kwargs):
    # si un module suivi porte sur la même matière, basculer les résultats sur ce module
    module_similaire_list=Module.objects.filter(formation=instance.formation, matiere__code=instance.matiere.code).exclude(id=instance.id)
    if module_similaire_list.exists():
        module_similaire=module_similaire_list[0]
        Resultat.objects.filter(ancien_resultat__isnull=True, module__matiere__code=instance.matiere.code, inscription__formation=instance.formation).update(
            module=module_similaire
        )
        ModulesSuivis.objects.filter(module__matiere__code=instance.matiere.code, module__formation=instance.formation).exclude(module=instance).update(
            module=module_similaire)


class ModulesSuivisUpdateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, UpdateView):

    model = ModulesSuivis
    fields = ['module', 'groupe']
    template_name = 'scolar/update.html'
    permission_required = 'scolar.fonctionnalitenav_planification_activites'    
    success_message = "La modification du déroulement du module pour ce groupe a bien été effectuée."
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-warning'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('planification_update', kwargs={'formation_pk':self.kwargs.get('formation_pk'), 'periode_pk':self.kwargs.get('periode_pk')})
        return form

class ModulesSuivisCreateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, CreateView):

    model = ModulesSuivis
    fields = ['module', 'groupe']
    template_name = 'scolar/create.html'
    permission_required = 'scolar.fonctionnalitenav_planification_activites'
    success_message = "L'affectation du module au groupe a bien été effectuée."
        
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        module_=get_object_or_404(Module, id=self.kwargs.get('module_pk'))
        groupe_=get_object_or_404(Groupe, id=self.kwargs.get('groupe_pk'))
        form.fields['module']=forms.ModelChoiceField(queryset=Module.objects.filter(id=module_.id), initial=0)
        form.fields['groupe']=forms.ModelChoiceField(queryset=Groupe.objects.filter(id=groupe_.id), initial=0)
        form.helper.add_input(Submit('submit','Créer', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('planification_update', kwargs={'formation_pk':module_.formation.id, 'periode_pk':module_.periode.id})
        return form

@receiver(post_save, sender=ModulesSuivis)
def update_resultat_module(sender, instance, created, **kwargs):
    Resultat.objects.filter(module__matiere=instance.module.matiere, resultat_ue__inscription_periode__groupe=instance.groupe).update(
            module=instance.module
        )
    
    
class ModulesSuivisDeleteView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, DeleteView):
    model = ModulesSuivis
    template_name = 'scolar/delete.html'
    permission_required='scolar.fonctionnalitenav_planification_activites'
    success_message = "Le module a bien été retiré au groupe."

    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression ModulesSuivis : "+str(object_))
        return super(ModulesSuivisDeleteView, self).delete(*args, **kwargs)
        
    def get_success_url(self):
        return reverse('planification_update', kwargs={'formation_pk':self.kwargs.get('formation_pk'), 'periode_pk':self.kwargs.get('periode_pk')})


@receiver(pre_delete, sender=ModulesSuivis)
def update_resultat_modulesuivis_delete(sender, instance, **kwargs):
    module_similaire_list=Module.objects.filter(formation=instance.module.formation, matiere__code=instance.module.matiere.code)
    if module_similaire_list.exists():
        module_similaire=module_similaire_list[0]
        Resultat.objects.filter(module__matiere=instance.module.matiere, resultat_ue__inscription_periode__groupe=instance.groupe).update(
            module=module_similaire
        )

class AbsenceChart(Chart):
    chart_type='bar'
    
    def __init__(self, etudiant_pk, periode_pk, *args, **kwargs):
        super(AbsenceChart, self).__init__(*args, **kwargs)
        self.labels=[]
        self.data=[]
        periode_= PeriodeProgramme.objects.get(id=periode_pk)
        self.titre="Nombre d'absences par matière : "+str(periode_.periode.code)
        try:
            inscription_etudiant=get_object_or_404(Inscription, etudiant=etudiant_pk, formation__annee_univ__encours=True, formation__programme = periode_.programme)
            groupe_etudiant=inscription_etudiant.groupe
            if groupe_etudiant :
                module_suivi_list=Resultat.objects.filter(ancien_resultat__isnull=True, inscription=inscription_etudiant, module__periode=periode_pk)
            
                absence_list=AbsenceEtudiant.objects.filter(etudiant=etudiant_pk, seance__activite__module__formation__annee_univ__encours=True, seance__activite__module__periode=periode_pk)
                absence_etudiant_list=absence_list.values('etudiant','seance__activite__module__matiere__code').annotate(nbr_abs=Count('seance__activite'))
                for absence in absence_etudiant_list:
                    self.labels.append(absence['seance__activite__module__matiere__code'])
                    self.data.append({'x':absence['seance__activite__module__matiere__code'], 'y':absence['nbr_abs']})
                for module_suivi in module_suivi_list:
                    if not module_suivi.module.matiere.code in self.labels :
                        self.labels.append(module_suivi.module.matiere.code)
                        self.data.append({'x':module_suivi.module.matiere.code,'y':0})
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: la génération du graphique des absences s'est terminée avec echec!")
        
    def get_labels(self, *args, **kwargs):
        return self.labels

    def get_datasets(self, **kwargs):
        return [DataSet(
                label = self.titre,
                data = self.data
                )]

class ProfileChart(Chart):
    chart_type='radar'
    options = {
        'scale': {
            'angleLines': {
                'display': True
            },
            'ticks': {
                'suggestedMin': 0,
                'suggestedMax': 20
            }
        }
    }

    def __init__(self, etudiant_pk, *args, **kwargs):
        super(ProfileChart, self).__init__(*args, **kwargs)
        self.labels=[]
        self.data=[]
        self.data_avg=[]
        self.titre="Profil par domaine de connaissance"
        try:
            #construction du profile: moyenne par domaine de connaissance
            etudiant_=Etudiant.objects.get(matricule=etudiant_pk)
            resultat_list=Resultat.objects.filter(ancien_resultat__isnull=True).filter(Q(inscription__etudiant=etudiant_)&(Q(inscription__decision_jury='A')|Q(inscription__decision_jury='AR')|Q(inscription__decision_jury='SR')|Q(inscription__decision_jury='AD')))
            ddc_moy_list=resultat_list.values('module__matiere__ddc__intitule').annotate(moy_ddc=Avg('moy'))
            
            for ddc_moy in ddc_moy_list :
                self.labels.append(ddc_moy['module__matiere__ddc__intitule'])
                self.data.append(round(ddc_moy['moy_ddc'],2))
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors dde la génération du graphique du profil.")
    
    def get_labels(self, *args, **kwargs):
        return self.labels

    def get_datasets(self, **kwargs):
        return [DataSet(
                label = self.titre,
                data = self.data
                )]

class EtudiantEffectifsChart(Chart):
    chart_type='bar'
    options= {
        'scales': {
            'xAxes': [{
                'stacked': True
            }],
            'yAxes': [{
                'stacked': True,
                'offset':True
            }]
        }
    }
    
    def __init__(self, ratio_, *args, **kwargs):
        super(EtudiantEffectifsChart, self).__init__(*args, **kwargs)
        self.labels=[]
        self.data=[]
        try:
            inscription_list=Inscription.objects.filter(formation__annee_univ__encours=True).exclude(Q(decision_jury='FT')|Q(decision_jury='X')).order_by('formation__programme__ordre')
            fille_count=Count('etudiant', filter=Q(etudiant__sexe='F'))
            garcon_count=Count('etudiant', filter=Q(etudiant__sexe='M'))
            total_count=Count('etudiant')
            inscription_programme_data=inscription_list.values('formation__programme__code').annotate(fille=fille_count).annotate(garcon=garcon_count).annotate(total=total_count)
    
            sexe_list=[
                {
                    'label':'fille',
                    'sexe':'F',
                    'color':(255,120,255)
                },
                {
                    'label':'garcon',
                    'sexe':'M',
                    'color':(0,0,255)
                },
            ]
            
    
    
            for sexe in sexe_list :
                data_=[]
                
                for programme_ in inscription_programme_data :
                    if ratio_ :
                        data_.append(round(programme_[sexe['label']]/programme_['total'],2))
                    else :
                        data_.append(programme_[sexe['label']])
                    if not programme_['formation__programme__code'] in self.labels:
                        self.labels.append(programme_['formation__programme__code'])
                dataset=DataSet(label=sexe['sexe'], data=data_, color=sexe['color'])
                
                self.data.append(dataset)
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors de la génération du graphique des effectifs étudiants")
        
    def get_labels(self, *args, **kwargs):
        return self.labels
    
    def get_datasets(self, **kwargs):
        return self.data

class AbsenceLiveChart(Chart):
    chart_type='line'

    def __init__(self, *args, **kwargs):
        super(AbsenceLiveChart, self).__init__(*args, **kwargs)
        self.labels=[]
        self.data=[]
        self.titre="Nombre d'absences par jour"
        try:
            absence_list=AbsenceEtudiant.objects.filter(seance__date__gt=datetime.date.today()-datetime.timedelta(days=5*30)).order_by('seance__date')
            absence_data=absence_list.values('seance__date').annotate(absence_count=Count('etudiant'))
            
            for absence_jour in absence_data :
                self.labels.append(absence_jour['seance__date'])
                self.data.append(absence_jour['absence_count'])
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors de la génération du graphique du nombre d'absences par jour")
    
    def get_labels(self, *args, **kwargs):
        return self.labels

    def get_datasets(self, **kwargs):
        return [DataSet(
                label = self.titre,
                data = self.data
                )]

class AbsenceFormationPeriodeChart(Chart):
    chart_type='line'

    def __init__(self, formation_pk, periode_pk, *args, **kwargs):
        super(AbsenceFormationPeriodeChart, self).__init__(*args, **kwargs)
        self.labels=[]
        self.data=[]
        self.titre="Nombre d'absences par jour"
        try:
            absence_list=AbsenceEtudiant.objects.filter(seance__activite__module__formation=formation_pk, seance__activite__module__periode__periode=periode_pk).order_by('seance__date')
            absence_data=absence_list.values('seance__date').annotate(absence_count=Count('etudiant', distinct=True))
            
            for absence_jour in absence_data :
                self.labels.append(absence_jour['seance__date'])
                self.data.append(absence_jour['absence_count'])
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors de la génération du graphique du nombre d'absences par jour")
    
    def get_labels(self, *args, **kwargs):
        return self.labels

    def get_datasets(self, **kwargs):
        return [DataSet(
                label = self.titre,
                data = self.data
                )]

class ResultatChart(Chart):
    chart_type='bar'
    
    def __init__(self, moyenne_list, *args, **kwargs):
        super(ResultatChart, self).__init__(*args, **kwargs)
        self.labels=['[0, 8[:Insuffisant', '[8, 10[:Médiocre', '[10, 12[:Passable', '[12, 14[:Assez Bien', '[14, 16[:Bien', '|16, 18[:Très Bien', '[18,20[:Excellent']
        self.titre="Répartition des résultats (en pourcentage) durant la période"
        try:
            
            self.data=[]
            total = len(moyenne_list)
            if total!=0:
                self.data.append(round(len([x for x in moyenne_list if x>=0 and x<8])/total,2)*100)
                self.data.append(round(len([x for x in moyenne_list if x>=8 and x<10])/total,2)*100)
                self.data.append(round(len([x for x in moyenne_list if x>=10 and x<12])/total,2)*100)
                self.data.append(round(len([x for x in moyenne_list if x>=12 and x<14])/total,2)*100)
                self.data.append(round(len([x for x in moyenne_list if x>=14 and x<16])/total,2)*100)
                self.data.append(round(len([x for x in moyenne_list if x>=16 and x<18])/total,2)*100)
                self.data.append(round(len([x for x in moyenne_list if x>=18 and x<=20])/total,2)*100)
    
            self.colors=['#c2c2d6', '#009933', '#66ff66', '#ff9933', '#ff0000', '#000000', '#3333cc']
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors de la génération du graphique d'aggrégat des résultats.")
        
    def get_labels(self, *args, **kwargs):
        return self.labels
    
    def get_datasets(self, **kwargs):
        return [DataSet(data=self.data, backgroundColor=self.colors, label=self.titre)]

class EtudiantWilayaResidenceChart(Chart):
    chart_type='pie'
    options= {
        'legend': {
            'display': False,
        }
    }
    
    def __init__(self, annee_univ_pk, *args, **kwargs):
        super(EtudiantWilayaResidenceChart, self).__init__(*args, **kwargs)
        self.labels=[]
        self.data=[]
        self.colors=[]
        try:
            inscriptions_encours=Inscription.objects.filter(formation__annee_univ__annee_univ=annee_univ_pk).exclude(Q(decision_jury__startswith='F') ).values('etudiant')
            # les étudiants en master ont une double inscription
            etudiants_encours_aggregate=Etudiant.objects.filter(matricule__in=inscriptions_encours).distinct().values('wilaya_residence__nom').annotate(nb_etudiants=Count('matricule')).order_by('nb_etudiants')
            
            for wilaya_aggregate in etudiants_encours_aggregate:
                if wilaya_aggregate['wilaya_residence__nom']==None:
                    self.labels.append("Non disponible")
                else:
                    self.labels.append(wilaya_aggregate['wilaya_residence__nom'])
                self.data.append(wilaya_aggregate['nb_etudiants'])
                self.colors.append("#%06x" % random.randint(0, 0xFFFFFF))
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors de la génération du graphique d'aggrégat des Wilayas de résidence.")
        
    def get_labels(self, *args, **kwargs):
        return self.labels
    
    def get_datasets(self, **kwargs):
        return [DataSet(data=self.data, backgroundColor=self.colors)]

class EtudiantInterneChart(Chart):
    chart_type='pie'
    
    def __init__(self, annee_univ_pk, *args, **kwargs):
        super(EtudiantInterneChart, self).__init__(*args, **kwargs)
        self.labels=[]
        self.data=[]
        self.colors=[]
        try:
            inscriptions_encours=Inscription.objects.filter(formation__annee_univ__annee_univ=annee_univ_pk).exclude(Q(decision_jury__startswith='F') ).values('etudiant')
            # les étudiants en master ont une double inscription
            etudiants_encours_aggregate=Etudiant.objects.filter(matricule__in=inscriptions_encours).distinct().values('interne').annotate(nb_etudiants=Count('matricule')).order_by('nb_etudiants')
            total=Etudiant.objects.filter(matricule__in=inscriptions_encours).distinct().count()
            for interne_aggregate in etudiants_encours_aggregate:
                self.labels.append("Internes" if interne_aggregate['interne'] else "Externes" )
                self.data.append(interne_aggregate['nb_etudiants'])
                #, round(float(interne_aggregate['nb_etudiants'])/float(total)*100,2))
                self.colors.append("#%06x" % random.randint(0, 0xFFFFFF))
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors de la génération du graphique d'aggrégat des Wilayas de résidence.")
        
    def get_labels(self, *args, **kwargs):
        return self.labels
    
    def get_datasets(self, **kwargs):
        return [DataSet(data=self.data, backgroundColor=self.colors)]

class DashboardEtudiantView(LoginRequiredMixin, TemplateView):
    template_name = 'scolar/dashboard_etudiant.html'
    
    def get_context_data(self, **kwargs):
        context = super(DashboardEtudiantView, self).get_context_data(**kwargs)
        context['effectifs_par_sexe_chart']=EtudiantEffectifsChart(False)
        context['effectifs_ratio_par_sexe_chart']=EtudiantEffectifsChart(True)
        context['absence_live_chart']=AbsenceLiveChart()
        annee_univ_encours_pk=AnneeUniv.objects.get(encours=True).annee_univ
        context['effectifs_wilaya_residence']=EtudiantWilayaResidenceChart(annee_univ_encours_pk)
        inscriptions_encours=Inscription.objects.filter(formation__annee_univ__annee_univ=annee_univ_encours_pk).exclude(Q(decision_jury__startswith='F') ).values('etudiant')
        # les étudiants en master ont une double inscription
        etudiants_encours_aggregate=Etudiant.objects.filter(matricule__in=inscriptions_encours).distinct().values('wilaya_residence__nom').annotate(nb_etudiants=Count('matricule')).order_by('-nb_etudiants')
        context['wilayas_aggregate']=etudiants_encours_aggregate
        context['total'] = etudiants_encours_aggregate=Etudiant.objects.filter(matricule__in=inscriptions_encours).distinct().count()
        context['interne_chart']=EtudiantInterneChart(annee_univ_encours_pk)
        context['webhelp']=format_html(HELP_DASHBOARD_ETUDIANT)
        return context

class FormationDecisionJuryChart(Chart):
    chart_type='pie'
    
    def __init__(self, formation_pk, *args, **kwargs):
        super(FormationDecisionJuryChart, self).__init__(*args, **kwargs)
        try:
            formation_=Formation.objects.get(id=formation_pk)
            self.labels=[]
            self.labels.append('En cours')
            self.labels.append('Admis')
            if formation_.activation_rattrapage() :
                self.labels.append('Admis avec Rattrapage')
            if formation_.activation_dettes() :
                self.labels.append('Admis avec Dettes')
            self.labels.append('Admis avec Rachat')
            self.labels.append('Redouble')
            self.labels.append('Non Admis')
            self.labels.append('Abandon')
            self.labels.append('Maladie')           
        
            formation_aggregate=formation_.aggregate_decision_jury()            
            self.data=[]
            if formation_aggregate:                    
                if formation_aggregate['total_inscrits']!=0:
                    self.data.append(round(formation_aggregate['encours']/formation_aggregate['total_inscrits'],2))
                    self.data.append(round(formation_aggregate['admis']/formation_aggregate['total_inscrits'],2))
                    if formation_.activation_rattrapage() :
                        self.data.append(round(formation_aggregate['admis_rattrapage']/formation_aggregate['total_inscrits'],2))
                    if formation_.activation_dettes() :
                        self.data.append(round(formation_aggregate['admis_dettes']/formation_aggregate['total_inscrits'],2))
                    self.data.append(round(formation_aggregate['admis_rachat']/formation_aggregate['total_inscrits'],2))
                    self.data.append(round(formation_aggregate['redouble']/formation_aggregate['total_inscrits'],2))
                    self.data.append(round(formation_aggregate['non_admis']/formation_aggregate['total_inscrits'],2))
                    self.data.append(round(formation_aggregate['abandon']/formation_aggregate['total_inscrits'],2))
                    self.data.append(round(formation_aggregate['maladie']/formation_aggregate['total_inscrits'],2))                    
    
            self.colors=[]
            self.colors.append('#c2c2d6')
            self.colors.append('#009933')
            if formation_.activation_rattrapage() :
                self.colors.append('#FFFF00') 
            if formation_.activation_dettes() :
                self.colors.append('#7F00FF') 
            self.colors.append('#66ff66') 
            self.colors.append('#ff9933') 
            self.colors.append('#ff0000') 
            self.colors.append('#000000') 
            self.colors.append('#3333cc')

        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors de la génération du graphique d'aggrégat des décisions de jury.")
        
    def get_labels(self, *args, **kwargs):
        return self.labels
    
    def get_datasets(self, **kwargs):
        return [DataSet(data=self.data, backgroundColor=self.colors)]

class ProgrammeAvgDecisionJuryChart(Chart):
    chart_type='bar'
    options= {
        'scales': {
            'xAxes': [{
                'stacked': True
            }],
            'yAxes': [{
                'stacked': True,
                'offset':True
            }]
        }
    }
    
    def __init__(self, *args, **kwargs):
        super(ProgrammeAvgDecisionJuryChart, self).__init__(*args, **kwargs)
        self.labels=[]
        self.data=[]
        try:
            programme_data={}
            for programme_ in Programme.objects.all().exclude(doctorat=True).order_by('ordre'):
                aggregate_=programme_.aggregate_avg_decision_jury()
                if aggregate_:
                    programme_data[programme_.code]=aggregate_
                    
            decision_list=[
                {
                    'label':'Succès %: Admis et Rachat',
                    'decision':'success',
                    'color':(0, 153, 51)
                },
                {
                    'label':'Echec %: Réorientés et Abandons',
                    'decision':'echec',
                    'color':(255, 51, 0)
                },
                {
                    'label':'Seconde chance %: Redoublants et Congés de Maladie',
                    'decision':'refaire',
                    'color':(255, 255, 102)
                },

            ]
    
            for decision in decision_list :
                data_=[]
                for code in programme_data.keys() :
                    data_.append(programme_data[code][decision['decision']])
                    if not code in self.labels:
                        self.labels.append(code)
                dataset=DataSet(label=decision['label'], data=data_, color=decision['color'])
                
                self.data.append(dataset)
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors de la génération du graphique des aggrégats de décision de jury par programme")
        
        
    def get_labels(self, *args, **kwargs):
        return self.labels
    
    def get_datasets(self, **kwargs):
        return self.data


class DashboardFormationView(LoginRequiredMixin, TemplateView):
    template_name = 'scolar/dashboard_formation.html'
    
    def get_context_data(self, **kwargs):
        context = super(DashboardFormationView, self).get_context_data(**kwargs)
        annee_univ_qs=AnneeUniv.objects.all().order_by('annee_univ')
        annee_univ_list=[]
        for annee_univ_ in annee_univ_qs:
            element={
                'annee_univ':annee_univ_,
                'formation_list':[]
                }
            formation_list=Formation.objects.filter(annee_univ=annee_univ_).exclude(Q(programme__matiere_equipe__isnull=False) |Q (programme__fictif=True)|Q (programme__doctorat=True)).order_by('programme__ordre')
            for formation_ in formation_list:
                element['formation_list'].append({
                    'formation':formation_,
                    'chart':FormationDecisionJuryChart(formation_.id)
                    })
            annee_univ_list.append(element)
        context['annee_univ_list']=annee_univ_list
        context['programme_avg_chart']=ProgrammeAvgDecisionJuryChart()
        context['programme_list']=Programme.objects.filter(matiere_equipe__isnull=True, fictif=False, doctorat=False).order_by('ordre')
        
        nb_activation_rattrapage=context['programme_list'].filter(cycle__activation_rattrapage=True).count()
        nb_activation_dettes=context['programme_list'].filter(cycle__activation_dettes=True).count()
        
        context['decision_list']=[]
        context['decision_list'].append('admis')
        if nb_activation_rattrapage > 0 :
            context['decision_list'].append('admis_rattrapage')
        if nb_activation_dettes > 0 :
            context['decision_list'].append('admis_dettes')
        context['decision_list'].append('admis_rachat')
        context['decision_list'].append('success')
        context['decision_list'].append('non_admis')
        context['decision_list'].append('abandon')
        context['decision_list'].append('echec')
        context['decision_list'].append('redouble')
        context['decision_list'].append('maladie')
        context['decision_list'].append('refaire')
        context['decision_list'].append('total')
        
        context['webhelp']=format_html(HELP_DASHBOARD_FORMATION)
        
        return context
    

class AbsenceEnseignantLiveChart(Chart):
    chart_type='line'

    def __init__(self, *args, **kwargs):
        super(AbsenceEnseignantLiveChart, self).__init__(*args, **kwargs)
        self.labels=[]
        self.data=[]
        self.titre="Nombre d'absences par jour"
        try:
            absence_list=AbsenceEnseignant.objects.filter(seance__activite__module__formation__annee_univ__encours=True, seance__date__gt=datetime.date.today()-datetime.timedelta(days=5*30))
            absence_data=absence_list.values('seance__date').annotate(absence_count=Count('enseignant'))
            
            for absence_jour in absence_data :
                self.labels.append(absence_jour['seance__date'])
                self.data.append(absence_jour['absence_count'])
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors de la génération du graphique du nombre d'absences enseignants par jour")
            
    
    def get_labels(self, *args, **kwargs):
        return self.labels

    def get_datasets(self, **kwargs):
        return [DataSet(
                label = self.titre,
                data = self.data
                )]

class EnseignantChargeChart(Chart):
    chart_type='pie'
    
    def __init__(self, *args, **kwargs):
        super(EnseignantChargeChart, self).__init__(*args, **kwargs)
        self.labels=['<30%', '[30%-40%]', '[40%-50%]', '[50%-60%]', '[60%-70%]', '[70%-80%]', '[80%-90%]', '[90%-100%]', '>100%']
        try:
            charge_list=Charge.objects.filter(annee_univ__encours=True, realisee_par__situation='A').values('realisee_par').annotate(ratio=
                Case(
                    When(realisee_par__statut='V', then=Value(1)), 
                    When(realisee_par__statut='P', then=Sum(
                         Case(
                             When(repeter_chaque_semaine=True, then=ExpressionWrapper(F('vh_eq_td'), output_field=DecimalField())*15.0), 
                             When(repeter_chaque_semaine=False, then=ExpressionWrapper(F('vh_eq_td'), output_field=DecimalField()))
                         )
                    )/F('realisee_par__charge_statut'))
    
    
                )
            )
            self.data=[]
            if charge_list.count()!=0:
                self.data.append(round(charge_list.filter(ratio__lt=Value(0.3)).count()/charge_list.count(),2))
                self.data.append(round(charge_list.filter(ratio__gte=Value(0.3)).filter(ratio__lt=Value(0.4)).count()/charge_list.count(),2))
                self.data.append(round(charge_list.filter(ratio__gte=Value(0.4)).filter(ratio__lt=Value(0.5)).count()/charge_list.count(),2))
                self.data.append(round(charge_list.filter(ratio__gte=Value(0.5)).filter(ratio__lt=Value(0.6)).count()/charge_list.count(),2))
                self.data.append(round(charge_list.filter(ratio__gte=Value(0.6)).filter(ratio__lt=Value(0.7)).count()/charge_list.count(),2))
                self.data.append(round(charge_list.filter(ratio__gte=Value(0.7)).filter(ratio__lt=Value(0.8)).count()/charge_list.count(),2))
                self.data.append(round(charge_list.filter(ratio__gte=Value(0.8)).filter(ratio__lt=Value(0.9)).count()/charge_list.count(),2))
                self.data.append(round(charge_list.filter(ratio__gte=Value(0.9)).filter(ratio__lt=Value(1.0)).count()/charge_list.count(),2))
                self.data.append(round(charge_list.filter(ratio__gte=Value(1.0)).count()/charge_list.count(),2))
    
            self.colors=['#AA6968', '#808080', '#A9A9A9', '#C0C0C0', '#D3D3D3', '#809080', '#A959A9', '#C0B0C0', '#D2D3D3']
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors de la génération du graphique de répartition des charges")
        
    def get_labels(self, *args, **kwargs):
        return self.labels
    
    def get_datasets(self, **kwargs):
        return [DataSet(data=self.data, backgroundColor=self.colors)]


class EnseignantEffectifsChart(Chart):
    chart_type='bar'
    options= {
        'scales': {
            'xAxes': [{
                'stacked': True
            }],
            'yAxes': [{
                'stacked': True,
                'offset':True
            }]
        }
    }
    
    def __init__(self, ratio_, *args, **kwargs):
        super(EnseignantEffectifsChart, self).__init__(*args, **kwargs)
        self.labels=[]
        self.data=[]
        try:
            fille_count=Count('id', filter=Q(sexe='F'))
            garcon_count=Count('id', filter=Q(sexe='M'))
            total_count=Count('id')
            enseignant_data=Enseignant.objects.filter(situation='A', statut__isnull=False).values('statut').annotate(Femme=fille_count).annotate(Homme=garcon_count).annotate(total=total_count)
    
            sexe_list=[
                {
                    'label':'Femme',
                    'sexe':'F',
                    'color':(255,120,255)
                },
                {
                    'label':'Homme',
                    'sexe':'M',
                    'color':(0,0,255)
                },
            ]
    
            for sexe in sexe_list :
                data_=[]
                for statut_ in enseignant_data :
                    if ratio_ :
                        data_.append(round(statut_[sexe['label']]/statut_['total'],2))
                    else :
                        data_.append(statut_[sexe['label']])
                    if not dict(STATUT)[statut_['statut']] in self.labels:
                        self.labels.append(dict(STATUT)[statut_['statut']])
                dataset=DataSet(label=sexe['label'], data=data_, color=sexe['color'])
                
                self.data.append(dataset)
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors de la génération du graphique des effectifs enseignants")
        
        
    def get_labels(self, *args, **kwargs):
        return self.labels
    
    def get_datasets(self, **kwargs):
        return self.data

class EnseignantGradeChart(Chart):
    chart_type='pie'
    
    def __init__(self,*args, **kwargs):
        self.labels=[]
        self.data=[]
        super(EnseignantGradeChart, self).__init__(*args, **kwargs)
        try:
            enseignant_aggregate=Enseignant.objects.filter(situation='A').exclude(Q(statut='V')|Q(statut='A')).values('grade').annotate(grade_count=Count('id'))
            self.data=[]
            
            for grade_ in dict(GRADE).keys():
                for element in enseignant_aggregate:
                    if element['grade']==grade_:
                        self.data.append(element['grade_count'])
                        self.labels.append(dict(GRADE)[grade_])
            # rajouter le cas grade inconuu
            for element in enseignant_aggregate:
                if element['grade']==None:
                    self.data.append(element['grade_count'])
                    self.labels.append('Non disponible')
            self.colors=['#c2c2d6', '#009933', '#66ff66', '#ff9933', '#ff0000', '#3333cc']
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors de la génération du graphique d'aggrégat des grades des enseignants.")
        
    def get_labels(self, *args, **kwargs):
        return self.labels
    
    def get_datasets(self, **kwargs):
        return [DataSet(data=self.data, backgroundColor=self.colors)]


class DashboardEnseignantView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name = 'scolar/dashboard_enseignant.html'
    
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalitenav_dashboard_enseignants')

    def get_context_data(self, **kwargs):
        context = super(DashboardEnseignantView, self).get_context_data(**kwargs)
        enseignant_aggregate=Enseignant.objects.filter(situation='A').exclude(Q(statut='V')|Q(statut='A')).values('grade').annotate(grade_count=Count('id'))
        total=Enseignant.objects.filter(situation='A').exclude(Q(statut='V')|Q(statut='A')).count()
        grade_count_list={}
        for grade_ in dict(GRADE).keys():
            for element in enseignant_aggregate:
                if element['grade']==grade_:
                    grade_count_list[grade_]=element['grade_count']
        for element in enseignant_aggregate:
            if element['grade']==None:
                grade_count_list['Non disponible']=element['grade_count']
        context['total']=total
        context['grade_count_list']=grade_count_list
        context['effectifs_par_sexe_chart']=EnseignantEffectifsChart(False)
        context['effectifs_ratio_par_sexe_chart']=EnseignantEffectifsChart(True)
        context['enseignant_charge_chart']=EnseignantChargeChart()
        context['enseignant_absence_live_chart']=AbsenceEnseignantLiveChart()
        context['enseignant_grade_chart']=EnseignantGradeChart
        webhelp_=HELP_DASHBOARD_ENSEIGNANT_BASE
        if self.request.user.has_perm('scolar.fonctionnalitenav_enseignants_visualisationcharges') :
            webhelp_+=HELP_DASHBOARD_ENSEIGNANT_CHARGES
        if self.request.user.has_perm('scolar.fonctionnalitenav_enseignants_visualisationabsences') :
            webhelp_+=HELP_DASHBOARD_ENSEIGNANT_ASSIDUITE
        context['webhelp']=format_html(webhelp_)
            
        
        
        return context

class EtudiantDetailView(UserPassesTestMixin, DetailView):
    model = Etudiant
    template_name = 'scolar/etudiant_detail.html'

    def test_func(self):
        etudiant_=get_object_or_404(Etudiant, matricule=self.kwargs.get('pk'))
        doctorant_qs=Doctorant.objects.filter(etudiant=etudiant_)
        if etudiant_.public_profile :
            return True
        elif not self.request.user.is_authenticated :
            return False
        elif self.request.user.has_perm('scolar.fonctionnalitenav_postgraduation_visualisationdoctorants') and doctorant_qs.exists() :
            return True
        elif self.request.user.has_perm_or_student_himself('scolar.fonctionnalitenav_etudiants_annuairecomplet', etudiant_.matricule) :
            return True
        elif etudiant_.acces_profil_candidature(self.request.user) :
            return True
        else :
            return False
        
    def get_context_data(self, **kwargs):
        context = super(EtudiantDetailView, self).get_context_data(**kwargs)
        etudiant_=context['object']
        doctorant_=None
        doctorant_qs=Doctorant.objects.filter(etudiant=etudiant_)
        if doctorant_qs.exists() :
            doctorant_=doctorant_qs.first()
            
        context['doctorant']=doctorant_
        private=False
        if not self.request.user.is_authenticated:
            private=True
        else:
            private=not (self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_etudiants_visualisationsensible', etudiant_.matricule) or (self.request.user.has_perm('scolar.fonctionnalite_postgraduation_visualisationsensibledoctorants') and etudiant_.is_doctorant()))
        context['private'] = private 
        exclude_=[]
        if not self.request.user.is_authenticated:
            exclude_.append('edit')
        elif not (self.request.user.has_perm('scolar.fonctionnalite_etudiants_gestion') or self.request.user.has_perm('scolar.fonctionnalite_postgraduation_gestiondoctorants') or self.request.user.has_cycles_avec_acces_gestion_etudiants()):
            exclude_.append('edit')
        parcours = InscriptionEtudiantTable(Inscription.objects.filter(etudiant=etudiant_).order_by('formation__annee_univ'), exclude=exclude_)
       
        RequestConfig(self.request).configure(parcours)
        context['parcours'] = parcours
        if activation_ddc() :
            profile_chart=ProfileChart(etudiant_pk=self.kwargs.get('pk'))
            context['profile_chart']=profile_chart
        context['decision_jury']=dict(DECISIONS_JURY)
        if self.request.user.is_authenticated :
            if self.request.user.is_etudiant():
                context['is_student_himself']=(self.request.user.etudiant.matricule == self.kwargs.get('pk'))
        try:
            inscription_encours_list=Inscription.objects.filter(etudiant=etudiant_, formation__annee_univ__encours=True)            
        except Inscription.DoesNotExist:
            pass
        else:
            # générer un chart pour chaque periode (période)
            absence_chart_list=[]
            for inscription_encours in inscription_encours_list:
                for periode in inscription_encours.formation.programme.periodes.all() :
                    absence_chart_list.append(AbsenceChart(etudiant_pk=self.kwargs.get('pk'), periode_pk=periode.id))
            context['absence_chart_list']=absence_chart_list
        context['sexes']=dict(SEXE)

        return context

class EtudiantCreateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, CreateView):
    model = Etudiant
    fields = ['user', 'matricule', 'nom', 'nom_a', 'prenom', 'prenom_a', 'sexe','photo','date_naissance', 'wilaya_naissance', 'lieu_naissance',  'lieu_naissance_a', 'wilaya_residence', 'commune_residence', 'addresse_principale','interne', 'residence_univ', 'tel','annee_bac','n_inscription_bac','serie_bac','moyenne_bac','lycee_bac','numero_securite_sociale','activite_extra', 'tuteur','prenom_pere','prenom_pere_a','fonction_pere','nom_mere','nom_mere_a','prenom_mere','prenom_mere_a','fonction_mere','tel_parents','matricule_progres']
    template_name = 'scolar/create.html'
    permission_required='scolar.fonctionnalite_etudiants_gestion'
    success_message = "L'étudiant a été créé avec succès!"
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.fields['user']=forms.ModelChoiceField(
                queryset=User.objects.filter(Q(etudiant__isnull=True)).order_by('username'),
                label=u"Utilisateur de la plateforme",
                widget=ModelSelect2Widget(
                        model=User,
                        search_fields=['username__icontains', 'email__icontains'],
    
                    ),
                help_text = "Tapez le nom d'utilisateur ou une partie du nom d'utilisateur pour faire une recherche",
                required = False
            )
        form.fields['date_naissance']=forms.DateField(required=False, input_formats = settings.DATE_INPUT_FORMATS, widget=DatePickerInput(format='%d/%m/%Y'))
        form.fields['photo'].help_text="Si vous voulez changer de photo, merci de déposer ici un scan d'une photo d'identité. Taille maximale 1M."
        form.fields['numero_securite_sociale'].help_text="Merci d'indiquer le numéro figurant sur l'ATS ou carte CHIFA."
        form.fields['wilaya_naissance'] = forms.ModelChoiceField(
                    queryset=Wilaya.objects.all().order_by('nom'),
                    label=u"Wilaya de naissance",
                    widget=ModelSelect2Widget(
                        model=Wilaya,
                        search_fields=['nom__icontains',],
                    ),
                    help_text = "Choisir une wilaya. Tapez deux espaces pour avoir toute la liste.",
                    required=False
                    )

        form.fields['wilaya_residence'] = forms.ModelChoiceField(
                    queryset=Wilaya.objects.all().order_by('nom'),
                    label=u"Wilaya de résidence principale",
                    widget=ModelSelect2Widget(
                        model=Wilaya,
                        search_fields=['nom__icontains',],
                    ),
                    help_text = "Choisir une wilaya. Tapez deux espaces pour avoir toute la liste.",
                    required=False
                    )
        form.fields['commune_residence'] = forms.ModelChoiceField(
                    queryset=Commune.objects.all().order_by('nom'),
                    label=u"Commune de résidence principale",
                    widget=ModelSelect2Widget(
                        model=Commune,
                        search_fields=['nom__icontains',],
                        dependent_fields={'wilaya_residence':'wilaya'},
                    ),
                    help_text = "Choisir une commune. Tapez deux espaces pour avoir toute la liste.",
                    required=False
                    )
        form.fields['annee_bac'].help_text="Veuillez indiquer l'année d'obtention bac."
        form.fields['serie_bac'].help_text="Choisir l'un de ces options:N03=Sciences Experimentales, N04=Mathématiques, N05=Techniques Mathematiques."
        form.fields['matricule_progres'].help_text="Vous pouvez extraire matricule progres à partir de la plateforme progres."
        form.fields['tel_parents'].help_text="Merci d'indiquer le numéro de téléphone l'un des parents(personne à contacter)."        
        form.helper.add_input(Submit('submit','Créer', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('etudiant_list')
        return form
    
class EtudiantUpdateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, UpdateView):
    model = Etudiant
    fields = ['user', 'nom', 'nom_a', 'prenom', 'prenom_a', 'sexe','photo','date_naissance', 'wilaya_naissance', 'lieu_naissance',  'lieu_naissance_a', 'wilaya_residence', 'commune_residence', 'addresse_principale','interne', 'residence_univ', 'tel','annee_bac','n_inscription_bac','serie_bac','moyenne_bac','lycee_bac','numero_securite_sociale','activite_extra', 'tuteur','prenom_pere','prenom_pere_a','fonction_pere','nom_mere','nom_mere_a','prenom_mere','prenom_mere_a','fonction_mere','tel_parents','matricule_progres']
    template_name = 'scolar/update.html'
    permission_required='scolar.fonctionnalite_etudiants_gestion'
    success_message = "Le dossier étudiant a été modifié avec succès!"
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        etudiant_ = get_object_or_404(Etudiant, matricule=self.kwargs.get("pk"))  
        form.fields['user']=forms.ModelChoiceField(
                queryset=User.objects.filter(Q(etudiant__matricule=etudiant_.matricule) | Q(etudiant__isnull=True)).order_by('username'),
                label=u"Utilisateur de la plateforme",
                widget=ModelSelect2Widget(
                        model=User,
                        search_fields=['username__icontains', 'email__icontains'],
    
                    ),
                help_text = "Tapez le nom d'utilisateur ou une partie du nom d'utilisateur pour faire une recherche",
                required = False,
                initial=etudiant_.user
            )
        form.fields['date_naissance']=forms.DateField(required=False, input_formats = settings.DATE_INPUT_FORMATS, widget=DatePickerInput(format='%d/%m/%Y'))
        form.fields['photo'].help_text="Scan d'une photo d'identité. Taille maximale 1M."
        form.fields['numero_securite_sociale'].help_text="Merci d'indiquer le numéro figurant sur l'ATS ou carte CHIFA."
        form.fields['wilaya_naissance'] = forms.ModelChoiceField(
                    queryset=Wilaya.objects.all().order_by('nom'),
                    label=u"Wilaya de naissance",
                    widget=ModelSelect2Widget(
                        model=Wilaya,
                        search_fields=['nom__icontains',],
                    ),
                    help_text = "Choisir une wilaya. Tapez deux espaces pour avoir toute la liste.",
                    required=False
                    )

        form.fields['wilaya_residence'] = forms.ModelChoiceField(
                    queryset=Wilaya.objects.all().order_by('nom'),
                    label=u"Wilaya de résidence principale",
                    widget=ModelSelect2Widget(
                        model=Wilaya,
                        search_fields=['nom__icontains',],
                    ),
                    help_text = "Choisir une wilaya. Tapez deux espaces pour avoir toute la liste.",
                    required=False,
                    )
        form.fields['commune_residence'] = forms.ModelChoiceField(
                    queryset=Commune.objects.all().order_by('nom'),
                    label=u"Commune de résidence principale",
                    widget=ModelSelect2Widget(
                        model=Commune,
                        search_fields=['nom__icontains',],
                        dependent_fields={'wilaya_residence':'wilaya'},
                    ),
                    help_text = "Choisir une commune. Tapez deux espaces pour avoir toute la liste.",
                    required=False
                    )
        form.fields['annee_bac'].help_text="Veuillez indiquer l'année d'obtention bac."
        form.fields['serie_bac'].help_text="Choisir l'un de ces options:N03=Sciences Experimentales, N04=Mathématiques, N05=Techniques Mathematiques."
        form.fields['matricule_progres'].help_text="Vous pouvez extraire matricule progres à partir de la plateforme progres."
        form.fields['tel_parents'].help_text="Merci d'indiquer le numéro de téléphone l'un des parents(personne à contacter)."        
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('etudiant_detail', kwargs={'pk': str(self.kwargs.get('pk'))})
        return form

class EtudiantDeleteView(LoginRequiredMixin, PermissionRequiredMixin, DeleteView):
    model = Etudiant
    template_name = 'scolar/delete.html'
    permission_required = 'scolar.fonctionnalite_etudiants_suppression'

    def delete(self, *args, **kwargs):
        etudiant_=self.get_object()
        trace_create(self.request.user, etudiant_, "Suppression de l'étudiant "+str(etudiant_))
        return super(EtudiantDeleteView, self).delete(*args, **kwargs)
            
    def get_success_url(self):
        messages.success(self.request, "L'étudiant a bien été supprimé!")
        return reverse('etudiant_list')
    
class EtudiantProfileUpdateView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, UpdateView):
    model = Etudiant
    fields = ['public_profile','github','linkdin','activite_extra',]
    template_name = 'scolar/update.html'
    success_message = "Votre dossier a été mis à jour avec succès!"
    
    def test_func(self):
        if self.request.user.etudiant.matricule == self.kwargs.get('pk'):
            messages.info(self.request, "Utilisez ce formulaire pour rendre votre profile visible sur Talents Finder!")
            messages.info(self.request, "Si vous voulez rajouter des activités extra-scolaire, merci d'en faire la demande à votre tuteur ou chef de département.")
            return True
        else:
            return False
        
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.fields['linkdin']=forms.URLField(label='Linkedin', required=False)
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('etudiant_detail', kwargs={'pk': str(self.kwargs.get('pk'))})
        return form

class EtudiantActiviteExtraUpdateView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, UpdateView):
    model = Etudiant
    fields = ['activite_extra',]
    template_name = 'scolar/update.html'
    success_message = "Le dossier de votre étudiant a été mis à jour avec succès!"
    
    def test_func(self):
        if self.request.user.is_tuteur( self.kwargs.get('pk')):
            messages.info(self.request, "Utilisez ce formulaire pour rajouter des activités extra-scolaires.")
            messages.info(self.request, "Merci de se limiter aux activités officiellement reconnues à l'institution dans le cadre de la vie associative et sportive.")
            messages.warning(self.request, "Merci de vérifier la véracité des informations auprès du service des activités associatives et sportives.")
            return True
        else:
            return False
        
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('tutorat_list')
        return form

class EtudiantSituationCertificatePDFView(LoginRequiredMixin, UserPassesTestMixin, PDFTemplateView):
    template_name = 'scolar/situation_certificate_pdf.html'

    def test_func(self):
        etudiant_=Inscription.objects.get(id=self.kwargs.get('inscription_pk')).etudiant
        return self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_etudiants_documents' and 'scolar.fonctionnalite_etudiants_attestations', etudiant_.matricule) or self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_postgraduation_visualisationdocumentsdoctorants', etudiant_.matricule)
    
    def get_context_data(self, **kwargs):
        context = super(EtudiantSituationCertificatePDFView, self).get_context_data(**kwargs)
        inscription_=Inscription.objects.get(id=self.kwargs.get('inscription_pk'))
        self.filename = str(inscription_.etudiant)+'_Situation_Certificate.pdf'
        context['inscription'] = inscription_
        context['today']=datetime.date.today()

        return context
    
class EtudiantCertificatbonneConduiteFRPDFView(LoginRequiredMixin, UserPassesTestMixin, PDFTemplateView):
    template_name = 'scolar/certificat_bonne_conduite_fr.html'
    
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalite_etudiants_documents')
    
    def get_context_data(self, **kwargs):
        context = super(EtudiantCertificatbonneConduiteFRPDFView, self).get_context_data(**kwargs)
        inscription_=Inscription.objects.get(id=self.kwargs.get('inscription_pk'))
        self.filename = str(inscription_.etudiant)+'_Bonne_Conduite_Fr.pdf'
        context['inscription'] = inscription_
        context['today']=datetime.date.today()

        return context    
    
class EtudiantCertificatbonConduitePDFView(LoginRequiredMixin, UserPassesTestMixin, PDFTemplateView):
    template_name = 'scolar/certificat_bon_conduite_pdf.html'

    def test_func(self):
        #etudiant_=Inscription.objects.get(id=self.kwargs.get('inscription_pk')).etudiant
        return self.request.user.has_perm('scolar.fonctionnalite_etudiants_documents')
    
    def get_context_data(self, **kwargs):
        context = super(EtudiantCertificatbonConduitePDFView, self).get_context_data(**kwargs)
        inscription_=Inscription.objects.get(id=self.kwargs.get('inscription_pk'))
        self.filename = str(inscription_.etudiant)+'_certificat_bon_conduite.pdf'
        context['inscription'] = inscription_
        context['today']=datetime.date.today()

        return context

class EtudiantAttestationEtudesFrancaisPDFView(LoginRequiredMixin, UserPassesTestMixin, PDFTemplateView):
    template_name = 'scolar/attestation_etudes_francais_pdf.html'
    cmd_options={
        'orientation':'Portrait',
        'page-size':'A5',
        }

    def test_func(self):
        etudiant_=Inscription.objects.get(id=self.kwargs.get('inscription_pk')).etudiant
        return self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_etudiants_documents' and 'scolar.fonctionnalite_etudiants_attestations', etudiant_.matricule) or self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_postgraduation_visualisationdocumentsdoctorants', etudiant_.matricule)
    
    def get_context_data(self, **kwargs):
        context = super(EtudiantAttestationEtudesFrancaisPDFView, self).get_context_data(**kwargs)
        inscription_=Inscription.objects.get(id=self.kwargs.get('inscription_pk'))
        self.filename = str(inscription_.etudiant)+'_Etudes_Francais.pdf'
        context['inscription'] = inscription_
        context['today']=datetime.date.today()

        return context

class EtudiantCertificatNonObjectionPDFView(LoginRequiredMixin, UserPassesTestMixin, PDFTemplateView):
    template_name = 'scolar/certificat_non_objection_pdf.html'
    cmd_options={
        'orientation':'Portrait',
        'page-size':'A4',
        }

    def test_func(self):
        etudiant_=InscriptionPeriode.objects.get(id=self.kwargs.get('inscription_periode_pk')).inscription.etudiant
        return self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_etudiants_documents', etudiant_.matricule) or self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_etudiants_documentsnonsignes', etudiant_.matricule)
    
    def get_context_data(self, **kwargs):
        context = super(EtudiantCertificatNonObjectionPDFView, self).get_context_data(**kwargs)
        inscription_periode=InscriptionPeriode.objects.get(id=self.kwargs.get('inscription_periode_pk'))
        self.filename = str(inscription_periode.inscription.etudiant)+'_Certificat_Non_Objection.pdf'
        context['inscription_periode'] = inscription_periode
        context['today']=datetime.date.today()

        return context
    
class EtudiantDemandePrologationChambreUniversitairePDFView(LoginRequiredMixin, UserPassesTestMixin, PDFTemplateView):
    template_name = 'scolar/Demande_Chambre_Universitaire_pdf.html'
    cmd_options={
        'orientation':'Portrait',
        'page-size':'A4',
        }

    def test_func(self):
        etudiant_=InscriptionPeriode.objects.get(id=self.kwargs.get('inscription_periode_pk')).inscription.etudiant
        return self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_etudiants_documents', etudiant_.matricule) or self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_etudiants_documentsnonsignes', etudiant_.matricule)
    
    def get_context_data(self, **kwargs):
        context = super(EtudiantDemandePrologationChambreUniversitairePDFView, self).get_context_data(**kwargs)
        inscription_periode=InscriptionPeriode.objects.get(id=self.kwargs.get('inscription_periode_pk'))
        self.filename = str(inscription_periode.inscription.etudiant)+'_Demande_Chambre_Universitaire_pdf'
        context['inscription_periode'] = inscription_periode
        context['today']=datetime.date.today()

        return context    
    



class EtudiantDocumentsListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name = 'scolar/etudiant_documents.html'
    
    def test_func(self):
        etudiant_=get_object_or_404(Etudiant, matricule=self.kwargs.get('etudiant_pk'))
        permission_=False
        permission_ = permission_ | self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_etudiants_documents', self.kwargs.get('etudiant_pk')) or self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_etudiants_documentsnonsignes', self.kwargs.get('etudiant_pk'))
        if etudiant_.is_doctorant() :
            permission_ = permission_ | self.request.user.has_perm('scolar.fonctionnalite_postgraduation_visualisationdocumentsdoctorants') | self.request.user.has_perm('scolar.fonctionnalite_postgraduation_visualisationdocumentsnonsignesdoctorants') 
        return permission_
    
    def get_context_data(self, **kwargs):
        context = super(EtudiantDocumentsListView, self).get_context_data(**kwargs)
        etudiant_=Etudiant.objects.get(matricule=self.kwargs.get('etudiant_pk'))
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalite_etudiants_gestion'):
            exclude_.append('edit')
            exclude_.append('admin')        
        parcours = InscriptionEtudiantDocumentsTable(Inscription.objects.filter(etudiant=etudiant_).order_by('formation__annee_univ'), exclude=exclude_)
        RequestConfig(self.request).configure(parcours)
        context['table'] = parcours
        if self.request.user.is_etudiant() :
            if self.request.user.etudiant == etudiant_ :
                context['is_etudiant_himself']=True
        
        documents={}
        inscription_encours_list=Inscription.objects.filter(etudiant=etudiant_.matricule, formation__annee_univ__encours=True)
        for inscription_ in inscription_encours_list.exclude(decision_jury='X').exclude(decision_jury__startswith='M').exclude(decision_jury__startswith='F'):
            if self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_etudiants_documents' and 'scolar.fonctionnalite_etudiants_attestations' , etudiant_.matricule) or self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_postgraduation_visualisationdocumentsdoctorants', etudiant_.matricule) :
                document_config_qs=DocumentConfig.objects.filter(code="ATTESTATION_ETUDES_EN", programme=inscription_.formation.programme)
                if document_config_qs.exists() and document_config_qs.first().actif:
                    documents['Situation Certificate '+str(inscription_.formation)]=reverse("situation_certificate_pdf", kwargs={'inscription_pk':inscription_.id})
                document_config_qs=DocumentConfig.objects.filter(code="ATTESTATION_ETUDES_FR", programme=inscription_.formation.programme)
                if document_config_qs.exists() and document_config_qs.first().actif:                
                    documents["Attestation d'études en français "+str(inscription_.formation)]=reverse("attestation_etudes_francais_pdf", kwargs={'inscription_pk':inscription_.id})
        for inscription_ in inscription_encours_list:            
            if self.request.user.has_perm('scolar.fonctionnalite_etudiants_documents') and self.request.user.has_perm('scolar.fonctionnalite_etudiants_attestations'):        
                document_config_qs=DocumentConfig.objects.filter(code="ATTESTATION_BONNE_CONDUITE_FR", programme=inscription_.formation.programme)                
                if document_config_qs.exists() and document_config_qs.first().actif:
                    documents['Attestation de bonne conduite français '+str(inscription_.formation)]=reverse("certificat_bonne_conduite_fr", kwargs={'inscription_pk':inscription_.id})
                document_config_qs=DocumentConfig.objects.filter(code="ATTESTATION_BONNE_CONDUITE", programme=inscription_.formation.programme)                
                if document_config_qs.exists() and document_config_qs.first().actif:
                    documents['Attestation de bonne conduite arabe '+str(inscription_.formation)]=reverse("certificat_bon_conduite_pdf", kwargs={'inscription_pk':inscription_.id})
                                            
                    
            for inscription_periode_ in inscription_.inscription_periodes.all():
                if inscription_periode_.groupe :
                    try:
                        document_config_qs=DocumentConfig.objects.filter(code="CERTIFICAT_NON_OBJECTION", programme=inscription_.formation.programme)
                        if document_config_qs.exists() and document_config_qs.first().actif:
                            pfe_=PFE.objects.get(groupe=inscription_periode_.groupe)
                            if pfe_.organisme:
                                if not pfe_.organisme.pays in ['dz', 'DZ']:
                                    if self.request.user.has_perm('scolar.fonctionnalite_etudiants_documents') and self.request.user.has_perm('scolar.fonctionnalite_etudiants_docstage'):
                                        documents['Certificat Non Objection -S '+str(inscription_.formation)]=reverse("certificat_non_objection_pdf", kwargs={'inscription_periode_pk':inscription_periode_.id, 'signature':0})
                                    if self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_etudiants_documents', etudiant_.matricule):
                                        documents['Certificat Non Objection '+str(inscription_.formation)]=reverse("certificat_non_objection_pdf", kwargs={'inscription_periode_pk':inscription_periode_.id, 'signature':1})
                                        
                        document_config_qs=DocumentConfig.objects.filter(code="Demande_Chambre_Universitaire", programme=inscription_.formation.programme)
                        if document_config_qs.exists() and document_config_qs.first().actif:
                            pfe_=PFE.objects.get(groupe=inscription_periode_.groupe)
                            if pfe_.organisme:                                
                                if self.request.user.has_perm('scolar.fonctionnalite_etudiants_documents') and self.request.user.has_perm('scolar.fonctionnalite_etudiants_docstage'):
                                    documents['Demande Chambre Universitaire '+str(inscription_.formation)]=reverse("Demande_Chambre_Universitaire_pdf", kwargs={'inscription_periode_pk':inscription_periode_.id, 'signature':0})              
                        
                    except ObjectDoesNotExist:               
                   
                        pass    
        for diplome in Diplome.objects.all().exclude(programme__doctorat=True):
            document_config_qs=DocumentConfig.objects.filter(code="RELEVE_NOTES_GLOBAL", diplome=diplome)
            if document_config_qs.exists() and document_config_qs.first().actif:
                inscriptions = Inscription.objects.filter(etudiant=self.kwargs.get('etudiant_pk'), formation__programme__diplome=diplome)
                if inscriptions.exists():
                    if self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_etudiants_documents' and 'scolar.fonctionnalite_etudiants_telechargerdocuments' , etudiant_.matricule) :
                        documents["Relevé de Notes Global du Diplome "+str(diplome)]=reverse('releve_notes_global_pdf', kwargs={'etudiant_pk':self.kwargs.get('etudiant_pk'), 'diplome_pk':diplome.id})                        
        inscriptions_avec_admission_list_tmp = Inscription.objects.filter(etudiant__matricule=self.kwargs.get('etudiant_pk')).filter( Q(decision_jury='A') | Q(decision_jury='AR') | Q(decision_jury='AC') | Q(decision_jury='CR')| Q(decision_jury='AD')| Q(decision_jury='SR')).order_by('formation__programme__ordre') 
        inscriptions_avec_admission_list = []
        
        for inscription_ in inscriptions_avec_admission_list_tmp :
            if ((inscription_.formation.archive ==True) | ((inscription_.formation.annee_univ.encours == False)&( inscription_.formation.programme.inclut_pfe()))) :
                inscriptions_avec_admission_list.append(inscription_)        
        
        if inscriptions_avec_admission_list:
            if activation_livret_competences() and self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_etudiants_documents' and 'scolar.fonctionnalite_etudiants_telechargerdocuments', etudiant_.matricule) :
                # ne pas modifier la clé "Livret des compétences", ou bien la modifier également dans etudiant_documents.html
                documents["Livret des compétences"]=etudiant_.livret_competences.url if etudiant_.livret_competences else ''  
        context['documents']=documents
        context['titre'] = 'Documents de '+str(etudiant_)
        context['etudiant']=etudiant_
        return context

def inscription_update_view(request, pk):
    inscription_=get_object_or_404(Inscription, id=pk)   
    if inscription_.formation.programme.doctorat :
        if not (request.user.has_perm('scolar.fonctionnalite_postgraduation_gestiondoctorants')):
            messages.error(request, "Vous n'avez pas la permission d'accès à cette fonction.")
            return redirect('/accounts/login/?next=%s' % request.path)              
    else :
        if not (request.user.has_perm('scolar.fonctionnalite_etudiants_gestion') or request.user.has_acces_gestion_etudiants_programme(inscription_.formation.programme)):
            messages.error(request, "Vous n'avez pas la permission d'accès à cette fonction.")
            return redirect('/accounts/login/?next=%s' % request.path)
       
    
    # if this is a POST request we need to process the form data
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = InscriptionUpdateForm(pk, request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:    
                form_data=form.cleaned_data                
                if not inscription_.formation.archive:
                    ancienne_decision_jury=inscription_.decision_jury
                    inscription_.decision_jury=form_data['decision_jury']
                    inscription_.save(update_fields=['decision_jury'])
                    if ancienne_decision_jury != inscription_.decision_jury :
                        trace_create(request.user, inscription_.etudiant, "Modification de la décision du jury de "+str(inscription_)+" de "+str(dict(DECISIONS_JURY)[ancienne_decision_jury])+" vers "+str(dict(DECISIONS_JURY)[inscription_.decision_jury]))
                        inscription_.proposition_decision_jury=inscription_.decision_jury
                        inscription_.save(update_fields=['proposition_decision_jury'])
                    if (inscription_.observation or form_data['observation']) and (inscription_.observation != form_data['observation']) :
                        inscription_.observation=form_data['observation']
                        inscription_.save(update_fields=['observation'])
                        trace_create(request.user, inscription_.etudiant, str(inscription_)+" : Observation modifiée")
                    for inscription_periode_ in inscription_.inscription_periodes.all():
                        key_='groupe_'+str(inscription_periode_.id)
                        ancien_groupe=inscription_periode_.groupe
                        inscription_periode_.groupe=form_data[key_]
                        inscription_periode_.save()
                        if ancien_groupe != inscription_periode_.groupe :
                            trace_create(request.user, inscription_.etudiant, "Modification du groupe de "+str(inscription_periode_)+" de "+str(ancien_groupe)+" vers "+str(inscription_periode_.groupe))                
                elif form_data['observation']:
                    if (inscription_.observation or form_data['observation']) and (inscription_.observation != form_data['observation']) :
                        inscription_.observation=form_data['observation']
                        inscription_.save(update_fields=['observation'])
                        trace_create(request.user, inscription_.etudiant,str(inscription_)+" : Observation modifiée. ")
                else: 
                    messages.error(request, "Cette formation est archivée, il n'est pas possible de modifier cette inscription.")
                    return redirect(reverse('etudiant_detail',kwargs={'pk': inscription_.etudiant.matricule }))
                        
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: La modification de l'inscription s'est terminée avec des erreurs." )
                    render(request, 'scolar/import.html', {'form': form, 'titre':'Modification d\'une Inscription'})
            messages.success(request, "La modification de l'inscription a été réalisée avec succès!")
            # redirect to a new URL:
            return HttpResponseRedirect(reverse('etudiant_detail',kwargs={'pk': inscription_.etudiant.matricule })) 
    # if a GET (or any other method) we'll create a blank form
    else:
        form = InscriptionUpdateForm(pk)
    return render(request, 'scolar/import.html', {'form': form, 'titre':'Modification d\'une Inscription'})


class InscriptionDeleteView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, DeleteView):
    model = Inscription
    template_name = 'scolar/delete.html'
    success_message = "L'inscription a bien été supprimée."

    def test_func(self):
        inscription_=get_object_or_404(Inscription, id=self.kwargs.get('pk'))
        if inscription_.formation.programme.doctorat :
            return self.request.user.has_perm('scolar.fonctionnalite_postgraduation_gestiondoctorants') 
        else :
            return self.request.user.has_perm('scolar.fonctionnalite_etudiants_gestion')

    def get_success_url(self):
        return reverse('etudiant_detail',kwargs={'pk': self.kwargs.get('etudiant_pk')})
    
    def delete(self, *args, **kwargs):
        inscription_=self.get_object()
        trace_create(self.request.user, inscription_.etudiant, "Suppression de l'inscription "+str(inscription_))
        return super(InscriptionDeleteView, self).delete(*args, **kwargs)
        
  
class InscriptionCreateView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, CreateView):

    model = Inscription
    fields=['etudiant', 'formation']
    template_name = 'scolar/create.html'
    success_message = "La nouvelle inscription a été ajoutée avec succès!"

    def test_func(self):
        etudiant_=get_object_or_404(Etudiant, matricule=self.kwargs.get('etudiant_pk'))
        permission_=False
        if etudiant_.is_doctorant() :
            permission_=permission_ | self.request.user.has_perm('scolar.fonctionnalite_postgraduation_gestiondoctorants') 
        permission_ = permission_ | self.request.user.has_perm('scolar.fonctionnalite_etudiants_gestion')
        return permission_

    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.fields['etudiant']=forms.ModelChoiceField(queryset=Etudiant.objects.filter(matricule=self.kwargs.get('etudiant_pk')), initial=0)
        
        etudiant_=get_object_or_404(Etudiant, matricule=self.kwargs.get('etudiant_pk'))
        if etudiant_.is_doctorant() and not self.request.user.has_perm('scolar.fonctionnalite_etudiants_gestion'):
            form.fields['formation']=forms.ModelChoiceField(queryset=Formation.objects.filter(programme__doctorat=True).order_by('-annee_univ__annee_univ', 'programme__ordre'), required=True)    
        else :
            form.fields['formation']=forms.ModelChoiceField(queryset=Formation.objects.all().order_by('-annee_univ__annee_univ', 'programme__ordre'), required=True)
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('etudiant_detail',kwargs={'pk': self.kwargs.get('etudiant_pk')})
        return form

    def form_valid(self, form):
        self.object = form.save()
        inscription_=self.object
        trace_create(self.request.user, inscription_.etudiant, "Création de l'inscription "+str(inscription_))        
        return HttpResponseRedirect(self.get_success_url())


class InscriptionListView(LoginRequiredMixin, PermissionRequiredMixin,TemplateView):
    permission_required = 'scolar.fonctionnalitenav_etudiants_annuairecomplet'
    template_name = 'scolar/filter_list.html'
    
    def get_queryset(self, **kwargs):
        return Inscription.objects.filter(formation__annee_univ__encours=True)

    def get_context_data(self, **kwargs):
        context = super(InscriptionListView, self).get_context_data(**kwargs)
        filter_ = InscriptionFilter(self.request.GET, queryset=self.get_queryset(**kwargs))
        filter_.form.helper = FormHelper()
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalite_etudiants_gestion'):
            exclude_.append('edit')
            exclude_.append('admin')         
        table = InscriptionTable(filter_.qs, exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['filter'] = filter_
        context['table'] = table
        context['back'] = reverse('home')
        btn_list={}
        if self.request.user.has_perm('scolar.fonctionnalite_etudiants_gestion'):
            btn_list['Import Inscriptions']=reverse('inscriptions_import')
            btn_list['Import Affectations Groupes']=reverse('import_affectation_groupe')
        if self.request.user.has_perm('scolar.fonctionnalite_stages_importation'):
            btn_list['Import Affectations PFE']=reverse('import_affectation_pfe')
        context['btn_list']=btn_list
        context['titre']='Etudiants Inscrits Année en Cours'
        return context

def inscription_annee_suivante_view(request, formation_pk):
    if not request.user.has_perm('scolar.fonctionnalitenav_pedagogie_generationpvsdeliberation'):
        messages.error(request,"Vous n'avez pas les permissions pour effectuer cette opération.")
        return redirect('/accounts/login/?next=%s' % request.path)

    try:
        formation_=Formation.objects.get(id=formation_pk)
        formation_.archive=True
        formation_.save(update_fields=['archive'])
        # submit as background task
        #t = threading.Thread(target=task_note_update,args=[form, module_, groupe_, request.user])
        #t.setDaemon(True)
        #t.start()
        #messages.info(request, "Votre demande d'enregistrement des notes a été prise en compte. Une notification vous sera transmise.")
        
        #inscrire les maladies et redoublants dans la même formation année suivante
        formation_idem_annee_suivante=formation_.formation_idem_annee_suivante()
        inscription_non_admis_list=Inscription.objects.filter(Q(formation=formation_) & (Q(decision_jury='R') | Q(decision_jury__startswith='M')| Q(decision_jury='AJ')))
        for inscription_ in inscription_non_admis_list:
#             #indiquer les modules acquis
#             if inscription_.decision_jury == 'R':
#                 for resultat_ in Resultat.objects.filter(ancien_resultat__isnull=True, inscription=inscription_):
#                     if resultat_.moy_post_delib >= 10:
#                         resultat_.acquis=True
#                     else: 
#                         resultat_.acquis = False
#                     resultat_.save(update_fields=['acquis'])
                    
            #indiquer les semestres acquis     
            if inscription_.decision_jury == 'R':
                for inscriptionperiode_ in InscriptionPeriode.objects.filter(inscription=inscription_):
                    # s'il n'a pas une note eliminatoire
                    if  inscriptionperiode_.ne == 0 and inscriptionperiode_.moy_post_delib() >= 10 :
                        inscriptionperiode_.acquis=True
                        #inscriptionperiode_.resultat__acquis=True
                    else: 
                        inscriptionperiode_.acquis = False
                        #indiquer les modules acquis
                        for resultat_ in Resultat.objects.filter(ancien_resultat__isnull=True, inscription=inscription_):
                            if resultat_.moy_post_delib >= 10:
                               resultat_.acquis=True
                            else: 
                               resultat_.acquis = False
                            resultat_.save(update_fields=['acquis'])
                    inscriptionperiode_.save(update_fields=['acquis'])
                        
            nouvelle_inscription_, created = Inscription.objects.update_or_create(etudiant=inscription_.etudiant, formation=formation_idem_annee_suivante, defaults={
                    'etudiant':inscription_.etudiant,
                    'formation':formation_idem_annee_suivante,
                })
            # créer inscription_periodes selon le programme
            for periode_ in formation_idem_annee_suivante.programme.periodes.all():
                InscriptionPeriode.objects.update_or_create(inscription=nouvelle_inscription_, periodepgm=periode_, defaults={
                        'inscription':nouvelle_inscription_,
                        'periodepgm':periode_,
                    })
            

        formation_sup_annee_suivante=formation_.formation_sup_annee_suivante()
        if formation_sup_annee_suivante==None:
            
            #Ce cas correspond à l'année suivante qui requière le choix de spécialité
            return HttpResponseRedirect(reverse('inscriptions_import'))
        else:
            #inscrire les admis dans formation_sup_annee_suivante
            inscription_admis_list=Inscription.objects.filter(Q(formation=formation_) & (Q(decision_jury='A') | Q(decision_jury='AR') | Q(decision_jury='SR') | Q(decision_jury='AD')))
            for inscription_ in inscription_admis_list:
                nouvelle_inscription_, created = Inscription.objects.update_or_create(etudiant=inscription_.etudiant, formation=formation_sup_annee_suivante, defaults={
                        'etudiant':inscription_.etudiant,
                        'formation':formation_sup_annee_suivante,
                    })
                # créer inscription_periodes selon le programme
                for periode_ in formation_sup_annee_suivante.programme.periodes.all():
                    InscriptionPeriode.objects.update_or_create(inscription=nouvelle_inscription_, periodepgm=periode_, defaults={
                            'inscription':nouvelle_inscription_,
                            'periodepgm':periode_,
                        })
        
        trace_create(request.user, request.user, "Passage vers l'année suivante pour la formation : "+str(formation_))       
        messages.success(request,"Les inscriptions vers l'année suivante ont été réalisées avec succès!")
        return HttpResponseRedirect(reverse('deliberation_detail', kwargs={'formation_pk':formation_pk, }))
    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            messages.error(request, "ERREUR: lors des inscriptions vers l'année suivante. Merci de le signaler à l'administrateur")
    
@login_required
def inscription_annee_suivante_confirmation(request, formation_pk):
    if not request.user.has_perm('scolar.fonctionnalitenav_pedagogie_generationpvsdeliberation'):
        messages.error(request,"Vous n'avez pas les permissions pour effectuer cette opération.")
        return redirect('/accounts/login/?next=%s' % request.path)  
          
    context={}
    context['info']="Les étudiants admis à la formation en cours passeront à la formation d'ordre+1 du même diplôme. Les redoublants seront inscrits à la formation du même programme de l'année universitaire+1."
    context['lien']=reverse('inscription_annee_suivante', kwargs={'formation_pk': formation_pk}) 
    return render(request, 'scolar/confirmation.html', context)


class EnseignantListView(LoginRequiredMixin,UserPassesTestMixin , TemplateView):
    template_name = 'scolar/filter_list.html'

    def test_func(self):    
        if self.request.user.has_perm('scolar.fonctionnalitenav_enseignants_annuairecomplet')  :
            return True
        else :
            return False
        
    def get_queryset(self, **kwargs):
        return Enseignant.objects.all().order_by('nom', 'prenom')

    def get_context_data(self, **kwargs):
        context = super(EnseignantListView, self).get_context_data(**kwargs)
        filter_ = EnseignantFilter(self.request.GET, queryset=self.get_queryset(**kwargs))
        filter_.form.helper = FormHelper()
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalite_enseignants_gestion'):
            exclude_.append('edit')
        if not self.request.user.has_perm('scolar.fonctionnalite_enseignants_suppression'):
            exclude_.append('admin') 
        private=False
        if not self.request.user.is_authenticated:
            private=True
        else :
            private= not self.request.user.has_perm('scolar.fonctionnalite_enseignants_visualisationsensible') 
        exclude_=[]
        if private:
            exclude_.append('tel') 
            
        if not activation_google_agenda() :
            exclude_.append('edt')
        table = EnseignantTable(filter_.qs, exclude=exclude_)
        
        RequestConfig(self.request).configure(table)
        context['filter'] = filter_
        context['table'] = table
        context['titre'] = 'Liste des enseignants'
        context['back'] = reverse('home')
        if self.request.user.has_perm('scolar.fonctionnalite_enseignants_gestion'):
            context['create_url'] = reverse('enseignant_create')
            context['create_btn'] = 'Enseignant'
            context['import_url'] = reverse('enseignant_import')
            context['import_btn'] = 'Importer'
        if self.request.user.has_perm('scolar.fonctionnalite_enseignants_export') :
            context['export_url'] = reverse('export_enseignant_list')+"?"+self.request.GET.urlencode()
            context['export_btn'] = 'Exporter'
        return context


class PublicEnseignantListView(TemplateView): 
    template_name = 'scolar/filter_list.html'

    def get_queryset(self, **kwargs):
        return Enseignant.objects.filter(public_profile=True).order_by('nom', 'prenom')

    def get_context_data(self, **kwargs):
        context = super(PublicEnseignantListView, self).get_context_data(**kwargs)
        filter_ = EnseignantFilter(self.request.GET, queryset=self.get_queryset(**kwargs))
        filter_.form.helper = FormHelper()
        private=False
        if not self.request.user.is_authenticated:
            private=True
        else :
            private= not self.request.user.has_perm('scolar.fonctionnalite_enseignants_visualisationsensible') 
        exclude_=[]
        if private:
            exclude_.append('tel') 
        exclude_.append('edt')
        exclude_.append('bal')
        exclude_.append('eps')
        exclude_.append('edit')
        exclude_.append('situation')
        exclude_.append('admin') 
        table = EnseignantTable(filter_.qs, exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['filter'] = filter_
        context['table'] = table
        context['back'] = reverse('home')
        messages.warning(self.request, "N'apparaîtront ici que les enseignants ayant choisi de rendre leur profil public.")
        context['titre'] = 'Liste des enseignants'
        
        return context
    
class EnseignantEDTView(TemplateView):
    template_name='scolar/enseignant_edt.html'

    def get_context_data(self, **kwargs):
        context=super(EnseignantEDTView, self).get_context_data(**kwargs)
        enseignant_=get_object_or_404(Enseignant, id=self.kwargs.get('enseignant_pk'))
        context['enseignant']=enseignant_
        return context   

class EnseignantCreateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, CreateView):
    model = Enseignant
    fields = ['user', 'nom', 'prenom','eps', 'nom_a', 'prenom_a', 'eps_a', 'sexe','date_naissance','date_embauche','statut', 'tel', 'grade', 'charge_statut', 'situation', 'bureau', 'bal', 'webpage','edt','photo','public_profile','bio','publications', 'matricule', 'organisme']
    template_name = 'scolar/create.html'
    permission_required = 'scolar.fonctionnalite_enseignants_gestion'
    success_message = "L'enseignant a été ajouté avec succès!"
        
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.fields['user']=forms.ModelChoiceField(
                queryset=User.objects.filter(Q(enseignant__isnull=True)).order_by('username'),
                label=u"Utilisateur de la plateforme",
                widget=ModelSelect2Widget(
                        model=User,
                        search_fields=['username__icontains', 'email__icontains'],
    
                    ),
                help_text = "Tapez le nom d'utilisateur ou une partie du nom d'utilisateur pour faire une recherche",
                required = False
            )
        form.fields['date_naissance']=forms.DateField(input_formats = settings.DATE_INPUT_FORMATS, widget=DatePickerInput(format='%d/%m/%Y'), required=False)
        form.fields['date_embauche']=forms.DateField(input_formats = settings.DATE_INPUT_FORMATS, widget=DatePickerInput(format='%d/%m/%Y'), required=False)        
        form.fields['charge_statut'].disabled=not (activation_charges())
        if not activation_charges() :
            form.fields['charge_statut'].help_text = "Les charges sont désactivées via les paramètres de la plateforme."
        form.fields['edt']=forms.CharField(required=False, disabled=not (activation_charges()))
        if not activation_google_agenda() :
            form.fields['edt'].help_text = "Les emplois du temps Google Agenda sont désactivés via les paramètres de la plateforme."
        form.helper.add_input(Submit('submit','Ajouter', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('enseignant_list')
        return form

    def get_context_data(self, **kwargs):
        context = super(EnseignantCreateView, self).get_context_data(**kwargs)
        context['titre'] = 'Ajouter un(e) enseignant(e)'
        return context

class EnseignantUpdateView(LoginRequiredMixin, UserPassesTestMixin, UpdateView):
    model = Enseignant
    fields = ['user', 'nom', 'prenom','eps', 'nom_a', 'prenom_a', 'eps_a', 'sexe','date_naissance','date_embauche', 'statut', 'tel', 'grade', 'charge_statut', 'situation', 'bureau', 'bal', 'webpage','edt','public_profile','bio','publications', 'matricule', 'organisme']
    template_name = 'scolar/update.html'
    success_message = "Votre profil a été mis à jour avec succès!"

    def test_func(self):   
        if self.request.user.has_perm('scolar.fonctionnalite_enseignants_gestion') or (self.request.user.is_enseignant() and (self.request.user.enseignant.id == int(self.kwargs.get("pk")))) :
            return True
        else :
            return False
        
    def get_form(self, form_class=None):
        enseignant_ = get_object_or_404(Enseignant, id=self.kwargs.get("pk"))  
        
        edit_restreint=not self.request.user.has_perm('scolar.fonctionnalite_enseignants_gestion')
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.fields['user']=forms.ModelChoiceField(
                queryset=User.objects.filter(Q(enseignant__id=enseignant_.id) | Q(enseignant__isnull=True)).order_by('username'),
                label=u"Utilisateur de la plateforme",
                widget=ModelSelect2Widget(
                        model=User,
                        search_fields=['username__icontains', 'email__icontains'],
    
                    ),
                help_text = "Tapez le nom d'utilisateur ou une partie du nom d'utilisateur pour faire une recherche" if not edit_restreint else "",
                required = False,
                initial=enseignant_.user,
                disabled=edit_restreint
            )
        form.fields['nom'].disabled=edit_restreint
        form.fields['prenom'].disabled=edit_restreint
        form.fields['eps'].disabled=edit_restreint
        form.fields['nom_a'].disabled=edit_restreint
        form.fields['prenom_a'].disabled=edit_restreint
        form.fields['eps_a'].disabled=edit_restreint
        form.fields['sexe'].disabled=edit_restreint
        form.fields['date_naissance']=forms.DateField(input_formats = settings.DATE_INPUT_FORMATS, widget=DatePickerInput(format='%d/%m/%Y'), disabled=edit_restreint, required=False)
        form.fields['date_embauche']=forms.DateField(input_formats = settings.DATE_INPUT_FORMATS, widget=DatePickerInput(format='%d/%m/%Y'), disabled=edit_restreint, required=False)        
        form.fields['statut'].disabled=edit_restreint
        form.fields['tel'].disabled=edit_restreint
        form.fields['grade'].disabled=edit_restreint
        form.fields['charge_statut'].disabled=edit_restreint or not (activation_charges())
        if not activation_charges() :
            form.fields['charge_statut'].help_text = "Les charges sont désactivées via les paramètres de la plateforme."
        form.fields['situation'].disabled=edit_restreint
        form.fields['edt']=forms.CharField(disabled=edit_restreint or (not activation_google_agenda()), widget=forms.Textarea, required=False)
        if not activation_google_agenda() :
            form.fields['edt'].help_text = "Les emplois du temps Google Agenda sont désactivés via les paramètres de la plateforme."
        form.fields['publications'].help_text = "Si vous renseignez une URL pour DBLP, elle sera affichée dans votre profil dans un nouvel onglet."
        form.fields['matricule'].disabled = edit_restreint
        form.fields['organisme'].disabled=edit_restreint
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('enseignant_detail',kwargs={'pk': self.kwargs.get('pk')})
        return form 

class EnseignantDeleteView(LoginRequiredMixin, PermissionRequiredMixin, DeleteView):
    model = Enseignant
    template_name = 'scolar/delete.html'
    permission_required = 'scolar.fonctionnalite_enseignants_suppression'

    def delete(self, *args, **kwargs):
        enseignant_=self.get_object()
        trace_create(self.request.user, enseignant_, "Suppression de l'enseignant "+str(enseignant_))
        return super(EnseignantDeleteView, self).delete(*args, **kwargs)
        
    def get_success_url(self):
        messages.success(self.request, "L'enseignant a bien été supprimé!")
        return reverse('enseignant_list')
        
class EnseignantPhotoUpdateView(LoginRequiredMixin, UserPassesTestMixin, UpdateView):
    model = Enseignant
    fields = ['photo']
    template_name = 'scolar/update.html'
    success_message = "Votre photo a été mise à jour avec succès!"

    def test_func(self):   
        if self.request.user.has_perm('scolar.fonctionnalite_enseignants_gestion') or (self.request.user.is_enseignant() and (self.request.user.enseignant.id == int(self.kwargs.get("pk")))) :
            return True
        else :
            return False
        
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('enseignant_detail',kwargs={'pk': self.kwargs.get('pk')})
        return form 


class EnseignantDetailView(UserPassesTestMixin, DetailView):
    model = Enseignant
    template_name = 'scolar/enseignant_detail.html'

    def test_func(self):
        enseignant_=get_object_or_404(Enseignant, id=self.kwargs.get("pk"))
        doctorant_qs=Doctorant.objects.filter(enseignant=enseignant_)
        if enseignant_.public_profile :
            return True
        elif not self.request.user.is_authenticated :
            return False
        elif self.request.user.has_perm('scolar.fonctionnalitenav_postgraduation_visualisationdoctorants') and doctorant_qs.exists() :
            return True
        elif self.request.user.has_perm_or_teacher_himself('scolar.fonctionnalitenav_enseignants_annuairecomplet', enseignant_.id) :
            return True
        elif enseignant_.acces_profil_candidature(self.request.user) :
            return True
        else :
            return False
    def get_context_data(self, **kwargs):
        context = super(EnseignantDetailView, self).get_context_data(**kwargs)
        enseignant_=context['object']
        private=False
        if not self.request.user.is_authenticated:
            private=True
        else :
            private= not (self.request.user.has_perm_or_teacher_himself('scolar.fonctionnalite_enseignants_visualisationsensible', enseignant_) or (self.request.user.has_perm('scolar.fonctionnalite_postgraduation_visualisationsensibledoctorants') and enseignant_.is_doctorant()))
        context['private'] = private 
       
        exclude_=[]
        if private:
            exclude_.append('detail')
        if not self.request.user.is_authenticated:
            exclude_.append('edit')
        elif not self.request.user.has_perm('scolar.fonctionnalite_enseignants_gestion'):
            exclude_.append('edit')
        titre='Informations Enseignant'
        context['titre'] = titre        
        module_list = Module.objects.filter(Q(activite__assuree_par=enseignant_)&(Q(activite__type='C')|Q(activite__type='TD')|Q(activite__type='TP')|Q(activite__type='P'))).distinct() 
        modules_sans_doublon=module_list
        annees_matieres={}       
        for module_ in module_list :
            if not module_.formation.annee_univ in annees_matieres :
                annees_matieres[module_.formation.annee_univ]=[]
            if not module_.matiere in annees_matieres[module_.formation.annee_univ] :
                annees_matieres[module_.formation.annee_univ].append(module_.matiere)
            else :
                modules_sans_doublon=modules_sans_doublon.exclude(id=module_.id)
        modules_sans_doublon=modules_sans_doublon.annotate(enseignant=F('activite__assuree_par__id'), annee=F('formation__annee_univ__annee_univ')).order_by('-formation__annee_univ__annee_univ')   
        modules_sans_doublon_=EnseignementsTable(modules_sans_doublon, exclude=exclude_)      
        RequestConfig(self.request, paginate=False).configure(modules_sans_doublon_)
        context['modules'] = modules_sans_doublon_
        encadrementsPFE_ = Activite.objects.filter(assuree_par=enseignant_).filter(Q(type='PFE_Enc')&Q(cible__pfe__isnull=False)).distinct().order_by('-module__formation__annee_univ__annee_univ')
        activite_ = EncadrementsTable(encadrementsPFE_, orderable = False)     
        RequestConfig(self.request, paginate=False).configure(activite_)     
        context['encadrementsPFE'] = activite_
        if encadrementsPFE_.exists() :
            context['pfe_encadr'] = True
        else :
            context['pfe_encadr'] = False                   
        encadrementsmaster_ = Activite.objects.filter(assuree_par=enseignant_).filter(Q(type='Mem_Enc')&Q(cible__pfe__isnull=False)).distinct().order_by('-module__formation__annee_univ__annee_univ')           
        activiteM_ = EncadrementsTable(encadrementsmaster_, orderable = False)
        RequestConfig(self.request, paginate=False).configure(activiteM_)
        context['encadrementsMaster'] = activiteM_
        if encadrementsmaster_.exists() :
            context['master_encadr'] = True
        else :
            context['master_encadr'] = False
            
        liste_urls_publications={}
        if enseignant_.publications :
            liste_urls=enseignant_.publications.replace('\n', '').split('\r')
            cpt_urls_other=0
            for url in liste_urls :
                if not url in liste_urls_publications.values() :
                    if urllib.parse.urlparse(f"{url}").hostname == "dblp.org":
                        if not 'DBLP' in liste_urls_publications  :
                            liste_urls_publications['DBLP']=url
                            context['DBLP']=url
                    elif url.startswith('http://scholar.google.') or url.startswith('https://scholar.google.'):
                        if not 'Google Scholar' in liste_urls_publications :
                            liste_urls_publications['Google Scholar']=url
                    elif url.startswith('http://researchgate') or url.startswith('https://researchgate.') or url.startswith('http://www.researchgate.') or url.startswith('https://www.researchgate.'):
                        if not 'ResearchGate' in liste_urls_publications and not url in liste_urls_publications.values() :
                            liste_urls_publications['ResearchGate']=url 
                    else :
                        cpt_urls_other+=1
                        liste_urls_publications['Autre '+str(cpt_urls_other)]=url
                          
        if liste_urls_publications :
            context['publications']=liste_urls_publications
            
        
        
        projetsRecherche_ = Projet.objects.filter(Q(chef=enseignant_)|Q(membres__in=[enseignant_])).distinct().order_by('-annee_debut__annee_univ')           
        
        exclude_tableProjets=[]
        if not self.request.user.is_authenticated :
            exclude_tableProjets.append('edit')
        elif self.request.user.has_perm('scolar.fonctionnalite_postgraduation_gestionprojetsrecherche') :
            pass
        elif self.request.user.is_enseignant() and Projet.objects.filter(chef=self.request.user.enseignant).exists():
            pass
        else :
            exclude_tableProjets.append('edit') 
        tableProjets_ = ProjetsEnseignantTable(projetsRecherche_, orderable = False, enseignant=enseignant_, exclude=exclude_tableProjets)
        RequestConfig(self.request, paginate=False).configure(tableProjets_)
        context['projetsRecherche'] = tableProjets_
        if projetsRecherche_.exists() :
            context['projets_recherche'] = True
        else :
            context['projets_recherche'] = False
            
        equipeRecherche_ = EquipeRecherche.objects.filter(Q(responsable=enseignant_)|Q(membres__in=[enseignant_])).distinct()
        
        exclude_tableEquipe=[]
        if not self.request.user.is_authenticated :
            exclude_tableEquipe.append('edit')
        elif self.request.user.has_perm('scolar.fonctionnalite_postgraduation_gestionequipesrecherche') :
            pass
        elif self.request.user.is_enseignant() and EquipeRecherche.objects.filter(responsable=self.request.user.enseignant).exists():
            pass
        else :
            exclude_tableEquipe.append('edit')
            
        tableEquipe_ = EquipeRechercheEnseignantTable(equipeRecherche_, orderable = False, enseignant=enseignant_, exclude=exclude_tableEquipe)
        RequestConfig(self.request, paginate=False).configure(tableEquipe_)
        context['equipeRecherche'] = tableEquipe_
        if equipeRecherche_.exists() :
            context['equipe_recherche'] = True
        else :
            context['equipe_recherche'] = False
                        
        context['grade']=dict(GRADE)[enseignant_.grade] if enseignant_.grade else '-'
        
        nom_=enseignant_.nom.lower().replace(' ', '_')
        prenom_=enseignant_.prenom.lower().replace(' ','_')
        context['canonical_profile_url']= reverse('redirect_canonical_enseignant_detail', kwargs={'ens_nom':nom_, 'ens_prenom':prenom_})
        
        if self.request.user.is_authenticated :
            if self.request.user.has_perm('scolar.fonctionnalite_enseignants_gestion') or (self.request.user.is_enseignant() and (self.request.user.enseignant.id == int(self.kwargs.get("pk")))) :
                context['edit']=True
        context['protocole_host']=settings.PROTOCOLE_HOST
                    
        return context

def canonical_redirect_enseignant_detail_view (request, ens_nom, ens_prenom):
    return HttpResponseRedirect(reverse('canonical_enseignant_detail', kwargs={'ens_nom':ens_nom, 'ens_prenom':ens_prenom}))

def canonical_enseignant_detail_view(request, ens_nom, ens_prenom):
    try:
        nom=ens_nom.replace('_',' ')
        prenom=ens_prenom.replace('_',' ')
        enseignant=Enseignant.objects.filter(nom__iexact=nom, prenom__iexact=prenom).first()
        if not enseignant :
            raise Http404
    except Exception as e: 
        if settings.DEBUG:
            raise e
        else:
            messages.error(request, "Aucun profil d'enseignant ne correspond à cette URL")
            return(reverse('public_enseignant_list'))
    return HttpResponseRedirect(reverse('enseignant_detail', kwargs={'pk':enseignant.id}))

@login_required
def export_enseignants_list(request):
    if not( request.user.has_perm('scolar.fonctionnalite_enseignants_export')):
        messages.error(request, "ERREUR: Vous n'êtes pas autorisés à exécuter cette opération")
        return redirect('/accounts/login/?next=%s' % request.path)
    try:
    # Create the HttpResponse object with the appropriate  header.
        filter = EnseignantFilter(request.GET, queryset=Enseignant.objects.all().order_by('nom', 'prenom'))
        enseignant_list=filter.qs
        
        header=['Nom', 'Eps', 'Prenom', 'NomA', 'EpsA', 'PrenomA', 'Sexe','Ddn', 'Dde', 
 'Grade', 'Situation', 'Tel', 'Bureau', 'Bal', 'Email', 'Charge','Matricule', 'Organisme']
        
        if not activation_charges() :
            header.remove('Charge')
       
        sheet=Dataset()
        sheet.headers = header    
        for enseignant_ in enseignant_list :
            row_=[]
            row_.append(enseignant_.nom)
            row_.append(enseignant_.eps if enseignant_.eps else '')
            row_.append(enseignant_.prenom)
            row_.append(enseignant_.nom_a if enseignant_.nom_a else '')
            row_.append(enseignant_.eps_a if enseignant_.eps_a else '')
            row_.append(enseignant_.prenom_a if enseignant_.prenom_a else '')
            row_.append(enseignant_.sexe if enseignant_.sexe else '')
            row_.append(enseignant_.date_naissance if enseignant_.date_naissance else '')
            row_.append(enseignant_.date_embauche if enseignant_.date_embauche else '')
            row_.append(enseignant_.grade if enseignant_.grade else '')
            row_.append(enseignant_.situation if enseignant_.situation else '')
            row_.append(enseignant_.tel if enseignant_.tel else '')
            row_.append(enseignant_.bureau if enseignant_.bureau else '')
            row_.append(enseignant_.bal if enseignant_.bal else '')    
            row_.append(enseignant_.get_email())
            if activation_charges() :
                row_.append(enseignant_.charge_statut if enseignant_.charge_statut else '')
            row_.append(enseignant_.matricule if enseignant_.matricule else '')   
            row_.append(enseignant_.organisme.sigle if enseignant_.organisme else '')  
            sheet.append(row_)            
        filename='Liste_Enseignants.xlsx'
        response = HttpResponse(content_type='application/vnd.ms-excel')
        response['Content-Disposition'] = 'attachment; filename='+filename+";"
        response.write(sheet.xlsx)
    except Exception :
        if settings.DEBUG: 
            raise Exception
        else :
            messages.error(request, "ERREUR: Il y a eu une erreur lors de l'export du fichier des Enseignants")      
    return response    
class EnseignantDocumentsListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name = 'scolar/enseignant_documents.html'
    def test_func(self):   
        return self.request.user.has_perm_or_teacher_himself('scolar.fonctionnalite_enseignants_documents', int(self.kwargs.get("pk")))
  
    def get_context_data(self, **kwargs):
        context = super(EnseignantDocumentsListView, self).get_context_data(**kwargs)
        enseignant_=get_object_or_404(Enseignant, id=self.kwargs.get("pk"))        
        documents={}
        document_config_qs=DocumentConfig.objects.filter(code="ATTESTATION_FONCTION")
        if document_config_qs.exists() and document_config_qs.first().actif:     
            if enseignant_.situation == 'A' :
                documents["Attestation de fonction "+str(enseignant_)]=reverse("attestation_fonction_pdf", kwargs={'enseignant_pk':enseignant_.id})
        document_config_qs=DocumentConfig.objects.filter(code="ATTESTATION_ENCADREMENTS")
        if document_config_qs.exists() and document_config_qs.first().actif:          
            encadrements_ = Activite.objects.filter(assuree_par=enseignant_).filter((Q(type='Mem_Enc')|Q(type='PFE_Enc'))&Q(cible__pfe__isnull=False))          
            if encadrements_.exists() :      
                documents["Attestation d'encadrements "+str(enseignant_)]=reverse("attestation_encadrements_pdf", kwargs={'enseignant_pk':enseignant_.id})
        document_config_qs=DocumentConfig.objects.filter(code="ATTESTATION_SOUTENANCES")
        if document_config_qs.exists() and document_config_qs.first().actif:  
            soutenances_ = Activite.objects.filter(assuree_par=enseignant_).filter((Q(type='PFE_Sout')|Q(type='Mem_Sout'))&Q(cible__pfe__isnull=False))          
            if soutenances_.exists() :      
                documents["Attestation de participation à des jurys de soutenance "+str(enseignant_)]=reverse("attestation_soutenances_pdf", kwargs={'enseignant_pk':enseignant_.id})
        document_config_qs=DocumentConfig.objects.filter(code="ATTESTATION_EXPERTISES_PFE")
        if document_config_qs.exists() and document_config_qs.first().actif:          
            expertisesPFE_ = PFE.objects.filter(Q(~Q(validations__avis='X')), type='P', groupe__section__formation__programme__matiere_equipe__isnull=True, validations__expert=enseignant_).distinct().order_by('-id')          
            if expertisesPFE_.exists() :      
                documents["Attestation d'expertises des sujets de PFE "+str(enseignant_)]=reverse("attestation_expertises_pfe_pdf", kwargs={'enseignant_pk':enseignant_.id})        
        context['documents']=documents
        context['titre'] = 'Documents de '+str(enseignant_)
        return context
      
class EnseignantAttestationFonctionPDFView(LoginRequiredMixin, UserPassesTestMixin, PDFTemplateView):
    template_name = 'scolar/attestation_fonction_pdf.html'
    def test_func(self):   
        return self.request.user.has_perm_or_teacher_himself('scolar.fonctionnalite_enseignants_documents', int(self.kwargs.get("enseignant_pk")))
   
    def get_context_data(self, **kwargs):
        context = super(EnseignantAttestationFonctionPDFView, self).get_context_data(**kwargs)
        enseignant_=get_object_or_404(Enseignant, id=self.kwargs.get("enseignant_pk"))        
        self.filename = str(enseignant_)+'_Attestation_Fonction.pdf'
        context['enseignant'] = enseignant_
        context['grade']=dict(GRADE)[enseignant_.grade] if enseignant_.grade else '-'
        context['today']=datetime.date.today()
        sexe = enseignant_.sexe
        gender_ = False
        if sexe == "M" : 
            gender_= True
        context['gender']= gender_        
        return context   
 
class EnseignantAttestationEncadrementsPDFView(LoginRequiredMixin, UserPassesTestMixin, PDFTemplateView):
    template_name = 'scolar/attestation_encadrements_pdf.html'
   
    def test_func(self):   
        return self.request.user.has_perm_or_teacher_himself('scolar.fonctionnalite_enseignants_documents', int(self.kwargs.get("enseignant_pk")))
   
    def get_context_data(self, **kwargs):
        context = super(EnseignantAttestationEncadrementsPDFView, self).get_context_data(**kwargs)
        enseignant_=get_object_or_404(Enseignant, id=self.kwargs.get("enseignant_pk"))        
        self.filename = str(enseignant_)+'_Attestation_Encadrements.pdf'
        context['enseignant'] = enseignant_
        context['grade']=dict(GRADE)[enseignant_.grade] if enseignant_.grade else '-'
        context['today']=datetime.date.today()
        sexe = enseignant_.sexe
        gender_ = False
        if sexe == "M" : 
            gender_= True
        context['gender']= gender_
        module_list = Module.objects.filter(Q(activite__assuree_par=enseignant_)&(Q(activite__type='C')|Q(activite__type='TD')|Q(activite__type='TP')|Q(activite__type='P'))).distinct() 
        modules_sans_doublon=module_list
        annees_matieres={}       
        for module_ in module_list :
            if not module_.formation.annee_univ in annees_matieres :
                annees_matieres[module_.formation.annee_univ]=[]
            if not module_.matiere in annees_matieres[module_.formation.annee_univ] :
                annees_matieres[module_.formation.annee_univ].append(module_.matiere)
            else :
                modules_sans_doublon=modules_sans_doublon.exclude(id=module_.id)
        modules_sans_doublon=modules_sans_doublon.annotate(enseignant=F('activite__assuree_par__id'), annee=F('formation__annee_univ__annee_univ')).order_by('-formation__annee_univ__annee_univ')   
        modules_sans_doublon_=EnseignementsTable(modules_sans_doublon)      
        RequestConfig(self.request, paginate=False).configure(modules_sans_doublon_)
        context['modules'] = modules_sans_doublon_
        encadrementsPFE_ = Activite.objects.filter(assuree_par=enseignant_).filter(Q(type='PFE_Enc')&Q(cible__pfe__isnull=False)).distinct().order_by('-module__formation__annee_univ__annee_univ')
        activite_ = EncadrementsAttestationTable(encadrementsPFE_, orderable = False)         
        RequestConfig(self.request, paginate=False).configure(activite_)     
        context['encadrementsPFE'] = activite_
        if encadrementsPFE_.all() :
            context['pfe_encadr'] = True
        else :
            context['pfe_encadr'] = False        
        encadrementsmaster_ = Activite.objects.filter(assuree_par=enseignant_).filter(Q(type='Mem_Enc')&Q(cible__pfe__isnull=False)).distinct().order_by('-module__formation__annee_univ__annee_univ')           
        activiteM_ = EncadrementsAttestationTable(encadrementsmaster_, orderable = False)
        RequestConfig(self.request, paginate=False).configure(activiteM_)
        context['encadrementsMaster'] = activiteM_
        if encadrementsmaster_.all() :
            context['master_encadr'] = True
        else :
            context['master_encadr'] = False
        return context    

class EnseignantAttestationSoutenancesPDFView(LoginRequiredMixin, UserPassesTestMixin, PDFTemplateView):
    template_name = 'scolar/attestation_soutenances_pdf.html'
    
    def test_func(self):   
        return self.request.user.has_perm_or_teacher_himself('scolar.fonctionnalite_enseignants_documents', int(self.kwargs.get("enseignant_pk")))
   
    def get_context_data(self, **kwargs):
        context = super(EnseignantAttestationSoutenancesPDFView, self).get_context_data(**kwargs)
        enseignant_=get_object_or_404(Enseignant, id=self.kwargs.get("enseignant_pk"))        
        self.filename = str(enseignant_)+'_Attestation_Soutenances.pdf'
        context['enseignant'] = enseignant_
        context['grade']=dict(GRADE)[enseignant_.grade] if enseignant_.grade else '-'
        context['today']=datetime.date.today()
        sexe = enseignant_.sexe
        gender_ = False
        if sexe == "M" : 
            gender_= True
        context['gender']= gender_
        module_list = Module.objects.filter(Q(activite__assuree_par=enseignant_)&(Q(activite__type='C')|Q(activite__type='TD')|Q(activite__type='TP')|Q(activite__type='P'))).distinct() 
        modules_sans_doublon=module_list
        annees_matieres={}       
        for module_ in module_list :
            if not module_.formation.annee_univ in annees_matieres :
                annees_matieres[module_.formation.annee_univ]=[]
            if not module_.matiere in annees_matieres[module_.formation.annee_univ] :
                annees_matieres[module_.formation.annee_univ].append(module_.matiere)
            else :
                modules_sans_doublon=modules_sans_doublon.exclude(id=module_.id)
        modules_sans_doublon=modules_sans_doublon.annotate(enseignant=F('activite__assuree_par__id'), annee=F('formation__annee_univ__annee_univ')).order_by('-formation__annee_univ__annee_univ')   
        modules_sans_doublon_=EnseignementsTable(modules_sans_doublon)      
        RequestConfig(self.request, paginate=False).configure(modules_sans_doublon_)
        context['modules'] = modules_sans_doublon_
        soutenancesPFE_ = Activite.objects.filter(assuree_par=enseignant_).filter(Q(type='PFE_Sout')&Q(cible__pfe__isnull=False)).distinct().order_by('-module__formation__annee_univ__annee_univ') 
        activite_ = SoutenancesAttestationTable(soutenancesPFE_, orderable = False, enseignant=enseignant_)  
        RequestConfig(self.request, paginate=False).configure(activite_)     
        context['soutenancesPFE'] = activite_ 
        if soutenancesPFE_.exists() :
            context['pfe_sout'] = True
        else :
            context['pfe_sout'] = False
        soutenancesmaster_ = Activite.objects.filter(assuree_par=enseignant_).filter(Q(type='Mem_Sout')&Q(cible__pfe__isnull=False)).distinct().order_by('-module__formation__annee_univ__annee_univ')  
        activiteM_ = SoutenancesAttestationTable(soutenancesmaster_, orderable = False, enseignant=enseignant_)
        RequestConfig(self.request, paginate=False).configure(activiteM_)
        context['soutenancesMaster'] = activiteM_
        if soutenancesmaster_.exists() :
            context['master_sout'] = True
        else :
            context['master_sout'] = False
        soutenancesEQP_ = Activite.objects.filter(assuree_par=enseignant_).filter(Q(type='EQP_Sout')&Q(cible__pfe__isnull=False)).distinct().order_by('-module__formation__annee_univ__annee_univ')  
        activiteEQP_ = SoutenancesAttestationTable(soutenancesEQP_, orderable = False, enseignant=enseignant_)
        RequestConfig(self.request, paginate=False).configure(activiteEQP_)
        context['soutenancesEQP'] = activiteEQP_
        if soutenancesEQP_.exists() :
            context['eqp_sout'] = True
        else :
            context['eqp_sout'] = False                           
        return context    
    
    
class EnseignantAttestationExpertisesPFEPDFView(LoginRequiredMixin, UserPassesTestMixin, PDFTemplateView):
    template_name = 'scolar/attestation_expertises_pfe_pdf.html'
   
    def test_func(self):   
        return self.request.user.has_perm_or_teacher_himself('scolar.fonctionnalite_enseignants_documents', int(self.kwargs.get("enseignant_pk")))
   
    def get_context_data(self, **kwargs):
        context = super(EnseignantAttestationExpertisesPFEPDFView, self).get_context_data(**kwargs)
        enseignant_=get_object_or_404(Enseignant, id=self.kwargs.get("enseignant_pk"))        
        self.filename = str(enseignant_)+'_Attestation_Expertises_PFE.pdf'
        context['enseignant'] = enseignant_
        context['grade']=dict(GRADE)[enseignant_.grade] if enseignant_.grade else '-'
        context['today']=datetime.date.today()
        sexe = enseignant_.sexe
        gender_ = False
        if sexe == "M" : 
            gender_= True
        context['gender']= gender_
 
        expertisesPFE_ = PFE.objects.filter(Q(~Q(validations__avis='X')), type='P', groupe__section__formation__programme__matiere_equipe__isnull=True, validations__expert=enseignant_).distinct().order_by('-id')
        table_ = ExpertisesPFEAttestationTable(expertisesPFE_, orderable = False, enseignant=enseignant_)         
        RequestConfig(self.request, paginate=False).configure(table_)     
        context['expertisesPFE'] = table_
        return context
        
            
class PublicEtudiantListView(TemplateView):
    template_name = 'scolar/filter_list.html'
    
    def get_queryset(self, **kwargs):
        return Etudiant.objects.filter(public_profile=True).order_by('nom', 'prenom').annotate(rang_min=Min('inscriptions__rang'))

    def get_context_data(self, **kwargs):
        context = super(PublicEtudiantListView, self).get_context_data(**kwargs)
        filter_ = EtudiantFilter(self.request.GET, queryset=self.get_queryset(**kwargs))
        filter_.form.helper = FormHelper()
        private=False
        if not self.request.user.is_authenticated:
            private=True
        else :

            private= not self.request.user.has_perm('scolar.fonctionnalite_etudiants_visualisationsensible') 
        exclude_=[]
        if private:
            exclude_.append('date_naissance')
            exclude_.append('tel')
        
        table = EtudiantTable(filter_.qs, exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['filter'] = filter_
        context['table'] = table
        context['back'] = reverse('home')
        btn_list={}
        if self.request.user.is_authenticated:
            if self.request.user.has_perm('scolar.fonctionnalite_etudiants_gestion'):
                btn_list['+ Créer Etudiant']=reverse('etudiant_create')    
                btn_list['Import Etudiants']=reverse('etudiants_import')               
                btn_list['Import Tutorats']=reverse('tutorats_import')
                btn_list['Import Inscriptions']=reverse('inscriptions_import')
                btn_list['Import Affectations Groupes']=reverse('import_affectation_groupe')
                btn_list['Modification des matricules en lot']=reverse('etudiants_matricule_batch_update')
            if self.request.user.has_perm('scolar.fonctionnalite_etudiants_export'):
                context['export_url']=reverse('export_etudiant_list')+"?"+self.request.GET.urlencode()
                context['export_btn'] = 'Exporter les étudiants'
            
            context['btn_list']=btn_list
        else:
            messages.warning(self.request, "N'apparaîtront ici que les étudiants ayant choisi de rendre leur profil public.")
            messages.info(self.request, "Pour consulter plus de profils, merci de vous connecter à votre compte.")
        context['titre'] = 'Liste des étudiants'
        return context

class EtudiantListView(LoginRequiredMixin, PermissionRequiredMixin, PublicEtudiantListView):
    permission_required = 'scolar.fonctionnalitenav_etudiants_annuairecomplet'
    
    def get_queryset(self, **kwargs):
        return Etudiant.objects.all().order_by('nom', 'prenom').annotate(rang_min=Min('inscriptions__rang'))

class EtudiantInscriptionListView(LoginRequiredMixin, PermissionRequiredMixin, TemplateView):
    
    template_name = 'scolar/list.html'
    permission_required = 'scolar.fonctionnalitenav_etudiants_annuairecomplet'
    
    def get_context_data(self, **kwargs):
        context = super(EtudiantInscriptionListView, self).get_context_data(**kwargs)
        etudiant_=Etudiant.objects.get(matricule=self.kwargs.get('etudiant_pk'))
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalite_etudiants_gestion'):
            exclude_.append('edit')
            exclude_.append('admin') 
        parcours = InscriptionEtudiantTable(Inscription.objects.filter(etudiant=etudiant_).order_by('formation__annee_univ'), exclude=exclude_)
        RequestConfig(self.request).configure(parcours)
        context['table'] = parcours
        context['titre']= 'Parcours de %s' % str(etudiant_)
        context['back'] = reverse('etudiant_list')
        if self.request.user.has_perm('scolar.fonctionnalite_etudiants_gestion'):
            context['create_url'] = reverse('inscription_create', kwargs={'etudiant_pk': etudiant_.matricule})
            context['create_btn'] = 'Inscription'
            
            
        
        return context

@login_required
def groupe_list_export_view(request, groupe_pk, periode_pk):
    groupe_enseigne=get_object_or_404(Groupe, id=groupe_pk)
    if groupe_enseigne.is_equipe() and request.user.has_perm('scolar.fonctionnalitenav_stages_visualisationsoutenancesequipes') :
        pass
    elif request.user.has_perm('scolar.fonctionnalitenav_etudiants_groupes') or request.user.has_perm('scolar.fonctionnalitenav_etudiants_annuairecomplet') :
        pass
    elif request.user.is_enseignant() :
        mes_activites=Activite.objects.filter(assuree_par__in=[request.user.enseignant]).exclude(type__startswith='E_')
        mes_groupes=[]
        for activite_ in mes_activites:
            for groupe_ in activite_.cible.all():
                if groupe_.code :
                    mes_groupes.append(groupe_.id)
                else:
                    section_=groupe_.section
                    for groupe_ in section_.groupes.filter(code__isnull=False):
                        mes_groupes.append(groupe_.id)
        return (groupe_enseigne in Groupe.objects.filter(section__formation__annee_univ__encours=True, id__in=mes_groupes))
    else :
        redirect('/accounts/login/?next=%s' % request.path)    
    
    try:
        # Create the HttpResponse object with the appropriate CSV header.
        groupe=get_object_or_404(Groupe, id=groupe_pk)
        periode=get_object_or_404(PeriodeProgramme, id=periode_pk)
        inscription_list=Inscription.objects.filter(inscription_periodes__groupe=groupe_pk, inscription_periodes__periodepgm=periode_pk).order_by('etudiant__nom', 'etudiant__prenom')
        header=['Matricule','Email', 'Nom','Prenom', 'Situation',]
        sheet=Dataset()
        sheet.headers = header
    
        for inscrit_ in inscription_list :
            row_=[]
            row_.append(inscrit_.etudiant.matricule)
            row_.append(inscrit_.etudiant.get_email())
            row_.append(inscrit_.etudiant.nom)
            row_.append(inscrit_.etudiant.prenom)
            row_.append("Maladie" if inscrit_.decision_jury.startswith("M") else dict(DECISIONS_JURY)[inscrit_.decision_jury])
            sheet.append(row_)
            
        filename=str(groupe)+'_'+str(periode.periode.code)+'.xlsx'
        filename=filename.replace(' ','_')

        response = HttpResponse(content_type='application/vnd.ms-excel')
        response['Content-Disposition'] = 'attachment; filename='+filename+";"
        response.write(sheet.xlsx)
    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            messages.error(request, "ERREUR: Il y a eu une erreur lors de l'export du fichier des étudiants. Merci de le signaler à l'administrateur.")
    return response



class EtudiantGroupeListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name = 'scolar/list.html'
    
    def test_func(self):
        groupe_enseigne=get_object_or_404(Groupe, id=self.kwargs.get('groupe_pk'))
        if groupe_enseigne.is_equipe() and self.request.user.has_perm('scolar.fonctionnalitenav_stages_visualisationsoutenancesequipes') :
            return True
        elif self.request.user.has_perm('scolar.fonctionnalitenav_etudiants_groupes') or self.request.user.has_perm('scolar.fonctionnalitenav_etudiants_annuairecomplet') :
            return True
        elif self.request.user.is_enseignant() :
            mes_activites=Activite.objects.filter(assuree_par__in=[self.request.user.enseignant]).exclude(type__startswith='E_')
            mes_groupes=[]
            for activite_ in mes_activites:
                for groupe_ in activite_.cible.all():
                    if groupe_.code :
                        mes_groupes.append(groupe_.id)
                    else:
                        section_=groupe_.section
                        for groupe_ in section_.groupes.filter(code__isnull=False):
                            mes_groupes.append(groupe_.id)
            return (groupe_enseigne in Groupe.objects.filter(section__formation__annee_univ__encours=True, id__in=mes_groupes))
        else :
            return False    
        
    def get_queryset(self, **kwargs):
        groupe_=get_object_or_404(Groupe, id=self.kwargs.get('groupe_pk'))
        if groupe_.is_equipe() :
            return Inscription.objects.filter(id__in=groupe_.pfe.equipe.inscriptions.all())
        else :
            return Inscription.objects.filter(inscription_periodes__groupe=self.kwargs.get('groupe_pk'), inscription_periodes__periodepgm=self.kwargs.get('periode_pk')).order_by('etudiant__nom', 'etudiant__prenom')

    def get_context_data(self, **kwargs):
        context = super(EtudiantGroupeListView, self).get_context_data(**kwargs)
        self.groupe_=Groupe.objects.get(id=self.kwargs.get('groupe_pk'))
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalite_etudiants_gestion'):
            exclude_.append('edit')
            exclude_.append('admin') 
        table = InscriptionGroupeTable(self.get_queryset(**kwargs), exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['table'] = table
        context['titre'] = 'Liste des étudiants du groupe '+str(self.groupe_)
        #context['back'] = reverse('groupe_all_list')
        
        return context

def get_charge_context(enseignant_qs):
    context={}
    enseignant_list=enseignant_qs
    charges=Charge.objects.filter(annee_univ__encours=True)
    periode_list=Periode.objects.all()
    charge_list={}
    for enseignant_ in enseignant_list:
        charge_enseignement_semaine_periode=0
        charge_totale_periode=0
        for periode_ in periode_list :
            charge_enseignant=charges.filter(realisee_par=enseignant_, periode=periode_)
            charge_enseignant_activite=charge_enseignant.values('realisee_par','vh_eq_td','activite__module', 'activite__type').annotate(nb_activites=Count('activite__type'))
            charge_enseignement_semaine=0
            charge_detail=''
            charge_tot=0
            for charge_ in charge_enseignant_activite :
                if charge_['activite__module'] :
                    module_=get_object_or_404(Module, id=charge_['activite__module'])
                    charge_detail+=str(charge_['nb_activites'])+'x '+str(charge_['activite__type'])+' '+str(module_.matiere.code)+' '+str(charge_['vh_eq_td'])+'h<br>'
            for charge_ in charge_enseignant :
                if charge_.repeter_chaque_semaine:
                    charge_tot+=charge_.vh_eq_td*charge_.periode.nb_semaines
                else:
                    charge_tot+=charge_.vh_eq_td
                if not charge_.activite :
                    charge_detail+=dict(TYPE_CHARGE)[charge_.type]+' '+str(charge_.obs)+' '+str(charge_.vh)+'h <br>'
                if charge_.repeter_chaque_semaine:
                    charge_enseignement_semaine+=charge_.vh_eq_td
            charge_enseignement_semaine_periode+=charge_enseignement_semaine
            charge_totale_periode+=charge_tot
            charge_list[str(enseignant_.id)+'_semaine_%s' % str(periode_.code)]=charge_enseignement_semaine
            charge_list[str(enseignant_.id)+'_detail_%s' % str(periode_.code)]=charge_detail
            charge_list[str(enseignant_.id)+'_tot_%s' % str(periode_.code)]=charge_tot
        charge_list[str(enseignant_.id)+'_moy_semaine']=charge_enseignement_semaine_periode/periode_list.count()
        charge_list[str(enseignant_.id)+'_tot_an_prv']=charge_totale_periode
        charge_list[str(enseignant_.id)+'_tot_statut']=enseignant_.charge_statut
        charge_list[str(enseignant_.id)+'_tot_ratio']=round(100,2) if enseignant_.statut=='V' else round(charge_totale_periode/enseignant_.charge_statut*100,2) 
    context['periode_list'] = periode_list
    context['enseignant_list'] = enseignant_list
    context['charge_list'] = charge_list
    return context

@login_required
@permission_required('scolar.fonctionnalitenav_enseignants_visualisationcharges')
def charge_list_view(request):
    # if this is a POST request we need to process the form data

    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = ChargeFilterForm(request.POST)
        # check whether it's valid:
        if form.is_valid():
            form_data=form.cleaned_data
            enseignant_list=form_data['enseignant_list'] if form_data['enseignant_list'] else Enseignant.objects.filter(situation='A').order_by('nom','prenom').values_list('id')
            charge_inf=decimal.Decimal(form_data['charge_inf']) if form_data['charge_inf'] else 0 
            charge_sup=decimal.Decimal(form_data['charge_sup']) if form_data['charge_sup'] else 1000
            
            enseignant_filter=[]
            for enseignant in Enseignant.objects.filter(id__in=enseignant_list):
                if (enseignant.ratio_charge_annuelle_encours() <= charge_sup) and (enseignant.ratio_charge_annuelle_encours() >= charge_inf):
                    enseignant_filter.append(enseignant.id)
            qs=Enseignant.objects.filter(id__in=enseignant_filter)
            
            messages.success(request, "Le filtre a été appliqué avec succès. Ci-après la liste des charges demandée.")
    else:
        
        form = ChargeFilterForm()
        qs=Enseignant.objects.filter(situation='A').order_by('nom', 'prenom')
        messages.info(request, "Utilisez ce formulaire pour filtrer les charges selon les critères ci-après.")
    try:
        context=get_charge_context(qs)
    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            messages.error(request, "ERREUR: lors de la création de la table des charges par enseignant. Merci de le signaler à l'administrateur.")
    context['form']=form
    context['titre']="Liste des charges par enseignant"
    return render(request, 'scolar/charge_list.html', context)
    
class ChargeEnseignantView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name = 'scolar/charge_list.html'

    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalitenav_enseignants_visualisationcharges') or self.request.user.is_enseignant()

    def get_context_data(self, **kwargs):
        context = super(ChargeEnseignantView, self).get_context_data(**kwargs)
        try:
            context.update(get_charge_context(Enseignant.objects.filter(id=self.request.user.enseignant.id)))
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors de la génération de la liste des charges. Merci de le signaler à l'administrateur.")
        context['titre'] = "Synthèse de la charge de M./Mme "+str(self.request.user.enseignant)
        return context

class ChargeEnseignantDetailView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, TemplateView):
    template_name = 'scolar/list.html'

    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalitenav_enseignants_visualisationcharges') or (self.request.user.is_enseignant() and self.request.user.enseignant.id == int(self.kwargs.get('enseignant_pk')))
    
    def get_queryset(self, **kwargs):
        return Charge.objects.filter(annee_univ__encours=True, realisee_par=self.kwargs.get('enseignant_pk')).order_by('periode__ordre')

    def get_context_data(self, **kwargs):
        context = super(ChargeEnseignantDetailView, self).get_context_data(**kwargs)
        try:
            enseignant_=get_object_or_404(Enseignant, id=self.kwargs.get('enseignant_pk'))
            exclude_=[]
            if not self.request.user.has_perm('scolar.fonctionnalite_enseignants_gestioncharges'):
                exclude_.append('edit')
                exclude_.append('admin') 
            table = ChargeEnseignantTable(self.get_queryset(**kwargs), exclude=exclude_)
            RequestConfig(self.request).configure(table)
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors de la construction de la table des charges d'un enseignant!")
        context['titre'] = 'Charge détaillée de '+str(enseignant_)
        context['table'] = table
        if self.request.user.has_perm('scolar.fonctionnalite_enseignants_gestioncharges'):
            context['create_btn'] = "Charge"
            context['create_url'] = reverse('charge_enseignant_create', kwargs={'enseignant_pk':self.kwargs.get('enseignant_pk')})
            btn_list={}
            btn_list['Ajout Charge Selon Modèle']=reverse('charge_selon_config_create', kwargs={'enseignant_pk':self.kwargs.get('enseignant_pk')})
            context['btn_list']=btn_list
        context['back'] = reverse('charge_enseignant', kwargs={'enseignant_pk':self.kwargs.get('enseignant_pk')})
        return context
    
    
class ChargeEnseignantCreateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, CreateView):
    permission_required = 'scolar.fonctionnalite_enseignants_gestioncharges'
    model = Charge
    fields = ['type', 'obs', 'vh', 'vh_eq_td', 'annee_univ', 'periode', 'realisee_par', 'cree_par', 'repeter_chaque_semaine']
    template_name = 'scolar/create.html'
    success_message = "La charge a été rajoutée avec succès!"
    

    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        messages.info(self.request, "Utilisez ce formulaire pour renseigner une nouvelle charge!")
        messages.warning(self.request, "Attention! Pour les activités d'enseignement, merci de passer par la Planification pour éviter toute incohérence!")
        form.fields['annee_univ']=forms.ModelChoiceField(queryset=AnneeUniv.objects.filter(encours=True), initial=0, required=True)
        form.fields['realisee_par']=forms.ModelChoiceField(queryset = Enseignant.objects.all(), initial=self.kwargs.get('enseignant_pk'), required=True)
        if self.request.user.is_enseignant() :
            form.fields['cree_par']=forms.ModelChoiceField(queryset = Enseignant.objects.filter(id=self.request.user.enseignant.id), initial=0, required=True)
        form.helper.add_input(Submit('submit','Ajouter', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('charge_enseignant_detail', kwargs={'enseignant_pk':self.kwargs.get('enseignant_pk')})
        return form
    
    
    def get_context_data(self, **kwargs):
        context = super(ChargeEnseignantCreateView, self).get_context_data(**kwargs)
        titre='Créer une nouvelle charge'        
        context['titre'] = titre
        return context

def charge_batch_create_view(request):
    if not request.user.has_perm('scolar.fonctionnalite_enseignants_gestioncharges'):
        return redirect('/accounts/login/?next=%s' % request.path)
    
    # if this is a POST request we need to process the form data
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = ImportChargeForm(request.POST, request.FILES)
        # check whether it's valid:
        if form.is_valid():
            try:    
                charge_file = request.FILES['file']
                dataset = Dataset()
                imported_data = dataset.load(charge_file.read(), format ='xlsx')
                # la première ligne du fichier doit contenir des entêtes, au moins Nom, Prenom, Charge
                # insert imported_data in charge table
                form_data=form.cleaned_data
                annee_univ_=form_data['annee_univ']
                periode_=form_data['periode']
                type_=form_data['type']
                obs_=form_data['obs']
                repeter_chaque_semaine_=form_data['repeter_chaque_semaine']
                for row in imported_data.dict :
                    try:
                        if row.get('Prenom'):
                            enseignant_=get_enseignant_list_from_str(row['Nom']+' '+row['Prenom'], '+')[0]
                        else:
                            enseignant_=get_enseignant_list_from_str(row['Nom'], '+')[0]
                    except Exception:
                        messages.error(request, "L'enseignant "+row['Nom']+" n'existe pas, veuillez corriger le nom ou l'insérer dans la base")
                        continue
                    if row['Charge'] :
                        vh_=round(decimal.Decimal(str(row['Charge'])), 2)
                    else :
                        vh_=round(decimal.Decimal(0,2))
                    Charge.objects.create(
                        annee_univ=annee_univ_,
                        periode=periode_,
                        type=type_,
                        obs=obs_,
                        repeter_chaque_semaine=repeter_chaque_semaine_,
                        realisee_par=enseignant_,
                        cree_par=request.user.enseignant,
                        vh=vh_,
                        vh_eq_td=vh_,
                        )
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: L'importation des charges s'est terminée avec des erreurs." )
                    messages.info(request, "Indiquer le fichier .xlsx des charges à créer")
                    messages.info(request, "La première ligne du fichier doit comporter au moins les colonnes suivantes: Nom, Prenom, Charge")
                    render(request, 'scolar/import.html', {'form': form, 'titre':'Importer des Charges'})
            messages.success(request, "L'importation des charges a été réalisée avec succès!")
            # redirect to a new URL:
            return HttpResponseRedirect(reverse('charge_list')) 
    # if a GET (or any other method) we'll create a blank form
    else:
        form = ImportChargeForm()
        messages.info(request, "Indiquer le fichier .xlsx des charges à créer")
        messages.info(request, "La première ligne du fichier doit comporter au moins les colonnes suivantes: Nom, Prenom, Charge")
    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer des Charges'})

def charge_selon_config_create_view(request, enseignant_pk):
    if not request.user.has_perm('scolar.fonctionnalite_enseignants_gestioncharges'):
        return redirect('/accounts/login/?next=%s' % request.path)
    
    # if this is a POST request we need to process the form data
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = SelectChargeConfigForm(request.POST, request.FILES)
        # check whether it's valid:
        if form.is_valid():
            try:    
                form_data=form.cleaned_data
                charge_config_=form_data['charge_config']

                Charge.objects.create(
                    annee_univ=get_object_or_404(AnneeUniv, encours=True),
                    periode=form_data['periode'],
                    type=charge_config_.categorie,
                    obs=form_data['obs'],
                    repeter_chaque_semaine=charge_config_.repeter_chaque_semaine,
                    realisee_par=get_object_or_404(Enseignant, id=enseignant_pk),
                    cree_par=request.user.enseignant,
                    vh=charge_config_.vh,
                    vh_eq_td=charge_config_.vh_eq_td,
                    )
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: La création de charge selon modèle s'est terminée avec des erreurs. Merci de le signaler à l'administrateur" )
                    messages.info(request, "Indiquez le type de charge et les informations compélementaires demandées dans ce formulaire.")
                    render(request, 'scolar/import.html', {'form': form, 'titre':'Sélection charge selon modèle'})
            messages.success(request, "La création de charge a été réalisée avec succès!")
            # redirect to a new URL:
            return HttpResponseRedirect(reverse('charge_enseignant_detail', kwargs={'enseignant_pk':enseignant_pk})) 
    # if a GET (or any other method) we'll create a blank form
    else:
        form = SelectChargeConfigForm()
        messages.info(request, "Indiquez le type de charge et les informations compélementaires demandées dans ce formulaire.")
    return render(request, 'scolar/import.html', {'form': form, 'titre':'Sélection charge selon modèle'})



class ActiviteChargeConfigListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    
    template_name = 'scolar/list.html'
    
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalite_configurationetablissement_visualisation')

    def get_queryset(self, **kwargs):
        return ActiviteChargeConfig.objects.all().order_by('categorie','type')
    
    def get_context_data(self, **kwargs):
        context = super(ActiviteChargeConfigListView, self).get_context_data(**kwargs)
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalite_configurationetablissement_modification'):
            exclude_.append('edit')
            exclude_.append('admin') 
        table = ActiviteChargeConfigTable(self.get_queryset(**kwargs), exclude=exclude_)
        RequestConfig(self.request).configure(table)
        
        context['table'] = table
        context['titre'] = 'Liste des configurations de charges liées à des activités pédagogiques'
        context['back'] = reverse('settings')
        if self.request.user.has_perm('scolar.fonctionnalite_configurationetablissement_modification'):
            context['create_url'] = reverse('activite_charge_config_create')
            context['create_btn'] = 'Ajouter une configuration'
        
        return context

class ActiviteChargeConfigCreateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, CreateView):
    model = ActiviteChargeConfig
    template_name = 'scolar/create.html'
    permission_required = 'scolar.fonctionnalite_configurationetablissement_modification'
    success_message = "La configuration a été ajouté avec succès!"
    fields=['categorie', 'type', 'titre', 'vh', 'vh_eq_td', 'repeter_chaque_semaine', 'repartir_entre_intervenants']
        
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.helper.add_input(Submit('submit','Ajouter', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('settings')
        return form

    def get_context_data(self, **kwargs):
        context = super(ActiviteChargeConfigCreateView, self).get_context_data(**kwargs)
        context['titre'] = 'Ajouter une configuration'
        return context

class ActiviteChargeConfigUpdateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, UpdateView):
    model = ActiviteChargeConfig
    template_name = 'scolar/update.html'
    permission_required = 'scolar.fonctionnalite_configurationetablissement_modification'
    success_message = "La configuration a été modifié avec succès!"
    fields=['categorie','type', 'titre','vh', 'vh_eq_td', 'repeter_chaque_semaine', 'repartir_entre_intervenants']
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('settings')
        return form

class ActiviteChargeConfigDeleteView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, DeleteView):
    permission_required = 'scolar.fonctionnalite_configurationetablissement_modification'
    model = ActiviteChargeConfig
    template_name = 'scolar/delete.html'
    success_message = "La configuration a bien été supprimée."

    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression ActiviteChargeConfig : "+str(object_))
        return super(ActiviteChargeConfigDeleteView, self).delete(*args, **kwargs)
    
    def get_success_url(self):
        return reverse('settings')


def tutorat_import_view(request):
    if not request.user.has_perm('scolar.fonctionnalite_etudiants_gestion'):
        messages.error(request,"Vous n'avez pas les permissions pour effectuer cette opération.")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    # if this is a POST request we need to process the form data
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = ImportFileForm(request.POST, request.FILES)
        # check whether it's valid:
        if form.is_valid():
            try:    
                tutorat_file = request.FILES['file']
                dataset = Dataset()
                imported_data = dataset.load(tutorat_file.read(), format ='xlsx')
                # la première ligne du fichier doit contenir des entêtes, au moins Matricule, Enseignant
                # update Etudiant with tuteur
                for row in imported_data.dict :
                    try:
                        etudiant_=Etudiant.objects.get(matricule=str(row.get('Matricule')).strip())
                        enseignant_=get_enseignant_list_from_str(str(row.get('Enseignant')).strip(), '+')[0]
                    except Exception:
                        messages.error(request, "L'étudiant"+str(row.get('Matricule')).strip()+" ou l'enseignant "+row['Enseignant']+" n'existe pas, veuillez corriger le nom ou l'insérer dans la base")
                        continue
                    etudiant_.tuteur=enseignant_
                    etudiant_.save()
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: L'importation des tutorats s'est terminée avec des erreurs." )
                    messages.info(request, "Indiquer le fichier .xlsx des tutorat à créer")
                    messages.info(request, "La première ligne du fichier doit comporter au moins les colonnes suivantes: Matricule, Enseignant")
                    render(request, 'scolar/import.html', {'form': form, 'titre':'Importer des Tutorats'})
            messages.success(request, "L'importation des tutorats a été réalisée avec succès!")
            # redirect to a new URL:
            return HttpResponseRedirect(reverse('etudiant_list')) 
    # if a GET (or any other method) we'll create a blank form
    else:
        form = ImportFileForm()
        messages.info(request, "Indiquer le fichier .xlsx des tutorats à créer")
        messages.info(request, "La première ligne du fichier doit comporter au moins les colonnes suivantes: Matricule, Enseignant")
    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer des Tutorats'})

    

class ChargeEnseignantUpdateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, UpdateView):
    permission_required = 'scolar.fonctionnalite_enseignants_gestioncharges'
    model = Charge
    fields = ['type', 'obs', 'vh', 'vh_eq_td', 'annee_univ', 'periode', 'realisee_par', 'cree_par', 'repeter_chaque_semaine']
    template_name = 'scolar/update.html'
    success_message = "La charge a été modifiée avec succès!"

    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        charge_=get_object_or_404(Charge,id=self.kwargs.get('pk'))
        form.fields['annee_univ']=forms.ModelChoiceField(queryset=AnneeUniv.objects.filter(encours=True), initial=0, required=True)
        if self.request.user.is_enseignant():
            form.fields['cree_par']=forms.ModelChoiceField(queryset = Enseignant.objects.filter(id=self.request.user.enseignant.id), initial=0, required=True)
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('charge_enseignant_detail', kwargs={'enseignant_pk':charge_.realisee_par.id})
        return form    
    
class ChargeEnseignantDeleteView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, DeleteView):
    permission_required = 'scolar.fonctionnalite_enseignants_gestioncharges'
    model = Charge
    template_name = 'scolar/delete.html'
    success_message = "La charge a bien été supprimée."

    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression de la charge enseignant : "+str(object_))
        return super(ChargeEnseignantDeleteView, self).delete(*args, **kwargs)
    
    def get_success_url(self):
        return reverse('charge_enseignant_detail',kwargs={'enseignant_pk': self.kwargs.get('enseignant_pk')})
        
class ActiviteCreateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, CreateView):
    permission_required = 'scolar.fonctionnalitenav_planification_activites'
    model = Activite
    fields = ['type', 'module', 'cible', 'assuree_par', 'vh']
    template_name = 'scolar/create.html'
    success_message = "L'activité a été ajoutée avec succès!"
        
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        try:
            groupe_=get_object_or_404(Groupe, id=self.kwargs.get('groupe_pk'))
            module_=get_object_or_404(Module, id=self.kwargs.get('module_pk'))
            formation_=module_.formation
            form.helper = FormHelper()
            form.fields['module']=forms.ModelChoiceField(queryset=Module.objects.filter(id=module_.id), initial=0)
            form.fields['cible']=forms.ModelMultipleChoiceField(queryset = Groupe.objects.filter(section__formation__programme__ordre=formation_.programme.ordre, section__formation__annee_univ__encours=True), initial=Groupe.objects.filter(id=groupe_.id))
            
            form.fields['assuree_par']=forms.ModelMultipleChoiceField(
                queryset = Enseignant.objects.all().order_by('nom'),
                widget=ModelSelect2MultipleWidget(
                    model=Enseignant,
                    search_fields=['nom__icontains','prenom__icontains'],
                ),
                help_text = "Sélection multiple possible. Tapez le nom ou prénom de l'enseignant ou deux espaces pour avoir la liste complète.",

            )
            form.helper.add_input(Submit('submit','Ajouter', css_class='btn-primary'))
            form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
            self.success_url = reverse('planification_update', kwargs={'formation_pk': formation_.id,'periode_pk':module_.periode.id})
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors de l'ajout de l'activité. Merci de le signaler à l'administrateur.")
        return form
    
    def get_context_data(self, **kwargs):
        context = super(ActiviteCreateView, self).get_context_data(**kwargs)
        titre='Créer une nouvelle activité'        
        context['titre'] = titre
        return context


class ActiviteUpdateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, UpdateView):
    permission_required = 'scolar.fonctionnalitenav_planification_activites'
    model = Activite
    fields = ['type', 'module', 'cible', 'assuree_par', 'vh']
    template_name = 'scolar/update.html'
    success_message = "Activité modifiée avec succès!"
        
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        activite_=Activite.objects.get(id=self.kwargs.get('pk'))
        formation_=Formation.objects.get(id=self.kwargs.get('formation_pk'))
        form.fields['module']=forms.ModelChoiceField(queryset=Module.objects.filter(matiere__code=activite_.module.matiere.code, formation=activite_.module.formation), initial=activite_.module, disabled=False)
        form.fields['cible']=forms.ModelMultipleChoiceField(queryset = Groupe.objects.filter(section__formation__programme__ordre=formation_.programme.ordre, section__formation__annee_univ__encours=True), initial=activite_.cible, disabled=False)
        form.fields['assuree_par']=forms.ModelMultipleChoiceField(
            queryset = Enseignant.objects.all().order_by('nom'),
            widget=ModelSelect2MultipleWidget(
                model=Enseignant,
                search_fields=['nom__icontains','prenom__icontains'],
            ),
            help_text = "Sélection multiple possible. Tapez le nom ou prénom de l'enseignant ou deux espaces pour avoir la liste complète.",

        )
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('planification_update', kwargs={'formation_pk': str(self.kwargs.get('formation_pk')), 'periode_pk':str(self.kwargs.get('periode_pk'))})
        return form

class ActiviteDeleteView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, DeleteView):
    permission_required = 'scolar.fonctionnalitenav_planification_activites'
    model = Activite
    template_name = 'scolar/delete.html'
    success_message = "L'activité a bien été supprimée."

    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression de l'activité : "+str(object_))
        return super(ActiviteDeleteView, self).delete(*args, **kwargs)
    
    def get_success_url(self):
        return reverse('planification_update',kwargs={'formation_pk': str(self.kwargs.get('formation_pk')), 'periode_pk':str(self.kwargs.get('periode_pk'))})

class SpecialiteCreateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, CreateView):
    permission_required = 'scolar.fonctionnalitenav_pedagogie_gestionprogrammes'
    model = Specialite
    fields = ['code', 'intitule', 'intitule_a', 'title', 'concernee_par_pfe']
    template_name = 'scolar/create.html'
    success_message = "La spécialité a été bien créée."
     
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.helper.add_input(Submit('submit','Ajouter', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('programme_design')
        return form

    def get_context_data(self, **kwargs):
        context = super(SpecialiteCreateView, self).get_context_data(**kwargs)
        
        titre='Créer une Spécialité'        
        context['titre'] = titre
        return context

class SpecialiteUpdateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, UpdateView):
    permission_required = 'scolar.fonctionnalitenav_pedagogie_gestionprogrammes'
    model = Specialite
    fields = ['intitule', 'intitule_a', 'title', 'concernee_par_pfe']
    template_name = 'scolar/update.html'
    success_message = "La spécialité a été bien modifiée."
        
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-warning'))
        self.success_url = reverse('programme_design')
        return form

    def get_context_data(self, **kwargs):
        context = super(SpecialiteUpdateView, self).get_context_data(**kwargs)
        
        titre='Modifier la Spécialité'        
        context['titre'] = titre
        return context

class SpecialiteDeleteView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, DeleteView):
    model = Specialite
    template_name= 'scolar/delete.html'
    permission_required = 'scolar.fonctionnalitenav_pedagogie_gestionprogrammes'
    success_message = "La spécialitéa bien été supprimée."

    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression de la spécialité : "+str(object_))
        return super(SpecialiteDeleteView, self).delete(*args, **kwargs)
        
    def get_success_url(self):
        return reverse('programme_design')
    
class PlanificationListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    
    template_name = 'scolar/filter_list.html'
    
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalitenav_planification_activites')

    def get_queryset(self, **kwargs):
        return Formation.objects.all().order_by('-annee_univ__annee_univ','programme__ordre')
    
    def get_context_data(self, **kwargs):
        context = super(PlanificationListView, self).get_context_data(**kwargs)

        filter_ = FormationFilter(self.request.GET, queryset=self.get_queryset(**kwargs))
        filter_.form.helper = FormHelper()
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalitenav_planification_activites'):
            exclude_.append('edit')
            exclude_.append('admin')         
        table = PlanificationTable(filter_.qs, exclude=exclude_)
        RequestConfig(self.request).configure(table)
        
        context['table'] = table
        context['filter'] = filter_
        context['titre'] = 'Liste des formations durant l\'année universitaire en cours'
        context['back'] = reverse('home')
        if self.request.user.has_perm('scolar.fonctionnalitenav_planification_activites'):
            if self.request.user.has_perm('scolar.fonctionnalite_planification_gestionactivites'):
               context['import_url'] = reverse('planning_import_from_fet')
               context['import_btn'] = 'Réinitialiser & Importer'
        
        return context

class PlanificationUpdateView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    
    template_name = 'scolar/planification_update.html'
    
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalitenav_planification_activites')
    
    def get_context_data(self, **kwargs):
        context = super(PlanificationUpdateView, self).get_context_data(**kwargs)
        try:
            formation_=get_object_or_404(Formation, id = self.kwargs.get('formation_pk'))
            periode_programme_=get_object_or_404(PeriodeProgramme, id = self.kwargs.get('periode_pk'))
            module_list=Module.objects.filter(formation=formation_, periode=periode_programme_)
            groupe_list=Groupe.objects.filter(section__formation=formation_)
            activite_list={}
            module_suivi_list={}
            module_periode_list=[]
            for groupe_ in groupe_list :
                for module_ in module_list :
                    module_suivi_=ModulesSuivis.objects.filter(groupe=groupe_, module=module_)
                    key_=str(groupe_.id)+'_'+str(module_.id)
                    if module_suivi_.exists():
                        module_suivi_=module_suivi_.get()
                        if not module_suivi_.module in module_periode_list:
                            module_periode_list.append(module_suivi_.module)
                        module_suivi_list[key_]=module_suivi_
                        module_activite_list=Activite.objects.filter(module=module_, cible__in=[groupe_])
                        key_=str(groupe_.id)+'_'+str(module_.id)
                        if module_activite_list.exists() :
                            activite_list[key_]=module_activite_list
                    else :
                        module_suivi_list[key_]=None
                        if not module_ in module_periode_list:
                            module_periode_list.append(module_)
            context['module_periode_list']=module_periode_list
            context['module_suivi_list']=module_suivi_list
            context['groupe_list']=groupe_list
            context['activite_list']=activite_list
            context['formation']=formation_
            context['periode']=periode_programme_
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors de la génération du tableau de planification. Merci de le signaler à l'administrateur!")
        return context

@receiver(m2m_changed, sender=Activite.assuree_par.through)
def update_charge(sender, instance, action, pk_set, **kwargs):
    if action=="post_add":
        for enseignant_ in instance.assuree_par.all() :
            Charge.objects.update_or_create(activite=instance, realisee_par=enseignant_, defaults={
                'type': 'S' if instance.type.startswith("E_") else 'E',
                'activite':instance,
                'vh': instance.vh_par_enseignant(),
                'vh_eq_td':instance.vh_eq_td_par_enseignant(),
                'annee_univ':instance.module.formation.annee_univ,
                'periode':instance.module.periode.periode,
                'realisee_par':enseignant_,
                #'cree_par':kwargs.get('request').GET.user.enseignant.id,
                'repeter_chaque_semaine':instance.repeter_chaque_semaine
            })
    elif action=="post_remove" :
        Charge.objects.filter(activite=instance, realisee_par__in=pk_set).delete()
        Charge.objects.filter(activite=instance, realisee_par__in=instance.assuree_par.all()).update(
                vh=instance.vh_par_enseignant(),
                vh_eq_td=instance.vh_eq_td_par_enseignant(),
            )

#Mise à jour des charges quand on change la durée d'une activité
@receiver(post_save, sender=Activite)
def update_charge_activite(sender, update_fields, instance, created, **kwargs):
    # Màj les charges qui correspondent à l'activité màj
    for enseignant_ in instance.assuree_par.all() :
        Charge.objects.update_or_create(activite=instance, realisee_par=enseignant_, defaults={
            'type': 'S' if instance.type.startswith("E_") else 'E',
            'activite':instance,
            'vh': instance.vh_par_enseignant(),
            'vh_eq_td':instance.vh_eq_td_par_enseignant(),
            'annee_univ':instance.module.formation.annee_univ,
            'periode':instance.module.periode.periode,
            'realisee_par':enseignant_,
            #'cree_par':kwargs.get('request').GET.user.enseignant.id,
            'repeter_chaque_semaine':instance.repeter_chaque_semaine
        })


@receiver(post_delete, sender=Activite)
def remove_charge(sender, instance, **kwargs):
        # supprimer les charges qui correspondent à l'activité supprimée
        Charge.objects.filter(activite=instance).delete()

class AbsenceEtudiantView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    
    template_name = 'scolar/list.html'
    
    def test_func(self):
        return self.request.user.has_perm_or_student_himself('scolar.fonctionnalitenav_etudiants_visualisationabsences', self.kwargs.get('etudiant_pk')) or self.request.user.is_enseignant()
    
    def get_queryset(self, **kwargs):
        etudiant_pk_=self.kwargs.get('etudiant_pk')
        module_pk_=self.kwargs.get('module_pk')
        return AbsenceEtudiant.objects.filter(seance__activite__module__formation__annee_univ__encours=True, etudiant=etudiant_pk_, seance__activite__module=module_pk_)

    def get_context_data(self, **kwargs):
        context = super(AbsenceEtudiantView, self).get_context_data(**kwargs)
        table = AbsenceEtudiantTable(self.get_queryset(**kwargs), exclude=exclude_columns_enseignant(self.request.user))
        RequestConfig(self.request).configure(table)
        context['titre'] = 'Mes absences'
        context['table'] = table
        context['back'] = self.request.META.get('HTTP_REFERER')
        return context



class AbsenceEtudiantListView(LoginRequiredMixin, PermissionRequiredMixin, TemplateView):
    permission_required = 'scolar.fonctionnalitenav_etudiants_visualisationabsences'
    template_name = 'scolar/filter_list.html'
    
    def get_queryset(self, **kwargs):
        return AbsenceEtudiant.objects.filter(seance__activite__module__formation__annee_univ__encours=True)

    def get_context_data(self, **kwargs):
        context = super(AbsenceEtudiantListView, self).get_context_data(**kwargs)
        filter_ = AbsenceEtudiantFilter(self.request.GET, queryset=self.get_queryset(**kwargs))
        filter_.form.helper = FormHelper()
        table = AbsenceEtudiantTable(filter_.qs, exclude=exclude_columns_enseignant(self.request.user))
        RequestConfig(self.request).configure(table)
        context['filter'] = filter_
        context['table'] = table
        context['titre']='Liste des absences'
        if self.request.user.has_perm('scolar.fonctionnalite_etudiants_justificationabsences'):
            context['btn_list'] = {
                    'Justifier Absences':reverse('absence_etudiant_justification')
                }
        
        return context

class AbsenceEtudiantSeanceListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name = 'scolar/list.html'

    def test_func(self):
        activite_=get_object_or_404(Activite, id=self.kwargs.get('activite_pk'))
        if self.request.user.is_enseignant():
            if self.request.user.enseignant in activite_.assuree_par.all() :
                return True
            else :
                return self.request.user.has_perm('scolar.fonctionnalitenav_etudiants_visualisationabsences')
        else :
            return self.request.user.has_perm('scolar.fonctionnalitenav_etudiants_visualisationabsences')
        
    def get_queryset(self, **kwargs):
        return AbsenceEtudiant.objects.filter(seance=self.kwargs.get('seance_pk'))

    def get_context_data(self, **kwargs):
        context = super(AbsenceEtudiantSeanceListView, self).get_context_data(**kwargs)
        activite_=get_object_or_404(Activite, id=self.kwargs.get('activite_pk'))
        exclude_=[]
        if self.request.user.is_enseignant():
            if not (self.request.user.enseignant in activite_.assuree_par.all() or self.request.user.has_perm('scolar.fonctionnalite_etudiants_justificationabsences')) :
                exclude_.append('edit')
                exclude_.append('admin')
                context['is_assuree_par_enseignant']=False
            else :
                context['is_assuree_par_enseignant']=True
        elif not self.request.user.has_perm('scolar.fonctionnalite_etudiants_justificationabsences') :
            exclude_.append('edit')
            exclude_.append('admin')
            
        table = AbsenceEtudiantTable(self.get_queryset(**kwargs), exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['table'] = table
        context['titre']='Liste des absences'
        context['back']= reverse('assiduite', kwargs={'activite_pk': str(self.kwargs.get('activite_pk'))})
        
        return context

class AbsenceEtudiantUpdateView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, UpdateView):
    model = AbsenceEtudiant
    fields = ['etudiant', 'seance','justif', 'motif', 'date_justif']
    template_name = 'scolar/update.html'
    success_message = "L'absence de l'étudiant a bien été modifiée."

    def test_func(self):
        absence_=get_object_or_404(AbsenceEtudiant, id=self.kwargs.get('pk'))
        activite_=get_object_or_404(Activite, id=absence_.seance.activite.id)
        if self.request.user.is_enseignant():
            if self.request.user.enseignant in activite_.assuree_par.all() :
                return True
            else :
                return self.request.user.has_perm('scolar.fonctionnalite_etudiants_justificationabsences')
        else :
            return self.request.user.has_perm('scolar.fonctionnalite_etudiants_justificationabsences')
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.fields['etudiant']=forms.ModelChoiceField(queryset=Etudiant.objects.all(), disabled=True)
        form.fields['seance']=forms.ModelChoiceField(queryset=Seance.objects.all(), disabled=True)
        form.fields['date_justif']=forms.DateField(input_formats = settings.DATE_INPUT_FORMATS, widget=DatePickerInput(format='%d/%m/%Y'), initial=datetime.date.today())
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-warning'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('absence_list')
        return form

class AbsenceEtudiantDeleteView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, DeleteView):
    model = AbsenceEtudiant
    template_name = 'scolar/delete.html'
    success_message = "L'absence a bien été supprimée."

    def test_func(self):
        absence_=get_object_or_404(AbsenceEtudiant, id=self.kwargs.get('pk'))
        activite_=get_object_or_404(Activite, id=absence_.seance.activite.id)
        if self.request.user.is_enseignant():
            if self.request.user.enseignant in activite_.assuree_par.all() :
                return True
            else :
                return self.request.user.has_perm('scolar.fonctionnalite_etudiants_justificationabsences')
        else :
            return self.request.user.has_perm('scolar.fonctionnalite_etudiants_justificationabsences')
        
    def get_success_url(self):
        if self.request.user.is_enseignant():
            return reverse('absence_seance_list',kwargs={'activite_pk': self.kwargs.get('activite_pk'), 'seance_pk':self.kwargs.get('seance_pk')})
        return reverse('absence_list')




class AbsenceEnseignantView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    
    template_name = 'scolar/list.html'
    
    def test_func(self):
        return self.request.user.has_perm_or_teacher_himself('scolar.fonctionnalitenav_enseignants_visualisationabsences', self.kwargs.get('enseignant_pk'))
    
    def get_queryset(self, **kwargs):
        enseignant_pk_=self.kwargs.get('enseignant_pk')
        module_pk_=self.kwargs.get('module_pk')
        return AbsenceEnseignant.objects.filter(seance__activite__module__formation__annee_univ__encours=True, enseignant=enseignant_pk_, seance__activite__module=module_pk_)

    def get_context_data(self, **kwargs):
        context = super(AbsenceEnseignantView, self).get_context_data(**kwargs)   
        table = AbsenceEnseignantTable(self.get_queryset(**kwargs), exclude=exclude_columns_enseignant(self.request.user))
        RequestConfig(self.request).configure(table)
        module_=get_object_or_404(Module, self.kwargs.get('module_pk'))
        if self.request.user.is_enseignant():
            if assure_module(self.request.user.enseignant, module_) :
                context['module_assure_par_enseignant']=True
        context['titre'] = 'Mes absences'
        context['table'] = table
        context['back'] = self.request.META.get('HTTP_REFERER')
        return context



class AbsenceEnseignantListView(LoginRequiredMixin, PermissionRequiredMixin, TemplateView):
    permission_required = 'scolar.fonctionnalitenav_enseignants_visualisationabsences'
    template_name = 'scolar/filter_list.html'
    
    def get_queryset(self, **kwargs):
        return AbsenceEnseignant.objects.filter(seance__activite__module__formation__annee_univ__encours=True)

    def get_context_data(self, **kwargs):
        context = super(AbsenceEnseignantListView, self).get_context_data(**kwargs)
        filter_ = AbsenceEnseignantFilter(self.request.GET, queryset=self.get_queryset(**kwargs))
        filter_.form.helper = FormHelper()
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalite_enseignants_justificationabsences'):
            exclude_.append('edit')
            exclude_.append('admin') 
        table = AbsenceEnseignantTable(filter_.qs, exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['filter'] = filter_
        context['table'] = table
        context['titre']='Liste des absences d\'enseignants'
        return context

class AbsenceEnseignantUpdateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, UpdateView):
    model = AbsenceEnseignant
    fields = ['enseignant', 'seance','justif', 'motif', 'seance_remplacement', 'date_justif']
    template_name = 'scolar/update.html'
    permission_required = 'scolar.fonctionnalite_enseignants_justificationabsences'
    success_message = "L'absence de l'enseignant a bien été modifiée"
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        absence_enseignant=AbsenceEnseignant.objects.get(id=self.kwargs.get('pk'))
        form.fields['enseignant']=forms.ModelChoiceField(queryset=Enseignant.objects.all(), disabled=True)
        form.fields['seance']=forms.ModelChoiceField(queryset=Seance.objects.all(), disabled=True)
        form.fields['seance_remplacement']=forms.ModelChoiceField(queryset=Seance.objects.filter(activite=absence_enseignant.seance.activite).exclude(id=absence_enseignant.seance.id))
        form.fields['date_justif']=forms.DateField(input_formats = settings.DATE_INPUT_FORMATS, widget=DatePickerInput(format='%d/%m/%Y'), initial=datetime.date.today())
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-warning'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('absence_enseignant_list')
        return form

class SeanceRattrapageCreateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, CreateView):
    model = Seance
    fields = ['activite', 'date', 'rattrapage']
    template_name = 'scolar/create.html'
    permission_required = 'scolar.fonctionnalite_planification_gestionseances'
    success_message = "La séance de rattrapage a bien été créée."
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.fields['activite']=forms.ModelChoiceField(queryset=Activite.objects.filter(id=self.kwargs.get('activite_pk')),initial=0)
        form.fields['rattrapage']=forms.BooleanField(initial=True)
        form.fields['date']=forms.DateField(input_formats = settings.DATE_INPUT_FORMATS, widget=DatePickerInput(format='%d/%m/%Y'), initial=datetime.date.today())
        form.helper.add_input(Submit('submit','Ajouter', css_class='btn-warning'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('absence_enseignant_list')
        return form

@login_required
def signaler_absence_etudiant(request):
    if not request.user.has_perm('scolar.fonctionnalitenav_etudiants_signalementabsences'):
        messages.error(request, "Vous n'avez pas accès à cette opération.")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    # if this is a POST request we need to process the form data
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = SeanceEtudiantSelectionForm(request.POST)
        
        # check whether it's valid:
        if form.is_valid():
            try:
                data=form.cleaned_data

                seance_=data['seance']
                
                absences_list=''
                for inscription_ in data['inscription_absent_list']:
                    try:
                        resultat_=Resultat.objects.get(ancien_resultat__isnull=True, inscription=inscription_, module__matiere__code=seance_.activite.module.matiere.code)
                    except Exception:
                        if settings.DEBUG:
                            raise Exception("Signaler Absence: Resultat inexitant ou Multiple")
                        else:
                            messages.error(request, str(inscription_)+" Module inexistant ou multiple, merci de le signaler à l'administrateur")
                    else:
                        if not resultat_.acquis:
                            absence, created=AbsenceEtudiant.objects.get_or_create(seance=seance_, etudiant=inscription_.etudiant, defaults={
                                'seance':seance_,
                                'etudiant':inscription_.etudiant,
                            })
                            absences_list+=str(inscription_)+' : '+settings.PROTOCOLE_HOST+reverse("etudiant_detail", kwargs={'pk':inscription_.etudiant.matricule})+' \n\n'
                        else:
                            messages.info(request, str(inscription_)+' a déjà validé le module: '+str(seance_.activite.module.matiere.code))
                        
                # envoyer la liste des absents à la direction en cas d'examen
                if seance_.activite.type.startswith('E_'):
                    if activation_emails():
                        email = EmailMessage('[Talents] Liste des Absences Signalées en '+str(seance_.activite),
                                                 'Bonjour,\n'+ 
                                                 'Ces absences en '+str(seance_.activite)+' ont été enregistrées dans Talents\n'+ 
                                                 absences_list+
                                                 ' Un email leur a été transmis pour leur demander de justifier l\'absence dans les 48h.\n'+
                                                 'Bien cordialement.\n'+
                                                 signature_emails(), to=[seance_.activite.module.formation.programme.get_email_responsable_autorite_cycle(), 
                                                                    seance_.activite.module.get_email_coordinateur(),
                                                                    request.user.get_email()]+
                                                                    email_scolarite()+email_direction())
            
                        email.send(fail_silently=True)
                    
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: lors du signalement d'absence d'étudiants. Merci d'en informer l'administrateur")
                    return HttpResponseRedirect(reverse('absence_list'))
            # redirect to a new URL:
            messages.success(request, "Les absences ont bien été enregistrées.")
            return HttpResponseRedirect(reverse('absence_list')) 
    # if a GET (or any other method) we'll create a blank form
    else:
        form = SeanceEtudiantSelectionForm()
        messages.info(request, "Merci de renseigner ce formulaire pour signaler la liste des absents.")
    return render(request, 'scolar/import.html', {'form': form, 'titre':'Signaler les absences d\'étudiants'})

@login_required
def absence_etudiant_report(request):
    if not request.user.has_perm('scolar.fonctionnalitenav_etudiants_rapportabsences'):
        messages.error(request, "Vous n'avez pas accès à cette opération.")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    # if this is a POST request we need to process the form data
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = AbsenceEtudiantReportSelectionForm(request.POST)
        
        # check whether it's valid:
        if form.is_valid():
            try:
                data=form.cleaned_data
                formation_=data['formation']
                periode_=data['periode']
                modules_suivis_list_=ModulesSuivis.objects.filter(
                        groupe__section__formation=formation_,
                        module__periode__periode=periode_
                    ).values('module__matiere__code').distinct()
                
                type_activite_list_=data['type_activite_list']
                absence_justifiee_count=Count('justif', filter=Q(justif=True))
                absence_non_justifiee_count=Count('justif', filter=Q(justif=False))
                
                absence_etudiant_queryset=AbsenceEtudiant.objects.filter(
                        seance__activite__module__formation=formation_,
                        seance__activite__module__matiere__code__in=modules_suivis_list_,
                        seance__activite__type__in=type_activite_list_
                    ).values(
                        'etudiant__matricule', 
                        'etudiant__nom', 
                        'etudiant__prenom',
                        'etudiant__residence_univ',
                        'etudiant__wilaya_residence__nom',
                        'seance__activite__module__matiere__code',
                        'seance__activite__type'
                    ).annotate(
                        absence_justifiee=absence_justifiee_count
                    ).annotate(
                        absence_non_justifiee=absence_non_justifiee_count
                    ).order_by('etudiant__nom', 'etudiant__prenom')
                    
                absence_etudiant_report_list_={}
                for absence_etudiant_ in absence_etudiant_queryset:
                    matricule_=absence_etudiant_['etudiant__matricule']
                    inscription_ = Inscription.objects.filter(formation=formation_, etudiant__matricule=matricule_, decision_jury='C')
                    if inscription_.exists():
                        groupe_=inscription_.first().groupe.code
                        resultat_=Resultat.objects.filter(ancien_resultat__isnull=True,
                            inscription__etudiant__matricule=absence_etudiant_['etudiant__matricule'],                            
                            module__matiere__code=absence_etudiant_['seance__activite__module__matiere__code'],
                            inscription__formation__annee_univ__encours=True,                            
                            acquis=False
                            )
                        if resultat_.exists():
                            resultat_=resultat_.get()
                            if not matricule_ in absence_etudiant_report_list_.keys():
                                absence_etudiant_report_list_[matricule_]={
                                    'nom': absence_etudiant_['etudiant__nom'],
                                    'prenom': absence_etudiant_['etudiant__prenom'],
                                    'residence_univ': absence_etudiant_['etudiant__residence_univ'] if absence_etudiant_['etudiant__residence_univ'] else '',
                                    'wilaya_residence': absence_etudiant_['etudiant__wilaya_residence__nom'] if absence_etudiant_['etudiant__wilaya_residence__nom'] else '',
                                    'groupe': groupe_,
                                }

                            if not resultat_.module.matiere.code in absence_etudiant_report_list_[matricule_].keys():  
                                absence_etudiant_report_list_[matricule_][resultat_.module.matiere.code]={}
                            type_activite_=absence_etudiant_['seance__activite__type']
                            if not type_activite_ in  absence_etudiant_report_list_[matricule_][resultat_.module.matiere.code].keys():
                                absence_etudiant_report_list_[matricule_][resultat_.module.matiere.code][type_activite_]={}
                            absence_etudiant_report_list_[matricule_][resultat_.module.matiere.code][type_activite_]={
                                    'absence_justifiee_count':absence_etudiant_['absence_justifiee'],
                                    'absence_non_justifiee_count':absence_etudiant_['absence_non_justifiee']
                                }
                
                header=['Matricule','Groupe','Nom','Prenom', 'Residence Univ', 'Wilaya Residence']
                for module_suivi_ in modules_suivis_list_ :                    
                                        
                    header.append(module_suivi_['module__matiere__code'])
                    
                    #header.append('R('+module_suivi_['module__matiere__code']+')')
                sheet=Dataset()
                sheet.headers = header
            
                for matricule_, report_ in absence_etudiant_report_list_.items() :
                    row_=[]
                    row_.append(matricule_) 
                    row_.append(report_['groupe'])                   
                    row_.append(report_['nom'])
                    row_.append(report_['prenom'])
                    row_.append(report_['residence_univ'])
                    row_.append(report_['wilaya_residence'])
                    
                    for module_suivi_ in modules_suivis_list_:
                        absence_justifiee_info_=''
                        absence_non_justifiee_info_=''
                        
                        remplacement_=False
                        if module_suivi_['module__matiere__code'] in report_.keys():
                            
                            for type_activite_ in type_activite_list_:
                                nb_justifiees=report_[module_suivi_['module__matiere__code']][type_activite_]['absence_justifiee_count'] if type_activite_ in report_[module_suivi_['module__matiere__code']].keys() else 0
                                nb_non_justifiees=report_[module_suivi_['module__matiere__code']][type_activite_]['absence_non_justifiee_count'] if type_activite_ in report_[module_suivi_['module__matiere__code']].keys() else 0
                                if nb_justifiees>0 and type_activite_.startswith('E_'):
                                    remplacement_=True
                                if  nb_justifiees > 0:
                                    if nb_justifiees==1:
                                        absence_justifiee_info_+=' '+str(type_activite_)
                                    else:
                                        absence_justifiee_info_+=str(nb_justifiees)+' x '+str(type_activite_)
                                if  nb_non_justifiees > 0:
                                    if nb_non_justifiees==1:
                                        absence_non_justifiee_info_+=' '+str(type_activite_)
                                    else:
                                        absence_non_justifiee_info_+=str(nb_non_justifiees)+' x '+str(type_activite_)
                            if absence_justifiee_info_ != '':
                                absence_justifiee_info_='OUI: '+absence_justifiee_info_
                            if absence_non_justifiee_info_ != '':
                                absence_non_justifiee_info_='NON: '+absence_non_justifiee_info_
                                
                        row_.append(absence_justifiee_info_+'\n'+absence_non_justifiee_info_)
#                         if remplacement_:
#                             row_.append('1')
#                         else: 
#                             row_.append('0')   
                    sheet.append(row_)
                    
                filename='Rapport_Absences_'+str(formation_)+'_'+str(periode_)+'.xlsx'
                filename=filename.replace(' ','_')
        
                response = HttpResponse(content_type='application/vnd.ms-excel')
                response['Content-Disposition'] = 'attachment; filename='+filename+";"
                response.write(sheet.xlsx)
                
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: lors de la génération du rapport global des absences")
                    return HttpResponseRedirect(reverse('absence_list'))
            # redirect to a new URL:
            messages.success(request, "Le rapport global des absences a été généré correctement.")
            return response 
    # if a GET (or any other method) we'll create a blank form
    else:
        form = AbsenceEtudiantReportSelectionForm()
        messages.info(request, "Merci de resenigner ce formulaire pour sélectionner les activités à faire apparaître sur le rapport global des absences")
    return render(request, 'scolar/import.html', {'form': form, 'titre':'Sélection des activités du rapport des absences'})


@login_required
def signaler_absence_enseignant(request):
    if not request.user.has_perm('scolar.fonctionnalitenav_enseignants_signalementabsences'):
        messages.error(request, "Vous n'avez pas accès à cette opération.")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    # if this is a POST request we need to process the form data
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = SeanceSelectionForm(request.POST)
        
        # check whether it's valid:
        if form.is_valid():
            try:
                enseignant_=form.cleaned_data['enseignant']
                activite_=form.cleaned_data['activite']
                date_=form.cleaned_data['date']
                seance_, created=Seance.objects.get_or_create(activite=activite_, date=date_, defaults={
                        'activite':activite_,
                        'date':date_
                    })
                absence, created=AbsenceEnseignant.objects.get_or_create(seance=seance_, enseignant=enseignant_, defaults={
                        'seance':seance_,
                        'enseignant':enseignant_,
                    })
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: lors du signalement d'absence de l'enseignant. Merci d'en informer l'administrateur")
                    return HttpResponseRedirect(reverse('absence_enseignant_list'))
            # redirect to a new URL:
            messages.success(request, "L'absence a bien été enregistrée.")
            return HttpResponseRedirect(reverse('absence_enseignant_list')) 
    # if a GET (or any other method) we'll create a blank form
    else:
        form = SeanceSelectionForm()
        messages.info(request, "Merci d'indiquer le nom de l'enseignant absent, puis la séance et date de l'absence.")
    return render(request, 'scolar/import.html', {'form': form, 'titre':'Signaler l\'absence d\'un enseignant'})

@receiver(post_save, sender=AbsenceEnseignant)
def email_absence_enseignant(sender, update_fields, instance, created, **kwargs):
    if created and activation_emails():
        nb_absences = instance.nb_absences()
        email_context = {
                "objet" : f"{nb_absences} Absences Signalées en {instance.seance.activite}",
                "destinataires" : [instance.enseignant.get_email()],
                "cc" : [instance.seance.activite.module.formation.programme.get_email_responsable_autorite_cycle()] + email_direction(),
                "instance" : instance,
            }
        if nb_absences < 3:
            email_context["template"] = "absence_inf_3_enseignant.html"
        else:
            email_context["template"] = "absence_sup_3_enseignant.html"
        send_email(email_context)



def index(request):
    context = {}
    return render(request, 'scolar/index.html',context)

def home(request):
    context = {}
    return render(request, 'scolar/home.html',context)

class ActiviteEtudiantTableView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    
    template_name = 'scolar/modal_filter_list.html'

    def test_func(self):
        return self.request.user.is_etudiant()
    
    def get_queryset(self, **kwargs):
        try:
            liste_inscription_encours=Inscription.objects.filter(etudiant=self.request.user.etudiant, formation__annee_univ__encours=True)
            liste_groupe_encours=[]
            for inscription_encours in liste_inscription_encours:
                for inscription_periode in inscription_encours.inscription_periodes.all():
                    if inscription_periode.groupe:
                        if not inscription_periode.groupe in liste_groupe_encours:
                            liste_groupe_encours.append(inscription_periode.groupe)
                            section_encours=inscription_periode.groupe.section.groupes.all().filter(code__isnull=True).get()
                            liste_groupe_encours.append(section_encours)
            return Activite.objects.filter(cible__in=liste_groupe_encours).exclude(type__startswith='E_')
        except Exception:
            messages.error(self.request, "ERREUR: nous ne trouvons pas d'inscription en cours valide. Si ce n'est pas le cas, merci de le signaler à l'administration des études..")
            return Activite.objects.none()

    def get_context_data(self, **kwargs):
        context = super(ActiviteEtudiantTableView, self).get_context_data(**kwargs)
        filter_ = ActiviteEtudiantFilter(self.request.GET, request = self.request, queryset=self.get_queryset(**kwargs))
        filter_.form.helper = FormHelper()
        table = ActiviteEtudiantTable(filter_.qs, exclude=exclude_columns_etudiant(self.request.user))
        RequestConfig(self.request).configure(table)
        context['filter'] = filter_
        context['table'] = table
        context['titre'] = 'Mon activité pédagogique'
        try:
            matiere_list=[]
            inscription_list=Inscription.objects.filter(etudiant=self.request.user.etudiant, formation__annee_univ__encours=True)
            for resultat_ in Resultat.objects.filter(ancien_resultat__isnull=True, inscription__in=inscription_list):
                matiere_list.append(resultat_.module.matiere)
            context.update(get_competence_context(MatiereCompetenceElement.objects.filter(matiere__in=matiere_list)))   
        except Exception:
            if settings.DEBUG:
                raise Exception
            else: 
                messages.error(self.request, "ERREUR: lors de la génération de la matrice de compétences. Merci de le signaler à l'administrateur")
 
        return context
    
class ExamenEtudiantListView(LoginRequiredMixin, TemplateView):
    
    template_name = 'scolar/list.html'
    
    def get_queryset(self, **kwargs):
        try:
            liste_inscription_encours=Inscription.objects.filter(etudiant=self.request.user.etudiant, formation__annee_univ__encours=True)
            return ReservationPlaceEtudiant.objects.filter(inscription__in=liste_inscription_encours, seance__activite__type__startswith='E_')
        except Exception:
            messages.error(self.request, "ERREUR: nous ne trouvons pas d'inscription en cours valide. Si ce n'est pas le cas, merci de le signaler à l'administration des études..")
            return Seance.objects.none()

    def get_context_data(self, **kwargs):
        context = super(ExamenEtudiantListView, self).get_context_data(**kwargs)        
        table = PlaceEtudiantTable(self.get_queryset(**kwargs), exclude=exclude_columns_etudiant(self.request.user))
        RequestConfig(self.request).configure(table)
        
        context['table'] = table
        context['titre'] = 'Mes examens'
 
        return context
    

class ActiviteTableView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name = 'scolar/modal_filter_list.html'
    titre = 'Mes activités pédagogiques'
    
    def test_func(self):
        return self.request.user.is_enseignant()
    
    def get_queryset(self, **kwargs):
        return Activite.objects.filter(assuree_par__in=[self.request.user.enseignant], module__matiere__pfe=False, module__formation__programme__matiere_equipe__isnull=True).exclude(type__startswith='E_').order_by('-module__formation__annee_univ__annee_univ')

    def get_context_data(self, **kwargs):
        context = super(ActiviteTableView, self).get_context_data(**kwargs)
        filter_ = ActiviteFilter(self.request.GET, queryset=self.get_queryset(**kwargs))
        filter_.form.helper = FormHelper()
        table = ActiviteTable(filter_.qs, exclude=exclude_columns_enseignant(self.request.user))
        RequestConfig(self.request).configure(table)
        context['filter'] = filter_
        context['table'] = table
        context['titre'] = self.titre
        
        try:
            matiere_list=[]
            activite_list=self.get_queryset()
            for activite_ in activite_list:
                matiere_list.append(activite_.module.matiere)
            context.update(get_competence_context(MatiereCompetenceElement.objects.filter(matiere__in=matiere_list)))    
        except Exception:
            if settings.DEBUG:
                raise Exception
            else: 
                messages.error(self.request, "ERREUR: lors de la génération de la matrice de compétences. Merci de le signaler à l'administrateur")
        return context

class ActiviteSurveillanceView(LoginRequiredMixin, TemplateView):
    template_name = 'scolar/filter_list.html'
    titre = 'Mes Surveillances'
    def get_queryset(self, **kwargs):
        return Seance.objects.filter(activite__assuree_par__in=[self.request.user.enseignant], activite__module__matiere__pfe=False, activite__type__startswith='E_').order_by('-date', 'heure_debut')

    def get_context_data(self, **kwargs):
        context = super(ActiviteSurveillanceView, self).get_context_data(**kwargs)
        filter_ = SurveillancesEnseignantFilter(self.request.GET, queryset=self.get_queryset(**kwargs))
        filter_.form.helper = FormHelper()
        table = ExamenTable(filter_.qs, exclude=exclude_columns_enseignant(self.request.user))
        RequestConfig(self.request).configure(table)
        context['filter'] = filter_
        context['table'] = table
        context['titre'] = self.titre
        return context


class ActiviteSoutenancesView(ActiviteTableView):
    titre = 'Mes soutenances et encadrements'
    def get_queryset(self, **kwargs):
        return Activite.objects.filter(Q(assuree_par__in=[self.request.user.enseignant]) & (Q(module__matiere__pfe=True)|Q(module__formation__programme__matiere_equipe__isnull=False))).order_by('-module__formation__annee_univ__annee_univ')
    
def get_note_list_context(inscription_list, module_pk, groupe_pk):
    context={}
    module_=get_object_or_404(Module, id=module_pk)
    evaluation_list=Evaluation.objects.filter(module=module_)
    resultat_list={}
    note_list={}
    for inscrit_ in inscription_list :
        # le résultat d'un étudiant dans un module est déjà créé lors de son inscription à un groupe
        resultat_=Resultat.objects.get(inscription=inscrit_,module__matiere=module_.matiere, ancien_resultat__isnull=True)
        resultat_list[inscrit_.etudiant.matricule]=resultat_
        for eval_ in evaluation_list :
            note_=Note.objects.filter(resultat__inscription=inscrit_, evaluation=eval_)
            if note_.exists() :
                note_=note_.get()
                key_=str(inscrit_)+' '+str(eval_)
                note_list[key_]=note_
    context['module'] = module_
    context['evaluation_list'] = evaluation_list
    context['groupe'] = get_object_or_404(Groupe, id=groupe_pk) if groupe_pk != None else None
    context['inscription_list'] = inscription_list
    context['resultat_list']= resultat_list
    context['note_list'] = note_list
    context['decisions_jury'] = dict(DECISIONS_JURY)
    return context
    
class NoteListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name="scolar/note_list.html"
    def test_func(self):
        module_=ModulesSuivis.objects.get(groupe=self.kwargs.get('groupe_pk'), module__matiere=self.kwargs.get('matiere_pk')).module
        if self.request.user.has_perm('scolar.fonctionnalitenav_pedagogie_visualisationnotes') or self.request.user.has_acces_visualisation_notes_programme(module_.formation.programme):
            return True
        elif self.request.user.is_enseignant():
            groupe_=get_object_or_404(Groupe, id=self.kwargs.get('groupe_pk'))
            groupe_section=groupe_.section.groupes.all().filter(code__isnull=True).get() # le groupe qui représente la section
            return assure_module_groupe(self.request.user.enseignant, module_, groupe_) or assure_module_groupe(self.request.user.enseignant, module_, groupe_section) 
        else:
            return False
        
    def get_queryset(self, **kwargs):
        groupe_=get_object_or_404(Groupe, id=self.kwargs.get('groupe_pk'))
        if groupe_.is_equipe():
            return Inscription.objects.filter(id__in=groupe_.pfe.equipe.inscriptions.all())
        else :    
            module_=ModulesSuivis.objects.get(groupe=self.kwargs.get('groupe_pk'), module__matiere=self.kwargs.get('matiere_pk')).module
            return Inscription.objects.filter(inscription_periodes__groupe=groupe_, inscription_periodes__periodepgm__periode=module_.periode.periode).order_by('etudiant__nom', 'etudiant__prenom')


    def get_context_data(self, **kwargs):
        context = super(NoteListView, self).get_context_data(**kwargs)
        try:
            groupe_=get_object_or_404(Groupe, id=self.kwargs.get('groupe_pk'))
            module_=ModulesSuivis.objects.get(groupe=self.kwargs.get('groupe_pk'), module__matiere=self.kwargs.get('matiere_pk')).module
            context.update(get_note_list_context(self.get_queryset(**kwargs), module_.id, self.kwargs.get('groupe_pk')))
            context['decisions_jury']=dict(DECISIONS_JURY)
            messages.info(self.request, "Vous pouvez introduire les notes des étudiants en les saisissant en cliquant sur le bouton Modifier")
            if not module_.matiere.pfe and not groupe_.is_equipe(): 
                messages.warning(self.request, "Si vous préférez charger les notes à partir d'un fichier Excel, veillez à ce que le fichier ait exactement la structure du fichier téléchargeable ci-après.")
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors de la génération du tableau des notes. Merci de le signaler à l'administrateur.")
        return context

class NoteEtudiantListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name="scolar/note_list.html"
    
    def test_func(self):
        return self.request.user.has_perm_or_student_himself('scolar.fonctionnalitenav_pedagogie_visualisationnotes', self.kwargs.get('etudiant_pk'))
    
    def get_context_data(self, **kwargs):
        context = super(NoteEtudiantListView, self).get_context_data(**kwargs)
        try:
            #module_=ModulesSuivis.objects.get(groupe__inscrits__etudiant__matricule__in=[self.kwargs.get('etudiant_pk')], groupe__section__formation__annee_univ__encours=True, module__matiere=self.kwargs.get('matiere_pk')).module
            matiere_=Matiere.objects.get(id=self.kwargs.get('matiere_pk'))
            resultat_=Resultat.objects.get(inscription__etudiant__matricule=self.kwargs.get('etudiant_pk'), inscription__formation__annee_univ__encours=True, module__matiere__code=matiere_.code, ancien_resultat__isnull=True)
            module_=resultat_.module
            context.update(get_note_list_context([resultat_.inscription],
                                                 module_.id, 
                                                 None))
            context['decision_jury'] = dict(DECISIONS_JURY)
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors de la génération du tableau des notes. Merci de le signaler à l'administrateur.")
        return context



class SeanceTableView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name='scolar/list.html'

    def test_func(self):
        if self.request.user.has_perm('scolar.fonctionnalite_planification_visualisationseances') :
            return True
        elif self.request.user.is_enseignant():
            activite_=get_object_or_404(Activite, id=self.kwargs.get('activite_pk'))
            return assure_module(self.request.user.enseignant, activite_.module) or self.request.user.has_perm('scolar.fonctionnalite_planification_visualisationseances')
        else:
            return False
    
    def get_queryset(self,**kwargs):
        return Seance.objects.filter(activite__id=self.kwargs.get('activite_pk'))
    
    def get_context_data(self, **kwargs):
        context = super(SeanceTableView, self).get_context_data(**kwargs)
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalite_planification_gestionseances'):
            exclude_.append('edit')
            exclude_.append('admin')
        table = SeanceTable(self.get_queryset(**kwargs), exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['table'] = table
        context['back'] = reverse('activite')
        context['create_url'] = reverse('seance_create', kwargs={'activite_pk':self.kwargs.get('activite_pk')})
        context['create_btn'] = 'Séance'
        return context


class AnneeUnivListView(LoginRequiredMixin, PermissionRequiredMixin, TemplateView):

    template_name='scolar/list.html'
    
    permission_required = 'scolar.fonctionnalitenav_planification_visualisationformations' 
       
    def get_context_data(self, **kwargs):
        context = super(AnneeUnivListView, self).get_context_data(**kwargs)
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalite_planification_gestionformations'):
            exclude_.append('edit')
            exclude_.append('admin')
        table = AnneeUnivTable(AnneeUniv.objects.all().order_by('-annee_univ'), exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['table'] = table
        context['back'] = self.request.META.get('HTTP_REFERER')
        if self.request.user.has_perm('scolar.fonctionnalite_planification_gestionformations'):
            context['create_url'] = reverse('anneeuniv_create')
            context['create_btn'] = 'Année'
        return context

class AnneeUnivUpdateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, UpdateView):
    model = AnneeUniv
    fields = ['annee_univ', 'debut', 'fin', 'encours']
    template_name = 'scolar/update.html'
    permission_required = 'scolar.fonctionnalite_planification_gestionformations'
    success_message = "La modification de l'année universitaire a bien été effectuée."
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.fields['debut']=forms.DateField(input_formats = settings.DATE_INPUT_FORMATS, widget=DatePickerInput(format='%d/%m/%Y'))
        form.fields['fin']=forms.DateField(input_formats = settings.DATE_INPUT_FORMATS, widget=DatePickerInput(format='%d/%m/%Y'))
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('anneeuniv_list')
        return form


class AnneeUnivCreateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, CreateView): 
    model = AnneeUniv
    fields = ['annee_univ', 'debut', 'fin', 'encours']
    template_name = 'scolar/create.html'
    permission_required = 'scolar.fonctionnalite_planification_gestionformations'
    success_message = "L'année universitaire a bien été rajoutée."
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.fields['debut']=forms.DateField(input_formats = settings.DATE_INPUT_FORMATS, widget=DatePickerInput(format='%d/%m/%Y'))
        form.fields['fin']=forms.DateField(input_formats = settings.DATE_INPUT_FORMATS, widget=DatePickerInput(format='%d/%m/%Y'))
        form.helper.add_input(Submit('submit','Ajouter', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('anneeuniv_list')
        return form
    def get_context_data(self, **kwargs):
        context = super(AnneeUnivCreateView, self).get_context_data(**kwargs)
        context['titre'] = "Ajouter une nouvelle année universitaire"
        return context

@receiver(post_save, sender=AnneeUniv)
def update_annee_univ_encours(sender, instance, created, **kwargs):
        # garder une seule année univ en cours
        if instance.encours :
            #mettre toutes les autres à False
            for annee_univ_ in AnneeUniv.objects.all():
                if (annee_univ_ != instance) and (annee_univ_.encours):
                    annee_univ_.encours=False
                    annee_univ_.save() 

                     
   
class FormationListView(LoginRequiredMixin, PermissionRequiredMixin, TemplateView):
    template_name='scolar/list.html'
    permission_required = 'scolar.fonctionnalitenav_planification_visualisationformations'
    
    def get_queryset(self,**kwargs):
        return Formation.objects.filter(annee_univ__annee_univ=kwargs.get('annee_univ_pk')).order_by('programme__ordre')
    
    def get_context_data(self, **kwargs):
        context = super(FormationListView, self).get_context_data(**kwargs)
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalite_planification_gestionformations'):
            exclude_.append('edit')
            exclude_.append('admin')          
        table = FormationTable(self.get_queryset(**kwargs), exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['titre'] = 'Liste des formations durant l\'année universitaire %s' % self.kwargs.get('annee_univ_pk')
        context['table'] = table
        context['back'] = reverse('anneeuniv_list')
        if self.request.user.has_perm('scolar.fonctionnalite_planification_gestionformations'):
            context['create_url'] = reverse('formation_create', kwargs={'annee_univ_pk':self.kwargs.get('annee_univ_pk')})
            context['create_btn'] = 'Formation'                     
        return context

class FormationDeleteView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, DeleteView):
    model = Formation
    template_name = 'scolar/delete.html'
    permission_required = 'scolar.fonctionnalite_planification_gestionformations'
    success_message = "La formation a bien été supprimée!"

    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression de la formation : "+str(object_))
        return super(FormationDeleteView, self).delete(*args, **kwargs)
        
    def get_success_url(self):
        return reverse('formation_list', kwargs={'annee_univ_pk': str(self.kwargs.get('annee_univ_pk'))})

def formation_archive_toggle_view(request, formation_pk):
    if request.user.has_perm('scolar.fonctionnalite_planification_gestionformations') :
        pass
    else :
        messages.error(request, "Vous n'avez pas la permission d'accéder à cette opération." )
        return redirect('/accounts/login/?next=%s' % request.path)
    
    formation_=Formation.objects.get(id=formation_pk)
    formation_.archive=not formation_.archive
    formation_.save(update_fields=['archive'])
    if formation_.archive:
        messages.success(request, 'La formation %s a été bien archivée' % str(formation_))
        trace_create(request.user,request.user,"La formation"+ str(formation_) +" a été archivée ")
    else:
        messages.warning(request, 'La formation %s a été désarchivée' % str(formation_))
        trace_create(request.user,request.user,"La formation "+ str(formation_) + " a été désarchivée ")
    return HttpResponseRedirect(request.META.get('HTTP_REFERER'))

class FormationCreateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, CreateView):
    model = Formation
    fields = ['programme','annee_univ',]
    template_name = 'scolar/create.html'
    permission_required = 'scolar.fonctionnalite_planification_gestionformations'
    success_message ="La formation a bien été créée."
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.fields['programme']=forms.ModelChoiceField(queryset=Programme.objects.all().order_by('ordre'))
        form.fields['annee_univ']=forms.ModelChoiceField(queryset=AnneeUniv.objects.filter(annee_univ=self.kwargs.get('annee_univ_pk')), initial=0)
        form.helper.add_input(Submit('submit', 'Ajouter', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('formation_list', kwargs={'annee_univ_pk': str(self.kwargs.get('annee_univ_pk'))})
        
        return form
    
    def get_context_data(self, **kwargs):
        context = super(FormationCreateView, self).get_context_data(**kwargs)
        titre='Créer une Formation'        
        context['titre'] = titre
        return context


class FormationUpdateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, UpdateView):
    model = Formation
    fields = ['programme','annee_univ',]
    template_name = 'scolar/update.html'
    permission_required = 'scolar.fonctionnalite_planification_gestionformations'
    success_message = "La formation a été bien mise à jour"
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.fields['programme']=forms.ModelChoiceField(queryset=Programme.objects.all().order_by('ordre'))
        form.fields['annee_univ']=forms.ModelChoiceField(queryset=AnneeUniv.objects.filter(annee_univ=self.kwargs.get('annee_univ_pk')), initial=0)
        form.helper.add_input(Submit('submit', 'Modifier', css_class='btn-warning'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('formation_list', kwargs={'annee_univ_pk': str(self.kwargs.get('annee_univ_pk'))})
        
        return form
    
@receiver(post_save, sender=Formation)
def add_modules_formation(sender, instance, created, **kwargs):
        if created:
            # créer les modules
            for periode_ in instance.programme.periodes.all():
                # on crée les sessions qui correspondent aux periodes du programme
                PeriodeFormation.objects.create(formation=instance, periode=periode_.periode, session=periode_.periode.session)
                for ue in periode_.ues.all():
                    if ue.nature=='OBL':
                        for matiere_ in ue.matieres.all():
                            Module.objects.create(formation=instance, matiere=matiere_, periode=periode_)
                        

class SectionListView(LoginRequiredMixin, PermissionRequiredMixin, TemplateView):
    template_name='scolar/list.html'
    permission_required = 'scolar.fonctionnalitenav_planification_visualisationformations'
    
    def get_queryset(self,**kwargs):
        return Section.objects.filter(formation__id=kwargs.get('formation_pk'))
    
    def get_context_data(self, **kwargs):
        context = super(SectionListView, self).get_context_data(**kwargs)
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalite_planification_gestionformations'):
            exclude_.append('edit')
            exclude_.append('admin')
        table = SectionTable(self.get_queryset(**kwargs), exclude=exclude_)
        RequestConfig(self.request).configure(table)
        formation_=get_object_or_404(Formation, id=self.kwargs.get('formation_pk'))
        context['table'] = table
        context['titre'] = 'Liste des sections'
        context['back'] = reverse('formation_list', kwargs={'annee_univ_pk':formation_.annee_univ.annee_univ})
        if self.request.user.has_perm('scolar.fonctionnalite_planification_gestionformations'):
            context['create_url']= reverse('section_create', kwargs={'formation_pk':self.kwargs.get('formation_pk')})
            context['create_btn'] = 'Section'            
        return context

class SectionDeleteView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, DeleteView):
    model = Section
    template_name = 'scolar/delete.html'
    permission_required = 'scolar.fonctionnalite_planification_gestionformations'
    success_message = "La section a bien été supprimée."

    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression de la section : "+str(object_))
        return super(SectionDeleteView, self).delete(*args, **kwargs)
        
    def get_success_url(self):
        return reverse('section_list', kwargs={'formation_pk': str(self.kwargs.get('formation_pk'))})

class SectionCreateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, CreateView):
    model = Section
    fields = ['code','formation']
    template_name = 'scolar/create.html'
    permission_required = 'scolar.fonctionnalite_planification_gestionformations'
    success_message = "La section a bien été créée."
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.fields['code'].help_text="Exemple de code de section : A, B, etc.. "
        form.fields['formation']=forms.ModelChoiceField(queryset=Formation.objects.filter(id=self.kwargs.get('formation_pk')), initial=0)
        form.helper.add_input(Submit('submit', 'Ajouter', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('section_list', kwargs={'formation_pk': str(self.kwargs.get('formation_pk'))})
        
        return form

    def get_context_data(self, **kwargs):
        context = super(SectionCreateView, self).get_context_data(**kwargs)
        context['titre'] = 'Ajouter une section'
        return context
    
@receiver(post_save, sender=Section)
def add_section_groupe(sender, instance, created, **kwargs):
        if created:
            grp=Groupe.objects.create(section=instance)

         
class GroupeListView(LoginRequiredMixin, PermissionRequiredMixin, TemplateView):
    template_name='scolar/list.html'
    permission_required = 'scolar.fonctionnalitenav_planification_visualisationformations'
    
    def get_queryset(self,**kwargs):
        return Groupe.objects.filter(section__id=kwargs.get('section_pk'))
    
    def get_context_data(self, **kwargs):
        context = super(GroupeListView, self).get_context_data(**kwargs)
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalite_planification_gestionformations'):
            exclude_.append('edit')
            exclude_.append('admin')
        table = GroupeTable(self.get_queryset(**kwargs), exclude=exclude_)
        RequestConfig(self.request).configure(table)
        section_=get_object_or_404(Section, id=self.kwargs.get('section_pk'))
        context['table'] = table
        context['titre'] = 'Liste des groupes'
        context['back'] = reverse('section_list', kwargs={'formation_pk':section_.formation.id})
        if self.request.user.has_perm('scolar.fonctionnalite_planification_gestionformations'):
            context['create_url'] = reverse('groupe_create', kwargs={'section_pk':section_.id})
            context['create_btn'] = 'Groupe'
        return context

class GroupeAllListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name='scolar/filter_list.html'
    
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalitenav_etudiants_groupes')
    
    def get_queryset(self,**kwargs):
        return Groupe.objects.filter(section__formation__annee_univ__encours=True).order_by('section__formation__programme__ordre', 'section__code', 'code')
    
    def get_context_data(self, **kwargs):
        context = super(GroupeAllListView, self).get_context_data(**kwargs)
        filter_ = GroupeAllFilter(self.request.GET, queryset=self.get_queryset(**kwargs))
        filter_.form.helper = FormHelper()
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalite_planification_gestionformations'):
            exclude_.append('edit')
            exclude_.append('admin')
        table = GroupeAllTable(filter_.qs, exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['filter'] = filter_
        context['table'] = table
        context['titre']='Liste des groupes'
        context['back'] = reverse('home')
        return context


class EquipeListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name='scolar/list.html'

    def test_func(self):
        formation_=get_object_or_404(Formation, id=self.kwargs.get('formation_pk'))
        module_=get_object_or_404(Module, formation__id=formation_.id)
        return self.request.user.has_perm('scolar.fonctionnalitenav_stages_visualisationsoutenancesequipes') or self.request.user.is_coordinateur(module_)
    def get_queryset(self,**kwargs):
        formation_=get_object_or_404(Formation, id=self.kwargs.get('formation_pk'))
        equipe_list=Equipe.objects.filter(pfe__groupe__section__formation__programme__matiere_equipe=formation_.programme.matiere_equipe)
        return Groupe.objects.filter(section__formation=formation_, pfe__equipe__in=equipe_list)
    
    def get_context_data(self, **kwargs):
        context = super(EquipeListView, self).get_context_data(**kwargs)
        formation_=get_object_or_404(Formation, id=self.kwargs.get('formation_pk'))
        module_=get_object_or_404(Module, formation__id=formation_.id)
        if self.request.user.is_coordinateur(module_) :
            table = GroupeTable(self.get_queryset(**kwargs))
        else :
            exclude_=[]
            if not self.request.user.has_perm('scolar.fonctionnalite_planification_gestionformations'):
                exclude_.append('edit')
                exclude_.append('admin')
            table = GroupeTable(self.get_queryset(**kwargs), exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['table'] = table
        context['titre'] = str('Liste des équipes de ')+formation_.programme.matiere_equipe.code
        context['back'] = reverse('notes_formation_coordinateur_detail', kwargs={'formation_pk':formation_.id, 'periode_pk':self.kwargs.get('periode_pk'), 'module_pk':module_.id})
        context['coordinateur']=self.request.user.is_coordinateur(module_)
        
        if (self.request.user.is_coordinateur(module_) and module_.formation.programme.matiere_equipe==module_.matiere):
            context['create_url'] = reverse('import_equipes', kwargs={'formation_pk':formation_.id, 'periode_pk':self.kwargs.get('periode_pk')})
            context['create_btn'] = 'Importer les équipes (codes + étudiants)'
            
        return context

class EquipeDeleteView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, DeleteView):
    model = Groupe
    template_name = 'scolar/delete.html'
    success_message = "L'équipe a bien été supprimée."

    def test_func(self):
        groupe_=self.get_object()
        if self.request.user.has_perm('scolar.fonctionnalite_planification_gestionformations') :
            return True
        elif groupe_.is_equipe() :
            try :
                module_fictif=Module.objects.get(matiere=groupe_.section.formation.programme.matiere_equipe, formation=groupe_.section.formation)
                if self.request.user.is_coordinateur(module_fictif) :
                    return True
                else :
                    return False
            except Exception :
                raise Exception    
    
    def get_success_url(self):
        return reverse('equipe_list', kwargs={'formation_pk': str(self.kwargs.get('formation_pk')), 'periode_pk': str(self.kwargs.get('periode_pk'))})

    def delete(self, *args, **kwargs):
        groupe_=self.get_object()
        activites=Activite.objects.filter(cible=groupe_)
        for activite_ in activites :
            charges=Charge.objects.filter(activite=activite_).delete()    
        activites.delete()
        pfe=PFE.objects.filter(groupe=groupe_).delete()
        return super(EquipeDeleteView, self).delete(*args, **kwargs)

def import_equipes(request, formation_pk, periode_pk):
    formation_=get_object_or_404(Formation, id=formation_pk)
    module_=get_object_or_404(Module, formation__id=formation_.id)
    if not (request.user.is_coordinateur(module_) and module_.formation.programme.matiere_equipe==module_.matiere) :
        return redirect('/accounts/login/?next=%s' % request.path)
    
    # if this is a POST request we need to process the form data
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        
        form = ImportFileForm(request.POST, request.FILES)
        # check whether it's valid:
        if form.is_valid():
            try:    
                equipes_file = request.FILES['file']
                dataset = Dataset()
                imported_data = dataset.load(equipes_file.read(), format ='xlsx')
                form_data=form.cleaned_data
                matricule_code_non_importes={}
                formation_=get_object_or_404(Formation, id=formation_pk)
                for row in imported_data.dict :
                    matricule_list=row['Matricule'].split('\n')
                    code_=row.get('Code') #code groupe (équipe) à créer
                    for matricule_ in matricule_list :
                        inscription_=Inscription.objects.filter(formation__programme__matiere_equipe__isnull=True, formation__programme__fictif=False, formation__sections__groupes__modules_suivis__module__matiere=formation_.programme.matiere_equipe, formation__annee_univ=formation_.annee_univ, etudiant__matricule=matricule_.strip(), decision_jury='C').distinct()                    
                        if inscription_.count()>1 :
                            raise Exception
                        if inscription_.exists() :
                            inscription_=inscription_.first()
    
                            default_section_, created=Section.objects.get_or_create(formation=formation_, code='A', defaults={
                                    'formation':formation_,
                                    'code':'A'
                                })
                            
                            groupe_, created=Groupe.objects.get_or_create(section=default_section_, code=code_, defaults={
                                    'code':code_,
                                    'section':default_section_
                                })
                            
                            pfe_, created=PFE.objects.get_or_create(groupe=groupe_, defaults={
                                    'groupe':groupe_,
                                    'notification':False
                                })
                            
                            equipe_, created=Equipe.objects.get_or_create(pfe=pfe_, defaults={
                                    'pfe':pfe_
                                }) 
                            
                            liste_equipes=Equipe.objects.filter(pfe__groupe__section__formation=formation_)
                            all_inscriptions_equipes=[]
                            for equipe_tmp in liste_equipes :
                                for inscription_tmp in equipe_tmp.inscriptions.all() :
                                    if not inscription_tmp in all_inscriptions_equipes :
                                        all_inscriptions_equipes.append(inscription_tmp)
                            if not inscription_ in equipe_.inscriptions.all() and inscription_ not in all_inscriptions_equipes:
                                equipe_.inscriptions.add(inscription_)
                                equipe_.save()
                            else :
                                matricule_code_non_importes[matricule_]=code_
                        else :        
                            matricule_code_non_importes[matricule_]=code_
                messages.info(request, "Liste des équipes non importées : "+str(matricule_code_non_importes))
                messages.success(request, "Les équipes ont été importées avec succès.")    
            except Exception as e:
                if settings.DEBUG:
                    raise e
                else:
                    messages.error(request, "ERREUR: L'importation des équipes n'a pas réussi. Le fichier est peut être mal formé!" )
                    messages.info(request, "Indiquer le fichier .xlsx des équipes de la matière.")
                    messages.info(request, "La première ligne du fichier doit comporter au moins les colonnes suivantes: Matricule, Code.")
                    messages.info(request, "La colonne Code correspond au code de l'équipe, par ex : 17/001. La colonne Matricule correspond aux matricules des étudiants qui suivent la matière dans leur formation. Ces matricules sont séparées par un saut de ligne (ALT+Entrée sur Excel)")
                    messages.info(request, "Equipes non importées : "+str(matricule_code_non_importes))
                    render(request, 'scolar/import.html', {'form': form, 'titre':'Importer les équipes'})
            # redirect to a new URL:
            return HttpResponseRedirect(reverse('equipe_list', kwargs={'formation_pk':formation_pk, 'periode_pk':periode_pk}))
    # if a GET (or any other method) we'll create a blank form
    else:
        form = ImportFileForm()
        messages.info(request, "Indiquer le fichier .xlsx des équipes de la matière.")
        messages.info(request, "La première ligne du fichier doit comporter au moins les colonnes suivantes: Matricule, Code")
        messages.info(request, "La colonne Code correspond au code de l'équipe, par ex : 17/001. La colonne Matricule correspond aux matricules des étudiants qui suivent la matière dans leur formation. Ces matricules sont séparées par un saut de ligne (ALT+Entrée sur Excel)")
        messages.warning(request, "Assurez vous que tous les étudiants importés suivent le module de la matière dans leur spécialité.")
    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer les équipes'})

def import_sujets(request, formation_pk, periode_pk):
    
    formation_=get_object_or_404(Formation, id=formation_pk)
    module_=get_object_or_404(Module, formation__id=formation_.id)
    if request.user.is_coordinateur(module_) :
        pass
    else :
        messages.error(request, "Seul le coordinateur du module peut importer les équipes." )
        return redirect('/accounts/login/?next=%s' % request.path)
  
    if request.method == 'POST':
        form = ImportFileForm(request.POST, request.FILES)
        # check whether it's valid:
        if form.is_valid():
            try:    
                stages_file = request.FILES['file']
                dataset = Dataset()
                imported_data = dataset.load(stages_file.read(), format ='xlsx')
                form_data=form.cleaned_data
                code_stage_non_importes={}
                for row in imported_data.dict :
                    
                    try :
                        groupe_=Groupe.objects.get(section__formation__id=formation_pk, code=row.get('Code'))
                        intitule=row.get('Intitule')
                        pfe_, created=PFE.objects.update_or_create(equipe=groupe_.pfe.equipe, defaults={
                                'groupe':groupe_,
                                'intitule':intitule,
                                'notification':False
                            })   
                    except Groupe.DoesNotExist as e :
                        code_stage_non_importes[row.get('Code')]=row.get('Intitule')                    
                        messages.info(request, "Sujets non importés : "+str(code_stage_non_importes))
                        code_stage_non_importes={}
                messages.success(request, "Les sujets des équipes ont été importés ou mis à jour avec succès.")    
            except Exception as e:
                if settings.DEBUG:
                    raise e
                else:
                    messages.error(request, "ERREUR: L'importation des sujets n'a pas réussi. Le fichier est peut être mal formé!" )
                    messages.info(request, "Indiquer le fichier .xlsx des affectations de sujets "+formation_.programme.matiere_equipe.code+" ci-dessous.")
                    messages.info(request, "La première ligne du fichier doit comporter au moins colonnes suivantes: Code, Intitule")
                    messages.info(request, "La colonne Code correspond au code de l'équipe du , par ex : 17/001")
                    render(request, 'scolar/import.html', {'form': form, 'titre':'Importer les sujets et leurs affectations aux équipes'})
            # redirect to a new URL:
            return HttpResponseRedirect(reverse('notes_formation_coordinateur_detail', kwargs={'formation_pk':formation_pk, 'periode_pk':periode_pk, 'module_pk':module_.id}))
    # if a GET (or any other method) we'll create a blank form
    else:
        form = ImportFileForm()
        formation_=get_object_or_404(Formation, id=formation_pk)
        messages.info(request, "Indiquer le fichier .xlsx des affectations de sujets "+formation_.programme.matiere_equipe.code+" ci-dessous.")
        messages.info(request, "La première ligne du fichier doit comporter au moins colonnes suivantes: Code, Intitule")
        messages.info(request, "La colonne Code correspond au code de l'équipe dans la matière, par ex : 17/001")
        messages.warning(request, "Assurez vous que toutes les équipes existent déjà, sinon importez-les d'abord")
    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer les sujets et leurs affectations aux équipes'})


@login_required
def export_equipes(request, formation_pk):
    formation_=get_object_or_404(Formation, id=formation_pk)
    if request.user.has_perm('scolar.fonctionnalitenav_stages_visualisationsoutenancesequipes') or request.user.has_perm('scolar.fonctionnalitenav_pedagogie_visualisationnotes') or request.user.has_acces_visualisation_notes_programme(formation_.programme):
        pass
    else :
        try :
            module_=Module.objects.get(matiere=formation_.programme.matiere_equipe, formation=formation_)
            if request.user.is_coordinateur(module_) :
                pass
            else :
                return redirect('/accounts/login/?next=%s' % request.path)
        except Exception :
            raise Exception
    try:
        # Create the HttpResponse object with the appropriate CSV header.
        formation_=get_object_or_404(Formation, id=formation_pk)
        stages_list=PFE.objects.filter(groupe__section__formation=formation_).order_by('groupe__code')
        header=['Code','Matricule','Nom','Prenom','Specialite','Intitule','Jury1', 'Jury2', 'DateSoutenance', 'Notes']
        sheet=Dataset()
        sheet.headers = header
        for stage_ in stages_list :
            row_=[]
            row_.append(stage_.groupe.code) 
            matricule_=''
            nom_=''
            prenom_=''
            specialite_=''
            for inscription_ in stage_.equipe.inscriptions.all() :
                matricule_+=inscription_.etudiant.matricule+'\n'
                nom_+=inscription_.etudiant.nom+'\n'
                prenom_+=inscription_.etudiant.prenom+'\n'
                if inscription_.formation.programme.specialite :
                    specialite_+=inscription_.formation.programme.specialite.code
                specialite_+='\n'
            row_.append(matricule_)
            row_.append(nom_)
            row_.append(prenom_)
            row_.append(specialite_)
            row_.append(stage_.intitule)
            if Soutenance.objects.filter(groupe=stage_.groupe).count()>0 :
                row_.append(str(stage_.groupe.soutenance.assesseur1))
                row_.append(str(stage_.groupe.soutenance.assesseur2))
                row_.append(str(stage_.groupe.soutenance.date))
            else :
                row_.append(' ')
                row_.append(' ')
                row_.append(' ')
            notes_=''
            for inscription_ in stage_.equipe.inscriptions.all() :
                module_fictif=Module.objects.get(formation=stage_.groupe.section.formation, matiere=stage_.groupe.section.formation.programme.matiere_equipe)
                try :
                    resultat_=Resultat.objects.get(inscription=inscription_, module__matiere=stage_.groupe.section.formation.programme.matiere_equipe, module__periode__periode=module_fictif.periode.periode, ancien_resultat__isnull=True)
                    notes_+=str(resultat_.moy)+'\n'
                except Resultat.DoesNotExist :
                    notes_+='0'+'\n'
            row_.append(notes_)
            sheet.append(row_)

        filename='Liste_'+str(formation_.programme.code)+'.xlsx'

        response = HttpResponse(content_type='application/vnd.ms-excel')
        response['Content-Disposition'] = 'attachment; filename='+filename+";"
        response.write(sheet.xlsx)
    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            messages.error(request, "ERREUR: Il y a eu une erreur lors de l'export du fichier")
    return response


class EnseignantGroupeAllListView(GroupeAllListView):
    
    def test_func(self):
        return self.request.user.is_enseignant()
    
    def get_queryset(self,**kwargs):
        mes_activites=Activite.objects.filter(assuree_par__in=[self.request.user.enseignant]).exclude(type__startswith='E_')
        mes_groupes=[]
        for activite_ in mes_activites:
            for groupe_ in activite_.cible.all():
                if groupe_.code :
                    mes_groupes.append(groupe_.id)
                else:
                    section_=groupe_.section
                    for groupe_ in section_.groupes.filter(code__isnull=False):
                        mes_groupes.append(groupe_.id)
        return Groupe.objects.filter(section__formation__annee_univ__encours=True, id__in=mes_groupes).order_by('section__formation__programme__ordre','code')
    
class NotesFormationListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name='scolar/filter_list.html'
    
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalitenav_pedagogie_visualisationnotes') or self.request.user.has_cycles_avec_acces_visualisation_notes()
    
    def get_queryset(self,**kwargs):
        if self.request.user.has_perm('scolar.fonctionnalitenav_pedagogie_visualisationnotes') :
            return Formation.objects.all().order_by('-annee_univ__annee_univ','programme__ordre')
        elif self.request.user.has_cycles_avec_acces_visualisation_notes() :
            return Formation.objects.filter(programme__cycle__in=self.request.user.cycles_avec_acces_visualisation_notes.all()).order_by('-annee_univ__annee_univ','programme__ordre')
    
    def get_context_data(self, **kwargs):
        context = super(NotesFormationListView, self).get_context_data(**kwargs)
        
        filter_ = FormationFilter(self.request.GET, queryset=self.get_queryset(**kwargs))
        filter_.form.helper = FormHelper()
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalite_pedagogie_modificationnotes'):
            exclude_.append('edit')
            exclude_.append('admin')
        exclude_.append('moyenne_passage')
        table = NotesFormationTable(filter_.qs, exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['filter'] = filter_
        context['table'] = table
        
        context['titre'] = 'Liste des formations et Notes par période'
        context['back'] = reverse('home')
        if self.request.user.has_perm('scolar.fonctionnalite_pedagogie_modificationnotes'):
            context['import_url'] = reverse('import_notes')
            context['import_btn'] = 'Importer des Notes'
        return context

class NotesFormationPFEListView(NotesFormationListView):
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalitenav_pedagogie_visualisationnotes') or self.request.user.has_perm('scolar.fonctionnalitenav_stages_visualisationsoutenances') or self.request.user.has_perm('scolar.fonctionnalitenav_stages_visualisationsoutenancesequipes')
        
    def get_queryset(self,**kwargs):
        formations=Formation.objects.none()
        if self.request.user.has_perm('scolar.fonctionnalitenav_stages_visualisationsoutenances') :
            formations= formations | Formation.objects.filter(Q(modules__matiere__pfe=True))
        if self.request.user.has_perm('scolar.fonctionnalitenav_stages_visualisationsoutenancesequipes') :
            formations = formations | Formation.objects.filter(Q(modules__matiere__equipe=True)&Q(programme__fictif=True))
        formations = formations.order_by('-annee_univ__annee_univ','programme__ordre')
        return formations
    
class NotesFormationDetailView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name='scolar/notes_formation_detail.html'
    
    def test_func(self):
        formation_=get_object_or_404(Formation, id=self.kwargs.get('formation_pk'))
        return self.request.user.has_perm('scolar.fonctionnalitenav_pedagogie_visualisationnotes') or (Formation.objects.filter(Q(id=formation_.id)&Q(modules__matiere__pfe=True)).exists() and self.request.user.has_perm('scolar.fonctionnalitenav_stages_visualisationsoutenances')) or (Formation.objects.filter(Q(id=formation_.id)&Q(modules__matiere__equipe=True)&Q(programme__fictif=True)&Q(programme__matiere_equipe__isnull=False)).exists() and self.request.user.has_perm('scolar.fonctionnalitenav_stages_visualisationsoutenancesequipes')) or self.request.user.has_acces_visualisation_notes_programme(formation_.programme)
    
    def get_modules_suivis_query_set(self):
        return ModulesSuivis.objects.filter(module__formation=self.kwargs.get('formation_pk'), module__periode=self.kwargs.get('periode_pk'))
    
    def get_context_data(self, **kwargs):
        context = super(NotesFormationDetailView, self).get_context_data(**kwargs)
        formation_=get_object_or_404(Formation, id=self.kwargs.get('formation_pk'))
        periode_=get_object_or_404(PeriodeProgramme, id=self.kwargs.get('periode_pk'))
        etat_saisie_list={}
        if formation_.programme.matiere_equipe != None:
            equipe_list=Equipe.objects.filter(pfe__groupe__section__formation__programme__matiere_equipe__in=[formation_.programme.matiere_equipe])
            groupe_list=Groupe.objects.filter(section__formation=formation_, pfe__equipe__in=equipe_list)
        else:
            #on récupère les groues qui suivent des modules durant cette periode
            groupe_periode_list=InscriptionPeriode.objects.filter(periodepgm__periode=periode_.periode, groupe__section__formation=self.kwargs.get('formation_pk')).values('groupe') 
            #groupe_list=Groupe.objects.filter(section__formation=self.kwargs.get('formation_pk'))
            groupe_list=Groupe.objects.filter(id__in=groupe_periode_list).order_by('code')
        module_suivi_list=self.get_modules_suivis_query_set()
        module_list=[] # on construit ici la liste des modules suivis sans doublants        
        for groupe_ in groupe_list:
            module_suivi_groupe=module_suivi_list.filter(groupe=groupe_)
            for module_suivi_ in module_suivi_groupe :
                if not module_suivi_.module in module_list :
                    module_list.append(module_suivi_.module)
                key=str(groupe_.id)+'_'+str(module_suivi_.module.id)
                etat_saisie_list[key]=module_suivi_.saisie_notes
        context['formation']=formation_
        if formation_.programme.matiere_equipe != None:
            context['equipe_list']=equipe_list
        context['periode']=periode_
        context['module_list'] = module_list
        context['groupe_list'] = groupe_list
        context['etat_saisie_list'] = etat_saisie_list
        context['back'] = reverse('notes_formation_list')
        return context

class NotesFormationCoordinateurDetailView(NotesFormationDetailView):
    
    def test_func(self):
        return self.request.user.is_coordinateur( get_object_or_404(Module, id=self.kwargs.get('module_pk')))
    
    def get_modules_suivis_query_set(self):
        return ModulesSuivis.objects.filter(module=self.kwargs.get('module_pk'))
    
    def get_context_data(self, **kwargs):
        context = super(NotesFormationCoordinateurDetailView, self).get_context_data(**kwargs)
        context['coordinateur']=True
        context['back'] = reverse('coordination')
        return context

class EDTEtudiantView(LoginRequiredMixin, TemplateView):
    template_name='scolar/edt_etudiant.html'

    def get_context_data(self, **kwargs):
        context=super(EDTEtudiantView, self).get_context_data(**kwargs)
        etudiant_=self.request.user.etudiant
        inscription_list=Inscription.objects.filter(etudiant=etudiant_, formation__annee_univ__encours=True)
        edt_list=''
        groupe_inscription_list=[]
        for inscription_periode_ in InscriptionPeriode.objects.filter(inscription__in=inscription_list):
            if inscription_periode_.groupe:
                if not inscription_periode_.groupe in groupe_inscription_list:
                    groupe_inscription_list.append(inscription_periode_.groupe)
        for groupe_ in groupe_inscription_list:
            if groupe_:
                edt_list +='<br><br>'+groupe_.edt
        context['edt']=edt_list
        context['etudiant']=etudiant_
        return context   
     
class TutoratListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name='scolar/list.html'

    def test_func(self):
        return self.request.user.is_enseignant()
        
    def get_queryset(self,**kwargs):
        return Inscription.objects.filter(etudiant__tuteur = self.request.user.enseignant)
    
    def get_context_data(self, **kwargs):
        context = super(TutoratListView, self).get_context_data(**kwargs)
        table = TutoratTable(self.get_queryset(**kwargs), exclude=exclude_columns_enseignant(self.request.user))
        RequestConfig(self.request).configure(table)
        
        context['table'] = table
        context['titre'] = 'Mes tutorés'
        context['back'] = reverse('home')
        return context

class CoordinationModuleListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name='scolar/filter_list.html'

    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalitenav_pedagogie_visualisationcoordination') or self.request.user.is_enseignant()
        
    def get_queryset(self,**kwargs):
        if self.request.user.has_perm('scolar.fonctionnalitenav_pedagogie_visualisationcoordination') :
            return Module.objects.filter(formation__annee_univ__encours=True).order_by('formation__programme__ordre', 'periode__periode__code', 'matiere__code')
        elif self.request.user.is_enseignant() :
            return Module.objects.filter(coordinateur = self.request.user.enseignant, formation__annee_univ__encours=True)
        else :
            return Module.objects.none()
        
    def get_context_data(self, **kwargs):
        context = super(CoordinationModuleListView, self).get_context_data(**kwargs)
        filter_ = CoordinationModuleFilter(self.request.GET, queryset=self.get_queryset(**kwargs))
        filter_.form.helper = FormHelper()
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalite_pedagogie_gestioncoordination'):
            exclude_.append('edit')
            exclude_.append('admin')
        exclude_.append('notes')
        table = ModuleTable(filter_.qs, exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['filter'] = filter_
        context['table'] = table
        context['titre'] = 'Coordination des modules'
        context['back'] = reverse('home')
        return context

class CoordinationNotesModuleListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name='scolar/filter_list.html'

    def test_func(self):
        return self.request.user.is_enseignant()
            
    def get_queryset(self,**kwargs):
        return Module.objects.filter(coordinateur = self.request.user.enseignant, formation__annee_univ__encours=True)
        
    def get_context_data(self, **kwargs):
        context = super(CoordinationNotesModuleListView, self).get_context_data(**kwargs)
        filter_ = CoordinationModuleFilter(self.request.GET, queryset=self.get_queryset(**kwargs))
        filter_.form.helper = FormHelper()
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalite_pedagogie_gestioncoordination'):
            exclude_.append('edit')
            exclude_.append('admin')
        exclude_.append('coordonner')
        table = ModuleTable(filter_.qs, exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['filter'] = filter_
        context['table'] = table
        context['titre'] = 'Notes des groupes des modules dont j\'assure la coordination'
        context['back'] = reverse('home')
        return context

class ModuleDetailView(LoginRequiredMixin, UserPassesTestMixin, DetailView):
    model = Module
    template_name_suffix = '_detail'

    def test_func(self):
        module_=get_object_or_404(Module, id=self.kwargs.get('pk'))
        if self.request.user.has_perm('scolar.fonctionnalitenav_pedagogie_visualisationcoordination') :
            return True
        elif self.request.user.is_enseignant() :
            return assure_module(self.request.user.enseignant, module_) 
        elif self.request.user.is_etudiant() :
            return Module.objects.filter(id= module_.id, groupes_suivis__groupe__inscrits_periode__inscription__etudiant=self.request.user.etudiant).exists()
        else :
            return False
   
    def get_context_data(self, **kwargs):
        context = super(ModuleDetailView, self).get_context_data(**kwargs)
        module_=context['object']
        exclude_=[]
        if not self.request.user.is_coordinateur(module_ ):
                exclude_.append('actions')
                context['is_coordinateur']=False
        else :
            context['is_coordinateur']=True
        
        if (not module_.activation_rattrapage()) :
            exclude_.append('ponderation_rattrapage')
            
        evaluations = EvaluationTable(Evaluation.objects.filter(module=module_), exclude=exclude_)
        RequestConfig(self.request).configure(evaluations)
        context['evaluations'] = evaluations
        semainier = SemainierTable(Semainier.objects.filter(module=module_), exclude=exclude_)
        RequestConfig(self.request).configure(semainier)
        context['semainier'] = semainier

        feedback_chart_=FeedbackChart(module_pk=self.kwargs.get('pk'))
        question_list=Question.objects.all()
        context['feedback_chart'] = feedback_chart_
        context['question_list']=question_list
        context['module']=module_
        if self.request.user.is_enseignant():
            if assure_module(self.request.user.enseignant, module_):
                feedback_list=Feedback.objects.filter(module=module_, show=True)
                context['feedback_list']=feedback_list
                # alerter l'enseignant si la somme des pondérations est # de 1
                if module_.somme_ponderation() != 1 and module_.somme_ponderation() != 0:
                    messages.error(self.request,"ATTENTION! La somme des pondérations des évaluations n'est pas égale à 1. Le coordinateur(trice) devrait corriger la formule")

        return context


class SemainierDeleteView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, DeleteView):
    model = Semainier
    template_name = 'scolar/delete.html'
    success_message = "La semaine a bien été supprimée."
    
    def test_func(self):
        module_=Module.objects.get(id=self.kwargs.get('module_pk'))
        return self.request.user.is_coordinateur(module_)
    
    def get_success_url(self):
        return reverse("module_detail", kwargs={'pk':self.kwargs.get('module_pk')})


class SemainierUpdateView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, UpdateView):
    model = Semainier
    fields = ['semaine','activite_cours', 'activite_dirigee', 'observation', 'objectifs', 'matiere_competence_element']
    template_name = 'scolar/update.html'
    success_message = "La semaine a bien été modifiée."

    def test_func(self):
        module_=Module.objects.get(id=self.kwargs.get('module_pk'))
        return self.request.user.is_coordinateur(module_)
       
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        module_=Module.objects.get(id=self.kwargs.get('module_pk'))
        form.fields['matiere_competence_element']=forms.ModelChoiceField(queryset=MatiereCompetenceElement.objects.filter(matiere=module_.matiere), required=False)
        form.helper.add_input(Submit('submit', 'Modifier', css_class='btn-warning'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse("module_detail", kwargs={'pk':self.kwargs.get('module_pk')})
        
        return form

class SemainierCreateView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, CreateView):
    model = Semainier
    fields = ['module', 'semaine','activite_cours', 'activite_dirigee', 'observation', 'objectifs', 'matiere_competence_element']
    template_name = 'scolar/create.html'
    success_message = "La semaine a bien été créée."
    
    def test_func(self):
        module_=Module.objects.get(id=self.kwargs.get('module_pk'))
        return self.request.user.is_coordinateur(module_)
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        module_=Module.objects.get(id=self.kwargs.get('module_pk'))
        form.fields['module']=forms.ModelChoiceField(queryset=Module.objects.filter(id=module_.id), initial=0)
        form.fields['matiere_competence_element']=forms.ModelChoiceField(queryset=MatiereCompetenceElement.objects.filter(matiere=module_.matiere), required=False)
        form.helper.add_input(Submit('submit', 'Créer', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse("module_detail", kwargs={'pk':self.kwargs.get('module_pk')})
        
        return form

    def get_context_data(self, **kwargs):
        context = super(SemainierCreateView, self).get_context_data(**kwargs)
        context['titre'] = 'Ajouter une semaine'
        return context

class GroupeDeleteView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, DeleteView):
    model = Groupe
    template_name = 'scolar/delete.html'
    permission_required = 'scolar.fonctionnalite_planification_gestionformations'
    success_message = "Le groupe a bien été supprimé."

    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression du groupe : "+str(object_))
        return super(GroupeDeleteView, self).delete(*args, **kwargs)
        
    def get_success_url(self):
        return reverse('groupe_list', kwargs={'section_pk': str(self.kwargs.get('section_pk'))})


class GroupeUpdateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, UpdateView):
    permission_required = 'scolar.fonctionnalite_planification_gestionformations'
    model = Groupe
    fields = ['code','section', 'option', 'edt']
    template_name = 'scolar/update.html'
    success_message = "Le groupe a bien été modifié."
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        section_=Section.objects.get(id=self.kwargs.get('section_pk'))
        form.fields['section']=forms.ModelChoiceField(queryset=Section.objects.filter(formation__annee_univ=section_.formation.annee_univ, formation__programme__ordre=section_.formation.programme.ordre), initial=section_)
        groupe_=get_object_or_404(Groupe, id=self.kwargs.get('pk'))
        '''
        try:
            groupe_.pfe
            form.fields['code']=forms.CharField(max_length=10, initial=groupe_.code)
        except ObjectDoesNotExist:
            form.fields['code']=forms.ChoiceField(initial=groupe_.code, choices=CODES_GRP)
        '''
        form.fields['code'].help_text="Exemple de code de groupe : G01, G02, etc.. "
        section=get_object_or_404(Section, id=self.kwargs.get('section_pk'))
        form.fields['option']=forms.ModelMultipleChoiceField(queryset=UE.objects.filter(periode__programme=section.formation.programme, nature='OPT'), required=False)
        form.helper.add_input(Submit('submit', 'Modifier', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('groupe_list', kwargs={'section_pk': str(self.kwargs.get('section_pk'))})
        
        return form

class GroupeCreateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, CreateView):
    permission_required = 'scolar.fonctionnalite_planification_gestionformations'
    model = Groupe
    fields = ['code','section', 'option', 'edt']
    template_name = 'scolar/create.html'
    success_message = "Le groupe a bien été créé."
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        #form.fields['code']=forms.ChoiceField(choices=CODES_GRP)
        form.fields['code'].help_text="Exemple de code de groupe : G01, G02, etc.. "
        form.fields['section']=forms.ModelChoiceField(queryset=Section.objects.filter(id=self.kwargs.get('section_pk')), initial=0)
        section=get_object_or_404(Section, id=self.kwargs.get('section_pk'))
        form.fields['option']=forms.ModelMultipleChoiceField(queryset=UE.objects.filter(periode__programme=section.formation.programme, nature='OPT'), required=False)
        form.helper.add_input(Submit('submit', 'Ajouter', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('groupe_list', kwargs={'section_pk': str(self.kwargs.get('section_pk'))})
        
        return form
    def get_context_data(self, **kwargs):
        context = super(GroupeCreateView, self).get_context_data(**kwargs)
        context['titre'] = 'Ajouter un groupe'
        return context

@receiver(post_save, sender=Groupe)
def add_modules_groupe(sender, instance, created, **kwargs):
    for periode_ in instance.section.formation.programme.periodes.all():
        for ue in periode_.ues.all():
            if ue.nature=='OBL':
                for matiere_ in ue.matieres.all():
                    module_, created=Module.objects.get_or_create(matiere=matiere_, formation=instance.section.formation, periode=ue.periode, defaults={
                        'matiere':matiere_, 
                        'formation':instance.section.formation,
                        'periode':ue.periode
                        })
                    module_suivi_, created= ModulesSuivis.objects.get_or_create(module=module_, groupe=instance, defaults={
                        'module':module_,
                        'groupe':instance,
                        })

@receiver(m2m_changed, sender=Groupe.option.through)
def add_option_groupe(sender, instance, action, **kwargs):
    if action=="post_add":
            # créer les modules
            for ue in instance.option.all():
                for matiere_ in ue.matieres.all():
                    module_, created=Module.objects.get_or_create(matiere=matiere_, formation=instance.section.formation, periode=ue.periode, defaults={
                    'matiere':matiere_, 
                    'formation':instance.section.formation,
                    'periode':ue.periode
                    })
                    module_suivi_, created= ModulesSuivis.objects.get_or_create(module=module_, groupe=instance, defaults={
                                'module':module_,
                                'groupe':instance,
                                })

class EvaluationCreateView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, CreateView):
    model = Evaluation
    fields = ['type','ponderation', 'ponderation_rattrapage', 'module']
    template_name = 'scolar/create.html'
    success_message = "L'évaluation a bien été créée."
    
    def test_func(self):
        module_=get_object_or_404(Module, id=self.kwargs.get('module_pk'))

        #Si la formation est archivée ou si un PV est déjà établit alors ne pas autoriser la modification
        if module_.formation.archive or module_.pv_existe():
            messages.error(self.request, "Il n'est plus possible de modifier les notes car un PV a été établit ou la saisie est clôturée.")
            return False
        
        if self.request.user.has_perm('scolar.fonctionnalite_pedagogie_gestioncoordination'):
            return True
        elif self.request.user.is_enseignant() :
            return self.request.user.enseignant == module_.coordinateur
        else:
            return False
         
    def get_form(self, form_class=None):
        module_=get_object_or_404(Module, id=self.kwargs.get('module_pk'))
        form = super().get_form(form_class)
        form.helper = FormHelper()
        if (not module_.activation_rattrapage()) :
            form.fields['ponderation_rattrapage'].disabled=True
            form.fields['ponderation_rattrapage'].help_text="Fonctionnalité désactivée"
        form.fields['module']=forms.ModelChoiceField(queryset=Module.objects.filter(id=self.kwargs.get('module_pk')), initial=0)
        form.helper.add_input(Submit('submit', 'Ajouter', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('module_detail', kwargs={'pk': str(self.kwargs.get('module_pk'))})
        
        return form
    
    def get_context_data(self, **kwargs):
        context = super(EvaluationCreateView, self).get_context_data(**kwargs)
        context['titre'] = 'Ajouter une évaluation'
        return context

 
@login_required
def evaluation_competence_update_view(request, evaluation_pk):
    # if this is a POST request we need to process the form data
    eval_=get_object_or_404(Evaluation, id=evaluation_pk)

    if request.user.is_enseignant():
        if request.user.enseignant != eval_.module.coordinateur:
            return redirect('/accounts/login/?next=%s' % request.path)
    elif not request.user.has_perm('scolar.fonctionnalite_pedagogie_gestioncoordination'):
        return redirect('/accounts/login/?next=%s' % request.path)

    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = EvaluationCompetenceForm(eval_.id, request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:
                form_data=form.cleaned_data
                competence_element_list=form_data['competence_element']
                for competence_element_ in competence_element_list:
                    EvaluationCompetenceElement.objects.get_or_create(evaluation=eval_, competence_element=competence_element_, defaults={
                        'evaluation':eval_,
                        'competence_element':get_object_or_404(CompetenceElement, id=competence_element_),
                        'commune_au_groupe':False,
                        'ponderation':0
                    })
                competence_eval_config_, created=CompetenceEvalConfig.objects.update_or_create(evaluation=eval_, defaults={
                        'evaluation':eval_
                    })
                competence_eval_config_.A=form_data['note_A']
                competence_eval_config_.B=form_data['note_B']
                competence_eval_config_.C=form_data['note_C']
                competence_eval_config_.D=form_data['note_D']
                competence_eval_config_.E=form_data['note_E']
                competence_eval_config_.F=form_data['note_F']
                competence_eval_config_.save()
                    
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: lors de l'ajout des éléments de compétence à l'évaluation. Merci de le signaler à l'administrateur.")
            messages.success(request, "Les éléments de compétence ont bien été rajoutés à l'évaluation.")
    else:
        form = EvaluationCompetenceForm(eval_.id)
        messages.info(request, "Merci de sélectionner les éléments de compétence à rajouter à l'évaluation.")
    context={}
    qs=EvaluationCompetenceElement.objects.filter(evaluation=eval_)
    exclude_=[]
    if not request.user.has_perm('scolar.fonctionnalite_pedagogie_gestioncoordination'):
        exclude_.append('edit')
        exclude_.append('admin')
    table_ = EvaluationCompetenceElementTable(qs, exclude=exclude_)
    RequestConfig(request).configure(table_)
    context['table'] = table_
    context['form'] = form
    context['titre'] = 'Liste des éléments de compétence évalués'
    return render(request, 'scolar/form_list.html', context)

class EvaluationCompetenceElementUpdateView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, UpdateView): 
    model = EvaluationCompetenceElement
    fields=['commune_au_groupe', 'ponderation',]
    template_name = 'scolar/update.html'
    success_message = "L'élément de compétence a bien été modifié."

    def test_func(self):
        module_=Evaluation.objects.get(id=self.kwargs.get('evaluation_pk')).module
        return self.request.user.is_coordinateur( module_)
     
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url =  reverse('evaluation_competence_update', kwargs={'evaluation_pk':self.kwargs.get('evaluation_pk')})
        return form
    
    def get_context_data(self, **kwargs):
        context = super(EvaluationCompetenceElementUpdateView, self).get_context_data(**kwargs)
        context['titre'] = 'Modifier pondération de l\'élément de compétence dans l\'évaluation'
        return context

class EvaluationCompetenceElementDeleteView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, DeleteView):
    model = EvaluationCompetenceElement
    template_name= 'scolar/delete.html'
    success_message = "L'élément de compétence a bien été supprimé de l'évaluation."
    
    def test_func(self):
        module_=Evaluation.objects.get(id=self.kwargs.get('evaluation_pk')).module
        return self.request.user.is_coordinateur( module_)

    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression Evaluation Competence Element : "+str(object_))
        return super(EvaluationCompetenceElementDeleteView, self).delete(*args, **kwargs)

    def get_success_url(self):
        return reverse('evaluation_competence_update', kwargs={'evaluation_pk':self.kwargs.get('evaluation_pk')})

class EvaluationUpdateView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, UpdateView):
    model = Evaluation
    fields = ['type','ponderation', 'ponderation_rattrapage', 'module']
    template_name = 'scolar/update.html'
    success_message = "L'évaluation a bien été modifiée."

    def test_func(self):
        module_=get_object_or_404(Module, id=self.kwargs.get('module_pk'))

        #Si la formation est archivée ou si un PV est déjà établit alors ne pas autoriser la modification
        if module_.formation.archive or module_.pv_existe():
            messages.error(self.request, "Il n'est plus possible de modifier les notes car un PV a été établit ou la saisie est clôturée.")
            return False
        
        if self.request.user.has_perm('scolar.fonctionnalite_pedagogie_gestioncoordination'):
            return True
        elif self.request.user.is_enseignant() :
            return self.request.user.enseignant == module_.coordinateur
        else:
            return False
         

    def get_form(self, form_class=None):
        module_=get_object_or_404(Module, id=self.kwargs.get('module_pk'))
        form = super().get_form(form_class)
        form.helper = FormHelper()
        if (not module_.activation_rattrapage()) :
            form.fields['ponderation_rattrapage'].disabled=True
            form.fields['ponderation_rattrapage'].help_text="Fonctionnalité désactivée"
        form.fields['module']=forms.ModelChoiceField(queryset=Module.objects.filter(id=self.kwargs.get('module_pk')), initial=0, disabled=True)
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        form.helper.add_input(Button('modifier','Définir Compétences', css_class='btn-warning', onclick="window.location.href='"+reverse('evaluation_competence_update', kwargs={'evaluation_pk':self.kwargs.get('pk')})+"'"))
        self.success_url = reverse('module_detail', kwargs={'pk': str(self.kwargs.get('module_pk'))})
        
        return form

    def get_context_data(self, **kwargs):
        context = super(EvaluationUpdateView, self).get_context_data(**kwargs)
        eval_=context['object']
        context['titre'] = 'Modifier '+str(eval_.type)+' de '+str(eval_.module.matiere.code)

        return context

@receiver(post_save, sender=Evaluation)
def update_formule_resultat_moy(sender, update_fields, instance, created, **kwargs):
    for note_ in Note.objects.filter(evaluation=instance):
        note_.save()
    
class EvaluationDeleteView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, DeleteView):
    model = Evaluation
    template_name = 'scolar/delete.html'
    success_message = "L'évaluation a bien été supprimée."
    
    def test_func(self):
        module_=get_object_or_404(Module, id=self.kwargs.get('module_pk'))

        #Si la formation est archivée ou si un PV est déjà établit alors ne pas autoriser la modification
        if module_.formation.archive or module_.pv_existe():
            messages.error(self.request, "Il n'est plus possible de modifier les notes car un PV a été établit ou la saisie est clôturée.")
            return False
        
        if self.request.user.has_perm('scolar.fonctionnalite_pedagogie_gestioncoordination'):
            return True
        elif self.request.user.is_enseignant() :
            return self.request.user.enseignant == module_.coordinateur
        else:
            return False

    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression de l'évaluation : "+str(object_))
        return super(EvaluationDeleteView, self).delete(*args, **kwargs)
             
    def get_success_url(self):
        return reverse('module_detail', kwargs={'pk': str(self.kwargs.get('module_pk'))})



class SeanceCreate(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, CreateView):
    model = Seance
    fields = ['date','activite', 'rattrapage']
    template_name = 'scolar/create.html'
    success_message="La séance a bien été créée."

    def test_func(self):
        activite_=get_object_or_404(Activite, id=self.kwargs.get('activite_pk'))
        if self.request.user.is_enseignant() :
            return (self.request.user.enseignant in activite_.assuree_par.all()) or self.request.user.has_perm('scolar.fonctionnalite_planification_gestionseances')
        else :
            return self.request.user.has_perm('scolar.fonctionnalite_planification_gestionseances')
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.fields['date']=forms.DateField(input_formats = settings.DATE_INPUT_FORMATS, widget=DatePickerInput(format='%d/%m/%Y'))
        form.fields['activite']=forms.ModelChoiceField(queryset=Activite.objects.filter(id=self.kwargs.get('activite_pk')), initial=0)
        form.helper.add_input(Submit('submit', 'Ajouter', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('assiduite', kwargs={'activite_pk': str(self.kwargs.get('activite_pk'))})
        
        return form

    def get_context_data(self, **kwargs):
        context = super(SeanceCreate, self).get_context_data(**kwargs)
        context['titre'] = 'Création d\'une nouvelle séance'
        return context

class SeanceUpdateView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, UpdateView):
    model = Seance
    fields = ['date','activite', 'rattrapage']
    template_name = 'scolar/update.html'
    success_message="La séance a bien été modifiée."
    
    def test_func(self):
        activite_=get_object_or_404(Activite, id=self.kwargs.get('activite_pk'))
        if self.request.user.is_enseignant() :
            return (self.request.user.enseignant in activite_.assuree_par.all()) or self.request.user.has_perm('scolar.fonctionnalite_planification_gestionseances')
        else :
            return self.request.user.has_perm('scolar.fonctionnalite_planification_gestionseances')
        
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.fields['date']=forms.DateField(input_formats = settings.DATE_INPUT_FORMATS, widget=DatePickerInput(format='%d/%m/%Y'))
        form.fields['activite']=forms.ModelChoiceField(queryset=Activite.objects.filter(id=self.kwargs.get('activite_pk')), initial=0)
        form.helper.add_input(Submit('submit', 'Modifier', css_class='btn-warning'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('assiduite', kwargs={'activite_pk': str(self.kwargs.get('activite_pk'))})
        
        return form

class SeanceDeleteView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, DeleteView):
    model = Seance
    template_name= 'scolar/delete.html'
    success_message = "La séance a bien été supprimée."

    def test_func(self):
        activite_=get_object_or_404(Activite, id=self.kwargs.get('activite_pk'))
        if self.request.user.is_enseignant() :
            return (self.request.user.enseignant in activite_.assuree_par.all()) or self.request.user.has_perm('scolar.fonctionnalite_planification_gestionseances')
        else :
            return self.request.user.has_perm('scolar.fonctionnalite_planification_gestionseances')

    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression de la séance : "+str(object_))
        return super(SeanceDeleteView, self).delete(*args, **kwargs)
    
    def get_success_url(self):
        return reverse('assiduite', kwargs={'activite_pk': str(self.kwargs.get('activite_pk'))})


class SalleListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name='scolar/filter_list.html'
    
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalitenav_examens_gestionsalles')
    
    def get_context_data(self, **kwargs):
        context = super(SalleListView, self).get_context_data(**kwargs)
        filter_ = SalleFilter(self.request.GET, Salle.objects.all().order_by('code'))
        filter_.form.helper = FormHelper()
        context['filter']= filter_
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalitenav_examens_gestionsalles'):
            exclude_.append('edit')
            exclude_.append('admin')
        table = SalleTable(filter_.qs, exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['table'] = table
        context['btn_list'] = {
            'Créer Salle': reverse('salle_create'),
        }
        context['titre'] = "Liste des Salles"
        return context

class SalleCreateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, CreateView):
    model = Salle
    fields = '__all__'
    template_name = 'scolar/create.html'
    permission_required = 'scolar.fonctionnalitenav_examens_gestionsalles'
    success_message="La salle a bien été créée."
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.helper.add_input(Submit('submit', 'Ajouter', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('salle_list')
        
        return form

    def get_context_data(self, **kwargs):
        context = super(SalleCreateView, self).get_context_data(**kwargs)
        context['titre'] = 'Création d\'une nouvelle salle'
        return context

class SalleUpdateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, UpdateView):
    model = Salle
    fields = '__all__'
    template_name = 'scolar/update.html'
    permission_required = 'scolar.fonctionnalitenav_examens_gestionsalles'
    success_message="La salle a bien été modifiée."
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()

        form.helper.add_input(Submit('submit', 'Modifier', css_class='btn-warning'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('salle_config_update', kwargs={'salle_pk': str(self.kwargs.get('pk'))})
        
        return form

@login_required
def salle_copy_view(request, salle_pk):

    if not request.user.has_perm('scolar.fonctionnalitenav_examens_gestionsalles'):
        messages.error(request,"Vous n'êtes pas autorisés à accéder à cette fonction.")
        return redirect('/accounts/login/?next=%s' % request.path)
    try:
        salle_=get_object_or_404(Salle, id=salle_pk)
        nouvelle_salle_=Salle.objects.create(
                code=salle_.code,
                version=salle_.version+'???',
                nb_lignes=salle_.nb_lignes,
                nb_colonnes=salle_.nb_colonnes,
                calendarId=salle_.calendarId
            )
    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            messages.error(request, "ERREUR: lors de la copie de la salle.")
            HttpResponseRedirect(reverse('salle_list'))
    messages.success(request, "Une copie de la salle a bien été créée.")
    
    return HttpResponseRedirect(reverse('salle_update', kwargs={'pk':nouvelle_salle_.id}))
    
    
@login_required
def salle_config_update_view(request, salle_pk):
    # if this is a POST request we need to process the form data
    

    if not request.user.has_perm('scolar.fonctionnalitenav_examens_gestionsalles'):
        messages.error(request,"Vous n'êtes pas autorisés à accéder à cette fonction.")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    salle_=get_object_or_404(Salle, id=salle_pk)
    

    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = SalleConfigForm(salle_pk, request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:
                form_data=form.cleaned_data

                # supprimer les rangés et colonnes si le nombre de lignes ou de colonnes a été modifié
                # supprimer toutes les places dont le num_ligne ou num_colonne n'est pas dans les lignes et colonnes prévues dans la salle
                Place.objects.filter(salle=salle_).exclude(Q(num_ligne__in=salle_.ligne_list()) & Q(num_colonne__in=salle_.colonne_list())).delete()
                
                # Mise à jour des places de la salle
                for place_ in salle_.places.all():
                    place_.code=form_data[str(place_.num_ligne)+'_'+place_.num_colonne+'_code']
                    place_.disponible=form_data[str(place_.num_ligne)+'_'+place_.num_colonne+'_disponible']
                    place_.save()
                
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: lors de la configuration de la salle.")
                    HttpResponseRedirect(reverse('salle_config_update'), kwargs={'pk':salle_pk})
            messages.success(request, "La configuration de la salle a bien été mise à jour.")
            
            return HttpResponseRedirect(reverse('salle_list'))
        else:
            context={}
            context['salle'] = salle_
            context['form'] = form
            context['titre'] = "Configuration de la salle "+salle_.code
            return render(request, 'scolar/salle_config_update.html', context)
    else:
        form = SalleConfigForm(salle_pk)
        messages.info(request, "Merci d'utiliser ce formulaire pour configurer la salle.")
        context={}
        context['salle'] = salle_
        context['form'] = form
        context['titre'] = "Configuration de la salle "+salle_.code
        return render(request, 'scolar/salle_config_update.html', context)


class SalleDeleteView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, DeleteView):
    model = Salle
    template_name= 'scolar/delete.html'
    permission_required = 'scolar.fonctionnalitenav_examens_gestionsalles'
    success_message = "La salle a bien été supprimée."

    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression de la salle : "+str(object_))
        return super(SalleDeleteView, self).delete(*args, **kwargs)
    
    def get_success_url(self):
        return reverse('salle_list')



class ExamenListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name='scolar/filter_list.html'
    
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalitenav_examens_visualisationexamens')
    
    def get_context_data(self, **kwargs):
        context = super(ExamenListView, self).get_context_data(**kwargs)
        filter_ = ExamenFilter(self.request.GET, Seance.objects.filter(activite__type__startswith="E_").order_by('-date', 'heure_debut'))
        filter_.form.helper = FormHelper()
        context['filter']= filter_
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalite_examens_gestionexamens'):
            exclude_.append('edit')
            exclude_.append('admin')
        table = ExamenTable(filter_.qs, exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['table'] = table
        btn_list={}
        if self.request.user.has_perm('scolar.fonctionnalite_examens_gestionexamens') :
            btn_list.update({'Créer Examen': reverse('examen_create') })
            btn_list.update({'Placement Etudiants': reverse('placement_etudiants_examens')})
            btn_list.update({'PV Examen par Salle': reverse('pv_salle_examen_list')})
            btn_list.update({'Affichage Répartition': reverse('affichage_convocations_examens')})
            btn_list.update({'Affichage Reprographie': reverse('affichage_reprographie')})
            btn_list.update({'Affichage Surveillance': reverse('affichage_surveillance')})
            btn_list.update({'Envoi Convocations Etudiants': reverse('authorize_envoi_convocations_examens_etudiants')})
            btn_list.update({'Envoi Convocations Enseignants': reverse('authorize_envoi_convocations_examens_enseignants')})
        if self.request.user.has_perm('scolar.fonctionnalitenav_examens_visualisationsurveillance') :
            btn_list.update({'PV Examen par Salle': reverse('pv_salle_examen_list')})
            btn_list.update({'Affichage Surveillance': reverse('affichage_surveillance')})
        if self.request.user.has_perm('scolar.fonctionnalite_examens_visualisationreprographie') :
            btn_list.update({'Affichage Reprographie': reverse('affichage_reprographie')})
        if self.request.user.has_perm('scolar.fonctionnalitenav_examens_visualisationplacesetudiants') :
            btn_list.update({'Affichage Répartition': reverse('affichage_convocations_examens')})
            
        context['btn_list']=btn_list
        context['titre'] = "Liste des examens"
        return context

class PlaceEtudiantListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name='scolar/filter_list.html'
    
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalitenav_examens_visualisationplacesetudiants')
    
    def get_context_data(self, **kwargs):
        context = super(PlaceEtudiantListView, self).get_context_data(**kwargs)
        filter_ = PlaceEtudiantFilter(self.request.GET, ReservationPlaceEtudiant.objects.filter(seance__activite__module__formation__annee_univ__encours=True
                                                                                                ).order_by('seance__activite__module__formation__programme__ordre', 
                                                                                                           'seance__activite__module__matiere__code',
                                                                                                           '-seance__date', 
                                                                                                           'seance__heure_debut',
                                                                                                           'inscription__etudiant__nom',
                                                                                                           'inscription__etudiant__prenom'))
        filter_.form.helper = FormHelper()
        context['filter']= filter_
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalite_examens_gestionexamens'):
            exclude_.append('edit')
            exclude_.append('admin')
        table = PlaceEtudiantTable(filter_.qs, exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['table'] = table
        context['titre'] = "Liste des affectations des étudiants aux places d'examens"
        return context




@login_required
def place_etudiant_update_view(request, pk):
    # if this is a POST request we need to process the form data
    

    if not request.user.has_perm('scolar.fonctionnalite_examens_gestionexamens'):
        messages.error(request,"Vous n'êtes pas autorisés à accéder à cette fonction.")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    reservation_=get_object_or_404(ReservationPlaceEtudiant, id=pk)
    

    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = ReservationPlaceEtudiantUpdateForm(pk, request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:
                form_data=form.cleaned_data

                reservation_.place=form_data['place']
                reservation_.save()
                
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: lors de la modification de la place d'examen.")
                    HttpResponseRedirect(reverse('place_etudiant_list'))
            messages.success(request, "La modification de la place d'examen a bien été effectuée.")
            
            return HttpResponseRedirect(reverse('place_etudiant_list'))
        else:
            context={}
            context['object'] = reservation_
            context['form'] = form
            return render(request, 'scolar/update.html', context)
    else:
        form = ReservationPlaceEtudiantUpdateForm(pk)
        messages.info(request, "Merci d'utiliser ce formulaire pour modifier la place d'examen.")
        context={}
        context['object'] = reservation_
        context['form'] = form
        return render(request, 'scolar/update.html', context)

# class PlaceEtudiantUpdateView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, UpdateView):
#     model = ReservationPlaceEtudiant
#     fields = ['inscription', 'seance', 'place']
#     template_name = 'scolar/update.html'
#     success_message = "La place de l'étudiant a été modifiée avec succès!"
#     
#     def test_func(self):
#         return self.request.user.is_direction() or self.request.user.is_scolarite()
#         
#      
#     def get_form(self, form_class=None):
#         form = super().get_form(form_class)
#         form.helper = FormHelper()
#         try:
#             form.fields['inscription'].widget.attrs['readonly'] = True
#             form.fields['seance'].widget.attrs['readonly'] = True
#             reservation_=get_object_or_404(ReservationPlaceEtudiant, id=self.kwargs.get('pk'))
#             place_reservee_list=ReservationPlaceEtudiant.objects.filter(seance=reservation_.seance).values_list('place')
#             form.fields['place'] = forms.ModelChoiceField(
#                         queryset=Place.objects.filter(salle__in=reservation_.seance.salles.all(), disponible=True).exclude(id__in=place_reservee_list),
#                           
#                         label=u"Place",
#                         widget=ModelSelect2Widget(
#                             model=Place,
#                             search_fields=['salle__code__icontains','code__icontains'],
#                         ),
#                         help_text = "Choisir une place. Tapez deux espaces pour avoir toute la liste.",
#                         required = True
#                         )
#   
#             form.helper.add_input(Submit('submit','Enregistrer', css_class='btn-primary'))
#             form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
#             self.success_url = reverse('place_etudiant_list')
#         except Exception:
#             if settings.DEBUG:
#                 raise Exception
#             else:
#                 messages.error(self.request, "ERREUR: lors de la modification de la place d'examen de l'étudiant.")
#       
#         return form


@login_required
def export_place_list(request):
    if not request.user.has_perm('scolar.fonctionnalitenav_examens_exportatonlisteplaces'):
        messages.error(request, "Vous n'êtes pas autorisés à accéder à cette fonctionnalité")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    try:
        # Create the HttpResponse object with the appropriate CSV header.
        place_list=Place.objects.filter(disponible=True).order_by('salle__code', 'salle__version','num_ligne','num_colonne')
        header=['Salle','Version', 'Place']
        sheet=Dataset()
        sheet.headers = header
    
        for place_ in place_list :
            row_=[]
            row_.append(place_.salle.code)
            row_.append(place_.salle.version)
            row_.append(place_.code)
            sheet.append(row_)
            
        filename='LISTE_PLACES_EXAMEN.xlsx'

        response = HttpResponse(content_type='application/vnd.ms-excel')
        response['Content-Disposition'] = 'attachment; filename='+filename+";"
        response.write(sheet.xlsx)
    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            messages.error(request, "ERREUR: Il y a eu une erreur lors de l'export du fichier des places d'examens. Merci de le signaler à l'administrateur.")
    return response



class SurveillanceListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name='scolar/filter_list.html'
    
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalitenav_examens_visualisationsurveillance')
    
    def get_context_data(self, **kwargs):
        context = super(SurveillanceListView, self).get_context_data(**kwargs)
        filter_ = SurveillanceFilter(self.request.GET, SurveillanceEnseignant.objects.filter(seance__activite__module__formation__annee_univ__encours=True
                                                                                                ).order_by('-seance__date', 
                                                                                                           'seance__heure_debut',
                                                                                                           'enseignant__nom',
                                                                                                           'seance__activite__module__formation__programme__ordre', 
                                                                                                           'seance__activite__module__matiere__code',))
        filter_.form.helper = FormHelper()
        context['filter']= filter_
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalite_examens_gestionexamens'):
            exclude_.append('edit')
            exclude_.append('admin')
        table = SurveillanceTable(filter_.qs, exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['table'] = table
        context['titre'] = "Liste des surveillances d'examens"
        context['btn_list'] = {
                'Export Excel':reverse('export_surveillance_list')
            }
        return context

@login_required
def export_surveillance_list(request):
    if not request.user.has_perm('scolar.fonctionnalitenav_examens_visualisationsurveillance'):
        return redirect('/accounts/login/?next=%s' % request.path)

    
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = SurveillanceListSelectForm(request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:
                form_data=form.cleaned_data
                
                # Sélectionner les examens des formations compris dans l'intervalle des dates indiquées
                surveillance_list = SurveillanceEnseignant.objects.filter(seance__activite__type__in=form_data['activite_type_list'],
                                                    seance__activite__module__formation__in=form_data['formation_list'],
                                                   seance__date__gte=form_data['date_debut'],
                                                   seance__date__lte=form_data['date_fin']
                                                   ).order_by('enseignant__nom', 'enseignant__prenom', 'seance__date', 'seance__heure_debut')

                header=['ENSEIGNANT', 'MODULE', 'FORMATION', 'DATE', 'HEURE DEBUT', 'HEURE FIN', 'SALLE', ]
                sheet=Dataset()
                sheet.headers = header
            
                for surveillance_ in surveillance_list :
                    row_=[]
                    row_.append(surveillance_.enseignant)
                    row_.append(surveillance_.seance.activite.module.matiere.code)
                    row_.append(surveillance_.seance.activite.module.formation.programme.code)
                    row_.append(JOUR_LIST[int(surveillance_.seance.date.strftime('%w'))] +' '+surveillance_.seance.date.strftime('%d/%m/%Y'))
                    row_.append(surveillance_.seance.heure_debut.strftime('%H:%M'))
                    row_.append(surveillance_.seance.heure_fin.strftime('%H:%M'))
                    row_.append(surveillance_.salle.code)
                    sheet.append(row_)
                    
                filename='Liste_Surveillances.xlsx'
        
                response = HttpResponse(content_type='application/vnd.ms-excel')
                response['Content-Disposition'] = 'attachment; filename='+filename+";"
                response.write(sheet.xlsx)
                
                return response
            
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: lors de la construction de la liste des surveillances.")
                    return HttpResponseRedirect(reverse('surveillance_list'))
    else:
        form = SurveillanceListSelectForm()
        
        
        messages.info(request, "Merci de renseigner le formulaire pour sélectionner les examens .")
        context={}
        context['form'] = form

        context['titre'] = "Sélection des examens"
        return render(request, 'scolar/import.html', context)
        

class SurveillanceUpdateView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, UpdateView):
    model = SurveillanceEnseignant
    fields = ['seance', 'salle', 'enseignant']
    template_name = 'scolar/update.html'
    success_message = "La surveillance a été modifiée avec succès!"
    
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalite_examens_gestionexamens')
     
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        try:
            
            form.fields['seance'].widget.attrs['readonly'] = True
            form.fields['salle'].widget.attrs['readonly'] = True
            
            surveillance_=get_object_or_404(SurveillanceEnseignant, id=self.kwargs.get('pk'))

            seance_chevauchement_list=Seance.objects.filter(date=surveillance_.seance.date).exclude(
                                                                            heure_debut__gte=surveillance_.seance.heure_fin
                                                                        ).exclude(
                                                                            heure_fin__lte=surveillance_.seance.heure_debut
                                                                        )
            enseignant_occupe_list=[]
            for seance_chevauchement_ in seance_chevauchement_list:
                for enseignant_occupe_ in seance_chevauchement_.activite.assuree_par.all():
                    if not enseignant_occupe_ in enseignant_occupe_list:
                        enseignant_occupe_list.append(enseignant_occupe_.id)
        
#         
#             enseignant_charge_list=[] 
#             for enseignant_ in Enseignant.objects.all().order_by('nom','prenom'):
#                 if not enseignant_ in enseignant_occupe_list: 
#                     enseignant_charge_list.append((enseignant_, str(enseignant_)+" (Charge= "+str(enseignant_.ratio_charge_annuelle_encours())+"% ) "+
#                                                "Surveillances (Nb= "+str(enseignant_.nb_surveillances())+
#                                                 " VH= "+str(enseignant_.vh_surveillances())+")"))
#             #Ajouter l'enseignant surveillant en cours à la liste
#             enseignant_charge_list.append((surveillance_.enseignant, str(surveillance_.enseignant)+" (Charge= "+str(surveillance_.enseignant.ratio_charge_annuelle_encours())+"% ) "+
#                                                "Surveillances (Nb= "+str(surveillance_.enseignant.nb_surveillances())+
#                                                 " VH= "+str(surveillance_.enseignant.vh_surveillances())+")"))
            form.fields['enseignant'] = forms.ModelChoiceField(
                        queryset=Enseignant.objects.all().exclude(id__in=enseignant_occupe_list),
                        initial = surveillance_.enseignant,
                        label=u"Surveillant",
                        widget=Select2Widget,
                        help_text = "Choisir un enseignant. Tapez deux espaces pour avoir toute la liste.",
                        required = True
                        )

            form.helper.add_input(Submit('submit','Enregistrer', css_class='btn-primary'))
            form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
            self.success_url = reverse('surveillance_list')
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors de la modification de la place d'examen de l'étudiant.")
    
        return form


@login_required
def examen_create_view(request):
    # if this is a POST request we need to process the form data
    

    if not request.user.has_perm('scolar.fonctionnalite_examens_gestionexamens'):
        messages.error(request,"Vous n'êtes pas autorisés à accéder à cette fonction.")
        return redirect('/accounts/login/?next=%s' % request.path)

    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = ExamenCreateForm(request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:
                form_data=form.cleaned_data
                module_=form_data['module']
                # Créer activite et seance correspondants à l'examen
                activite_= Activite.objects.create(
                        module=module_,
                        type=form_data['type_activite'],
                        vh=form_data['duree'].hour + form_data['duree'].minute/60,
                        repeter_chaque_semaine=False,
                    )
                # rajouter les groupes concernés par l'examen
                for groupe_ in form_data['groupes']:
                    if  groupe_.code:
                        if not groupe_ in activite_.cible.all():
                            activite_.cible.add(groupe_)
                    else:
                        # Il s'agit d'une section
                        for grpe_ in groupe_.section.groupes.all():
                            if  not grpe_ in activite_.cible.all() and grpe_.code :
                                activite_.cible.add(grpe_)                            
                heure_fin_=datetime.datetime(2020, 1, 1, 0, 0) + datetime.timedelta(hours = form_data['heure_debut'].hour, minutes = form_data['heure_debut'].minute) + datetime.timedelta(hours = form_data['duree'].hour, minutes = form_data['duree'].minute) #
                heure_fin_=heure_fin_.time()
                
                seance_, created = Seance.objects.update_or_create(activite=activite_, date=form_data['date'], defaults={
                        'activite':activite_,
                        'date': form_data['date'],
                        'heure_debut':form_data['heure_debut'],
                        'heure_fin':heure_fin_,
                    })
                
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: lors de planification d'un examen.")
                    HttpResponseRedirect(reverse('examen_list'))
            messages.success(request, "L'examen a bien été planifié.")
            
            return HttpResponseRedirect(reverse('seance_salles_reservation', kwargs={'seance_pk': seance_.id}))
            
        else:
            context={}
            context['form'] = form
            context['titre'] = "Planification d'un examen."
            return render(request, 'scolar/import.html', context)
    else:
        form = ExamenCreateForm()
        messages.info(request, "Merci de renseigner le formulaire pour planifier l'examen.")
        context={}
        context['form'] = form
        context['titre'] = "Planification d'un examen."
        return render(request, 'scolar/import.html', context)

@login_required
def examen_update_view(request, seance_pk):
    # if this is a POST request we need to process the form data
    

    if not request.user.has_perm('scolar.fonctionnalite_examens_gestionexamens'):
        messages.error(request,"Vous n'êtes pas autorisés à accéder à cette fonction.")
        return redirect('/accounts/login/?next=%s' % request.path)

    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = ExamenUpdateForm(seance_pk, request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:
                seance_=get_object_or_404(Seance, id=seance_pk)
                form_data=form.cleaned_data
                
                # Créer activite et seance correspondants à l'examen
                seance_.activite.type=form_data['type_activite']
                seance_.activite.vh=form_data['duree'].hour + form_data['duree'].minute/60
                
                seance_.activite.save()
                # supprimer puis rajouter les groupes concernés par l'examen
                for groupe_ in seance_.activite.cible.all():
                    seance_.activite.cible.remove(groupe_)
                for groupe_ in form_data['groupes']:
                    if  groupe_.code:
                        if not groupe_ in seance_.activite.cible.all():
                            seance_.activite.cible.add(groupe_)
                    else:
                        # Il s'agit d'une section
                        for grpe_ in groupe_.section.groupes.all():
                            if  not grpe_ in seance_.activite.cible.all() and grpe_.code:
                                seance_.activite.cible.add(grpe_)                            

                heure_fin_=datetime.datetime(2020, 1, 1, 0, 0) + datetime.timedelta(hours = form_data['heure_debut'].hour, minutes = form_data['heure_debut'].minute) + datetime.timedelta(hours = form_data['duree'].hour, minutes = form_data['duree'].minute) #
                heure_fin_=heure_fin_.time()
                
                seance_.date=form_data['date']
                seance_.heure_debut=form_data['heure_debut']
                seance_.heure_fin=heure_fin_
                seance_.save()
                
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: lors de planification d'un examen.")
                    HttpResponseRedirect(reverse('examen_list'))
            messages.success(request, "L'examan a bien été modifié.")
            
            return HttpResponseRedirect(reverse('seance_salles_reservation', kwargs={'seance_pk': seance_.id}))
        else:
            context={}
            context['form'] = form
            context['titre'] = "Planification d'un examen."
            return render(request, 'scolar/import.html', context)
    else:
        form = ExamenUpdateForm(seance_pk)
        messages.info(request, "Merci de renseigner le formulaire pour planifier l'examen.")
        context={}
        context['form'] = form
        context['titre'] = "Planification d'un examen."
        return render(request, 'scolar/import.html', context)

class ExamenDeleteView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, DeleteView):
    permission_required = 'scolar.fonctionnalite_examens_gestionexamens'
    model = Activite
    template_name = 'scolar/delete.html'
    success_message = "L'examen a bien été supprimé."

    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression de l'examen : "+str(object_))
        return super(ExamenDeleteView, self).delete(*args, **kwargs)
    
    def get_success_url(self):
        return reverse('examen_list')

@login_required
def seance_salles_reservation(request, seance_pk):
    # if this is a POST request we need to process the form data
    seance_=get_object_or_404(Seance, id=seance_pk)

    if not request.user.has_perm('scolar.fonctionnalite_examens_gestionexamens'):
        messages.error(request,"Vous n'êtes pas autorisés à accéder à cette fonction.")
        return redirect('/accounts/login/?next=%s' % request.path)

    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = SeanceSallesReservationForm(seance_pk, request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:
                form_data=form.cleaned_data
                # Supprimer pui Ajouter les salles sélectionnées à la séance
                seance_.salles.clear()
                for salle_id_ in form_data['salles']:
                    salle_=get_object_or_404(Salle, id=salle_id_)
                    seance_.salles.add(salle_)
                #seance_.save()
                if seance_.activite.nb_etudiants()<=seance_.capacite_reservee():
                    seance_.save()
                else:
                    seance_.salles.clear()
                    messages.error(request,"Capacité des salles sélectionnées inferieur au nombre d'étudiants indiqué.")
                    return HttpResponseRedirect(reverse('seance_salles_reservation', kwargs={'seance_pk': seance_.id}))     
                # Supprimer les surveillances qui avaient été prévues dans des salles retirées à cet examen
                SurveillanceEnseignant.objects.filter(seance=seance_).exclude(salle__in=seance_.salles.values_list('id')).delete()
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: lors de la réservation de salles.")
                    HttpResponseRedirect(reverse('examen_list'))
            messages.success(request, "Les salles ont bien été réservées.")
            
            #return HttpResponseRedirect(reverse('placer_surveillants_etudiants', kwargs={'seance_pk': seance_.id})) 
            return HttpResponseRedirect(reverse('examen_list'))
    else:
        form = SeanceSallesReservationForm(seance_pk)
        messages.info(request, "Merci de renseigner le formulaire pour réserver les salles.")
        context={}
        context['salles']=Salle.objects.all()
        context['form'] = form
        context['titre'] = "Réservtaion de salles."
        return render(request, 'scolar/seance_salles_reservation.html', context)


@login_required
def placement_etudiants_examens_view(request):
    # if this is a POST request we need to process the form data

    if not request.user.has_perm('scolar.fonctionnalite_examens_gestionexamens'):
        messages.error(request,"Vous n'êtes pas autorisés à accéder à cette fonction.")
        return redirect('/accounts/login/?next=%s' % request.path)

    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = ExamenListSelectForm(request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:
                form_data=form.cleaned_data
                examen_list = form_data['examen_list']

                # lancer la réservation des places aléatoires en tâche de fond
                t = threading.Thread(target=task_placement_etudiants,args=[examen_list, request.user])
                t.setDaemon(True)
                t.start()

            
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: lors de la sélection des examens pour placement groupé.")
                    HttpResponseRedirect(reverse('examen_list'))
            messages.success(request, "La répartition des étudiants sur les places d'examen est lancée.")
            messages.success(request, "Vous recevrez une notification une fois la tâche terminée")
            
            return HttpResponseRedirect(reverse('examen_list')) 
    else:
        form = ExamenListSelectForm()
        messages.info(request, "Merci de renseigner le formulaire pour réserver les salles.")
        context={}
        context['salles']=Salle.objects.all()
        context['form'] = form
        context['titre'] = "Réservtaion de salles."
        return render(request, 'scolar/import.html', context)

# Ce signal permet de supprimer la charge d'un enseignant retiré de la surveillance
@receiver(pre_delete, sender=SurveillanceEnseignant)
def update_activite_surveillance_delete(sender, instance, **kwargs):
    instance.seance.activite.assuree_par.remove(instance.enseignant)

#just test
@transaction.atomic
def task_placement_etudiants(examen_list, user):
    try:
        
        # Trier la liste des examens dans l'ordre croissant du nombre de salles
        sorted_examen_list=[]
        for examen_ in examen_list:
            #annoter chaque inscrit de sa moyenne
            item={}
            item['examen']=examen_
            item['nb_salles']=examen_.salles.count()
            sorted_examen_list.append(item)
        sorted_examen_list.sort(key=operator.itemgetter('nb_salles'))
        
        examen_list=[]
        for item in sorted_examen_list:
            examen_list.append(item['examen'])
                
        # collecter toute les places disponible dans une liste par examen
        place_disponible_list={}
        
        
        for examen_ in examen_list:
            if not examen_ in place_disponible_list.keys():
                place_disponible_list[examen_]=[]

            for salle_ in examen_.salles.all():
                for place_ in salle_.place_disponible_list():
                    place_disponible_list[examen_].append(place_)
            # trier la liste des places d'une façon aléatoire
            random.shuffle(place_disponible_list[examen_])
        
        # Supprimer les anciennes réservation 
        ReservationPlaceEtudiant.objects.filter(seance__in=examen_list).delete()
        
        #stocker les listes d'inscrits par examen
        examen_inscrit_list={}
        for examen_ in examen_list:
            examen_inscrit_list[examen_] = examen_.activite.inscrits_activite()
            
        # Réserver une place pour chaque inscription pour tous les examens dans la liste
        reservation_list={}
        for examen_ in examen_list:
            if not examen_ in reservation_list.keys():
                reservation_list[examen_]={}
            
            for inscription_ in examen_inscrit_list[examen_]:
                #Si aucune place n'est attribuée alors trouver une place et l'affecter à l'étudiant pour tous les examens qu'il pourra passer à cette place
                if not inscription_.etudiant.matricule in reservation_list[examen_].keys():
                    try:
                        place_ = place_disponible_list[examen_].pop()
                        # attribuer la même place dans les autres examens si la salle est commune
                        reservation_list[examen_][inscription_.etudiant.matricule]=place_
                        ReservationPlaceEtudiant.objects.update_or_create(seance=examen_, inscription=inscription_, defaults={
                            'seance': examen_,
                            'inscription':inscription_,
                            'place':place_,
                        })
                        for autre_examen_ in examen_list:
                            if autre_examen_ != examen_:
                                if not autre_examen_ in reservation_list.keys():
                                    reservation_list[autre_examen_]={}
                                if inscription_ in examen_inscrit_list[autre_examen_] and not inscription_.etudiant.matricule in reservation_list[autre_examen_].keys():
                                    #if place_.salle.code in [salle_.code for salle_ in autre_examen_.salles.all()]:
                                    if place_ in place_disponible_list[autre_examen_]:
                                        try:
                                            print("affecter même place")
                                            place_disponible_list[autre_examen_].remove(place_)
                                            reservation_list[autre_examen_][inscription_.etudiant.matricule]=place_
                                            ReservationPlaceEtudiant.objects.update_or_create(seance=autre_examen_, inscription=inscription_, defaults={
                                                'seance':autre_examen_,
                                                'inscription':inscription_,
                                                'place':place_,
                                            })
                                        except Exception:
                                            continue
                    except Exception:
                        raise Exception("ERREUR: Nombre de places insuffisant")
    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            if activation_emails():
                email = EmailMessage('[Talents] Erreur Réservation Places Etudiants '+str(examen_),
                                     'Bonjour,\n'+ 
                                     'Une erreur s\'est produite lors de la réservation des places aux étudiants\n'+ 
                                     'Merci de vérifier les capacités des salles\n'
                                     'Bien cordialement.\n'+
                                     signature_emails(), to=[user.get_email()] )
                email.send(fail_silently=True)
            else:
                print("ERREUR: Reservation Places Etudiants")
    else:
        if activation_emails():
            email = EmailMessage('[Talents] Réservation Places Etudiants ',
                             'Bonjour,\n'+ 
                             'La réservation des places aux étudiants pour passer les examens est effectuée avec succès'+'\n'+ 
                             'Bien cordialement.\n'+
                             signature_emails(), to=[user.get_email()] )
            email.send(fail_silently=True)
        else:
            print("Reservation Places Etudiants avec Succès!")

@login_required
def placer_surveillants_update(request, seance_pk):
    # if this is a POST request we need to process the form data
    seance_=get_object_or_404(Seance, id=seance_pk)

    if not request.user.has_perm('scolar.fonctionnalite_examens_gestionexamens'):
        messages.error(request,"Vous n'êtes pas autorisés à accéder à cette fonction.")
        return redirect('/accounts/login/?next=%s' % request.path)

    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = SurveillanceUpdateForm(seance_pk, request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:
                form_data=form.cleaned_data
                # Ajouter les surveillance, ajouter les enseignants à activite.assuree_par --> charges
                # Supprimer les charges et surveillances
                SurveillanceEnseignant.objects.filter(seance=seance_).delete()
                
                for salle_ in seance_.salles.all():
                    for surveillant_id_ in form_data[salle_.code]:
                        # rajouter le surveillant à activite.assuree_par
                        enseignant_=get_object_or_404(Enseignant, id=surveillant_id_)
                        seance_.activite.assuree_par.add(enseignant_)
                        
                        SurveillanceEnseignant.objects.update_or_create(seance=seance_, enseignant=enseignant_, defaults={
                                'seance':seance_,
                                'enseignant':enseignant_,
                                'salle':salle_
                            })
                        
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: lors du placement des surveillants  en salles.")
                    return HttpResponseRedirect(reverse('examen_list'))
            messages.success(request, "Les surveillants ont bien été affectées aux salles.")
            
            return HttpResponseRedirect(reverse('examen_list')) 
    else:
        form = SurveillanceUpdateForm(seance_pk)
        messages.info(request, "Merci de renseigner le formulaire pour affecter des surveillants aux salles.")
        context={}
        context['form'] = form
        context['titre'] = "Affectation de surveillants."
        return render(request, 'scolar/import.html', context)

class PVExamenListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name='scolar/pv_examen_list.html'
     
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalitenav_examens_visualisationexamens')
     
    def get_context_data(self, **kwargs):
        context = super(PVExamenListView, self).get_context_data(**kwargs)
        seance_=get_object_or_404(Seance, id=self.kwargs.get("seance_pk"))
        pv_list={}
        for salle_ in seance_.salles.all():
            # construire la liste des places réservées dans la salle
            pv_list[salle_]={
                'surveillance_enseignant_list': SurveillanceEnseignant.objects.filter(seance=seance_, salle=salle_).order_by('enseignant__nom')
            }
        context['pv_list'] = pv_list
        context['seance'] = seance_
        return context

@login_required
def authorize_envoi_convocations_examens_enseignants_view(request):
    # if this is a POST request we need to process the form data
    if not request.user.has_perm('scolar.fonctionnalite_examens_gestionexamens'):
        messages.error(request,"Vous n'êtes pas autorisés à accéder à cette fonction.")
        return redirect('/accounts/login/?next=%s' % request.path)

    flow = Flow.from_client_secrets_file(
        settings.GOOGLE_CLIENT_SECRET_FILE,
        scopes=settings.SCOPES,
        redirect_uri=settings.PROTOCOLE_HOST+reverse('callback_envoi_convocations_examens_enseignants'))
    authorization_url, state = flow.authorization_url(
        access_type='offline',
        prompt='consent',
        include_granted_scopes='false')
    return redirect(authorization_url)
    
        
def callback_envoi_convocations_examens_enseignants_view(request):
    # if this is a POST request we need to process the form data
    if not request.user.has_perm('scolar.fonctionnalite_examens_gestionexamens'):
        messages.error(request,"Vous n'êtes pas autorisés à accéder à cette fonction.")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    state = request.GET.get('state')
    
    flow = Flow.from_client_secrets_file(
        settings.GOOGLE_CLIENT_SECRET_FILE,
        scopes=settings.SCOPES,
        state=state,
        redirect_uri=settings.PROTOCOLE_HOST+reverse('callback_envoi_convocations_examens_enseignants'))
    
    #authorization_response = request.build_absolute_uri
    flow.fetch_token(code=request.GET.get('code'))
    # Store credentials in the session.
    # ACTION ITEM: In a production app, you likely want to save these
    #              credentials in a persistent database instead.
    credentials = flow.credentials
    request.session['credentials'] = credentials_to_dict(credentials)
    return HttpResponseRedirect(reverse('envoi_convocations_examens_enseignants'))


#TODO planifier l'envoie d'un SMS de rappel le jour de la surveillance à 7h
@login_required
def envoi_convocations_examens_enseignants_view(request):
    # if this is a POST request we need to process the form data
    if not request.user.has_perm('scolar.fonctionnalite_examens_gestionexamens'):
        messages.error(request,"Vous n'êtes pas autorisés à accéder à cette fonction.")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    if 'credentials' not in request.session:
        return redirect('/scolar/authorize_envoi_convocations_examens_enseignants')

    # Load credentials from the session.
    credentials_dict=request.session['credentials']
    credentials = Credentials(
        credentials_dict["token"],
        refresh_token = credentials_dict["refresh_token"],
        token_uri = credentials_dict["token_uri"],
        client_id = credentials_dict["client_id"],
        client_secret = credentials_dict["client_secret"],
        scopes = credentials_dict["scopes"]
        )
 
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = ExamenSelectForm(request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:
                form_data=form.cleaned_data                
                
                
                service = build("calendar", "v3", credentials=credentials)                
                # Sélectionner les examens des formations compris dans l'intervalle des dates indiquées
                examen_list = Seance.objects.filter(activite__type__in=form_data['activite_type_list'],
                                                    activite__module__formation__in=form_data['formation_list'],
                                                   date__gte=form_data['date_debut'],
                                                   date__lte=form_data['date_fin']
                                                   ).order_by('date', 'heure_debut')
                # lancer l'envoi des convocations en tâche de fond               
                t = threading.Thread(target=task_envoi_convocations_examens_enseignants,args=[examen_list, service, request.user])                
                t.setDaemon(True)
                t.start()
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: lors du lancement de l'envoi des convocations.")
                    return HttpResponseRedirect(reverse('examen_list'))
               
            messages.success(request, "L'envoi des convocations a été lancé. Une notification vous sera transmise une fois la tâche terminée.")
            
            return HttpResponseRedirect(reverse('examen_list')) 
    else:
        form = ExamenSelectForm()
        
        messages.info(request, "Merci de renseigner le formulaire pour sélectionner les examens à publier.")
        context={}
        context['form'] = form
        context['titre'] = "Sélection des examens à publier"
        return render(request, 'scolar/import.html', context)
        


@transaction.atomic
def task_envoi_convocations_examens_enseignants(examen_list, service, user):

    non_envoye=''
    #convoquer les surveillants
    for enseignant_ in Enseignant.objects.filter(situation='A'):
        # sélectionner les surveillances programmées pour cet enseignant
        surveillance_list = SurveillanceEnseignant.objects.filter(
                seance__in=examen_list.values('id'),
                enseignant=enseignant_
            ).order_by('seance__date', 'seance__heure_debut')
        if surveillance_list.exists():
            # convoquer l'enseignant
            try:
                enseignant_surveillance_list=''
                for surveillance_ in surveillance_list:
                    enseignant_surveillance_list += surveillance_.seance.date.strftime('%d/%m/%Y')+' de '+ surveillance_.seance.heure_debut.strftime('%H:%M')+' à '+ surveillance_.seance.heure_fin.strftime('%H:%M')+ ' à la salle : '+ surveillance_.salle.code+ '('+ dict(TYPES_ACT)[surveillance_.seance.activite.type]+' '+ surveillance_.seance.activite.module.matiere.code+')\n'                        
                    #Ajout surveillance dans agenda de l'enseignant
                    surveillance_event = {
                                "summary": 'Surveillance '+dict(TYPES_ACT)[surveillance_.seance.activite.type] +" "+ surveillance_.seance.activite.module.matiere.code,
                                "start": {
                                    "dateTime": (datetime.datetime(surveillance_.seance.date.year, surveillance_.seance.date.month, surveillance_.seance.date.day,0,0) + datetime.timedelta(hours=surveillance_.seance.heure_debut.hour, minutes=surveillance_.seance.heure_debut.minute)).isoformat(),
                                    "timeZone":"Africa/Algiers"
                                },
                                "end": {
                                    "dateTime": (datetime.datetime(surveillance_.seance.date.year, surveillance_.seance.date.month, surveillance_.seance.date.day,0,0) + datetime.timedelta(hours=surveillance_.seance.heure_fin.hour, minutes=surveillance_.seance.heure_fin.minute)).isoformat(),
                                    "timeZone":"Africa/Algiers"
                                },
                                "attendees":[
                                        {"email":surveillance_.enseignant.get_email()}
                                    ],
#                                    "sendUpdates": 'all',
                                'location': surveillance_.salle.code,
#                                     "reminders": {
#                                         "useDefault":False,
#                                         "overrides": [
#                                             {
#                                                 "method": "email",                      
#                                                 "minutes": 12*60
#                                             },
#                                             {
#                                                 "method": "email",
#                                                 "minutes": 2*60
#                                             },
#                                             {
#                                                 "method": "popup",
#                                                 "minutes": 20
#                                             },
#                                         ]
#                                     }
                            }
                    service.events().insert(calendarId='primary', body=surveillance_event).execute()
                    sleep(1)
                    
                # Envoi convocation par email   
                if activation_emails():                 
                    email = EmailMessage('[Talents] Convocation à Surveillance d\'Examens',
                                'Bonjour '+str(enseignant_)+',\n'+ 
                                'Nous vous prions d\'assurer la surveillance des examens suivants:\n'+
                                 enseignant_surveillance_list+
                                'Bien cordialement.\n'+
                                signature_emails(), to=[enseignant_.get_email(), user.get_email()] )
                    email.send(fail_silently=True)
                    sleep(1)
            except Exception:
                non_envoye+=str(enseignant_)+'\n'
                continue
    
    if non_envoye != '':
        trace_create(user, user, 'Une erreur s\'est produite lors de l\'envoi des convocations aux enseignants.')
        if activation_emails():
            email = EmailMessage('[Talents] Erreur Envoi de Convocations',
                                 'Bonjour '+str(user.enseignant.prenom)+',\n'+ 
                                 'Une erreur s\'est produite lors de l\'envoi des convocations.\n'+ 
                                 'Non envoyés: '+non_envoye+'\n'+
                                 'Bien cordialement.\n'+
                                 signature_emails(), to=[user.get_email()] )
            email.send(fail_silently=True)
    else:
        trace_create(user, user, 'L\'envoi des convocations aux enseignants a été effectué avec succès')
        if activation_emails():
            email = EmailMessage('[Talents] Envoi des convocations pour examens',
                             'Bonjour '+str(user.enseignant.prenom)+',\n'+ 
                             'L\'envoi des convocations a été effectué avec succès'+'\n'+
                             'Bien cordialement.\n'+
                             signature_emails(), to=[user.get_email()] )
            email.send(fail_silently=True)

    # Réserver les salles et groupes dans l'agenda
    # TODO: mettre dans une vue à part
    non_reserve=''        
    for examen_ in examen_list:
        try:
            first_groupe=True
            for groupe_ in examen_.activite.cible.all():            
                if groupe_.gCal():
                    if first_groupe:
                        # réserver les ressources dans le 1er groupe seulement
                        first_groupe=False
                        first_groupe_event = {
                                    "summary": dict(TYPES_ACT)[examen_.activite.type] +" "+ examen_.activite.module.matiere.code,
                                    #"description": "Bar",
                                    "start": {
                                        "dateTime": (datetime.datetime(examen_.date.year, examen_.date.month, examen_.date.day,0,0) + datetime.timedelta(hours=examen_.heure_debut.hour, minutes=examen_.heure_debut.minute)).isoformat(),
                                        "timeZone":"Africa/Algiers"
                                    },
                                    "end": {
                                        "dateTime": (datetime.datetime(examen_.date.year, examen_.date.month, examen_.date.day,0,0) + datetime.timedelta(hours=examen_.heure_fin.hour, minutes=examen_.heure_fin.minute)).isoformat(),
                                        "timeZone":"Africa/Algiers"
                                    },
                                    'attendees': [
                                        {'email': salle_.calendarId, 'resource':True} for salle_ in examen_.salles.all()
                                    ],
                                    'location': str([salle_.code for salle_ in examen_.salles.all()]),
                                    'conferenceData': {
                                        'createRequest': {
                                            "requestId": f"{uuid4().hex}",
                                            'conferenceSolutionKey': {
                                                'type': "hangoutsMeet"
                                            }
                                        }
                                    }
                                }
                        first_event = service.events().insert(calendarId=groupe_.gCal().calendarId, body=first_groupe_event, conferenceDataVersion=1).execute()
                        sleep(1)
                    else:
                        groupe_event = {
                                    "summary": first_event['summary'],
                                    "start": first_event['start'],
                                    "end": first_event['end'],
                                    'conferenceData': first_event['conferenceData'],
                                    'location': first_groupe_event['location'],
                                }
                        service.events().insert(calendarId=groupe_.gCal().calendarId, body=groupe_event, conferenceDataVersion=1).execute()
                        sleep(1)        
        except Exception:
            non_reserve+=str(examen_)+'\n'
            continue
    if non_reserve != '':
        trace_create(user, user, 'Une erreur s\'est produite lors de la réservation des salles pour examens.')
        if activation_emails():
            email = EmailMessage('[Talents] Erreur Réservation Salles Examens Agenda',
                                 'Bonjour '+str(user.enseignant.prenom)+',\n'+ 
                                 'Une erreur s\'est produite lors de la réservation des salles pour examens dans l\'agenda.\n'+ 
                                 'Examens non réservé: '+non_reserve+'\n'+
                                 'Bien cordialement.\n'+
                                 signature_emails(), to=[user.get_email()] )
            email.send(fail_silently=True)
    else:
        trace_create(user, user, 'La réservation des examens a été effectué avec succès')
        if activation_emails():
            email = EmailMessage('[Talents] Réservation des examens sur Agenda',
                             'Bonjour '+str(user.enseignant.prenom)+',\n'+ 
                             'La réservation des examens a été effectué avec succès'+'\n'+
                             'Bien cordialement.\n'+
                             signature_emails(), to=[user.get_email()] )
            email.send(fail_silently=True)
                

@login_required
def authorize_envoi_convocations_examens_etudiants_view(request):
    # if this is a POST request we need to process the form data
    if not request.user.has_perm('scolar.fonctionnalite_examens_gestionexamens'):
        messages.error(request,"Vous n'êtes pas autorisés à accéder à cette fonction.")
        return redirect('/accounts/login/?next=%s' % request.path)

    flow = Flow.from_client_secrets_file(
        settings.GOOGLE_CLIENT_SECRET_FILE,
        scopes=settings.SCOPES,
        redirect_uri=settings.PROTOCOLE_HOST+reverse('callback_envoi_convocations_examens_etudiants'))
    authorization_url, state = flow.authorization_url(
        access_type='offline',
        prompt='consent',
        include_granted_scopes='false')
    return redirect(authorization_url)
    
        
def callback_envoi_convocations_examens_etudiants_view(request):
    # if this is a POST request we need to process the form data
    if not request.user.has_perm('scolar.fonctionnalite_examens_gestionexamens'):
        messages.error(request,"Vous n'êtes pas autorisés à accéder à cette fonction.")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    state = request.GET.get('state')
    
    flow = Flow.from_client_secrets_file(
        settings.GOOGLE_CLIENT_SECRET_FILE,
        scopes=settings.SCOPES,
        state=state,
        redirect_uri=settings.PROTOCOLE_HOST+reverse('callback_envoi_convocations_examens_etudiants'))
    
    #authorization_response = request.build_absolute_uri
    flow.fetch_token(code=request.GET.get('code'))
    # Store credentials in the session.
    # ACTION ITEM: In a production app, you likely want to save these
    #              credentials in a persistent database instead.
    credentials = flow.credentials
    request.session['credentials'] = credentials_to_dict(credentials)
    return HttpResponseRedirect(reverse('envoi_convocations_examens_etudiants'))


#TODO planifier l'envoie d'un SMS de rappel le jour de la surveillance à 7h
@login_required
def envoi_convocations_examens_etudiants_view(request):
    # if this is a POST request we need to process the form data
    if not request.user.has_perm('scolar.fonctionnalite_examens_gestionexamens'):
        messages.error(request,"Vous n'êtes pas autorisés à accéder à cette fonction.")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    if 'credentials' not in request.session:
        return redirect('/scolar/authorize_envoi_convocations_examens_etudiants')

    # Load credentials from the session.
    credentials_dict=request.session['credentials']
    credentials = Credentials(
        credentials_dict["token"],
        refresh_token = credentials_dict["refresh_token"],
        token_uri = credentials_dict["token_uri"],
        client_id = credentials_dict["client_id"],
        client_secret = credentials_dict["client_secret"],
        scopes = credentials_dict["scopes"]
        )
 
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = ExamenSelectForm(request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:
                form_data=form.cleaned_data                
                
                
                service = build("calendar", "v3", credentials=credentials)                

                # Sélectionner les examens des formations compris dans l'intervalle des dates indiquées
                examen_list = Seance.objects.filter(activite__type__in=form_data['activite_type_list'],
                                                    activite__module__formation__in=form_data['formation_list'],
                                                   date__gte=form_data['date_debut'],
                                                   date__lte=form_data['date_fin']
                                                   ).order_by('date', 'heure_debut')
                # lancer l'envoi des convocations en tâche de fond                
                t = threading.Thread(target=task_envoi_convocations_examens_etudiants,args=[examen_list, service, request.user])                
                t.setDaemon(True)
                t.start()
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: lors du lancement de l'envoi des convocations aux étudiants.")
                    return HttpResponseRedirect(reverse('examen_list'))
            messages.success(request, "L'envoi des convocations aux étudiants a été lancé. Une notification vous sera transmise une fois la tâche terminée.")
            
            return HttpResponseRedirect(reverse('examen_list')) 
    else:
        form = ExamenSelectForm() 
        messages.info(request, "Merci de renseigner le formulaire pour sélectionner les examens à publier.")
        context={}
        context['form'] = form
        context['titre'] = "Sélection des examens à publier"
        return render(request, 'scolar/import.html', context)

@transaction.atomic
def task_envoi_convocations_examens_etudiants(examen_list,service,user):
    try:
        non_envoye=''    
        #convoquer les étudiants
        inscription_examen_list={}
        reservation_place_etudiant_list=ReservationPlaceEtudiant.objects.filter(
                seance__in=examen_list,
            ).order_by('seance__date', 'seance__heure_debut')
        for reservation_ in reservation_place_etudiant_list:
            if not reservation_.inscription in inscription_examen_list.keys():
                inscription_examen_list[reservation_.inscription]=''
            inscription_examen_list[reservation_.inscription]+=reservation_.seance.date.strftime("%d/%m/%Y")+' de '+reservation_.seance.heure_debut.strftime("%H:%M")+' à '+reservation_.seance.heure_fin.strftime("%H:%M")+' ==> '+reservation_.place.salle.code+':'+str(reservation_.place.code)+ '('+reservation_.seance.activite.module.matiere.code+')\n'
            
            #Ajout examen dans agenda de l'étudiant            
            examen_event = {
                        "summary": dict(TYPES_ACT)[reservation_.seance.activite.type] +" "+ reservation_.seance.activite.module.matiere.code,
                        "start": {
                            "dateTime": (datetime.datetime(reservation_.seance.date.year, reservation_.seance.date.month, reservation_.seance.date.day,0,0) + datetime.timedelta(hours=reservation_.seance.heure_debut.hour, minutes=reservation_.seance.heure_debut.minute)).isoformat(),
                            "timeZone":"Africa/Algiers"
                        },
                        "end": {
                            "dateTime": (datetime.datetime(reservation_.seance.date.year, reservation_.seance.date.month, reservation_.seance.date.day,0,0) + datetime.timedelta(hours=reservation_.seance.heure_fin.hour, minutes=reservation_.seance.heure_fin.minute)).isoformat(),
                            "timeZone":"Africa/Algiers"
                        },
                        "attendees":[
                            {"email": reservation_.inscription.etudiant.get_email()}
                        ],
#                        "sendUpdates": 'all',
                        "location": reservation_.place.salle.code+'('+reservation_.place.code+')',#                        
                    }
            service.events().insert(calendarId='primary', body=examen_event).execute()            
            sleep(1)
        
        #Envoi des convocations par email
        for inscription_, examen_list_ in inscription_examen_list.items():
                try:
                    if activation_emails():
                        recipient_= [inscription_.etudiant.get_email()]
                        email = EmailMessage('[Talents] Convocation à Passer des Epreuves Ecrites',
                                         'Bonjour '+str(inscription_.etudiant.prenom)+',\n'+ 
                                         'Vous êtes convoqués à passer les épreuves écrites suivantes:\n'+
                                          examen_list_+
                                         'Bien cordialement.\n'+
                                         signature_emails(), 
                                         to=recipient_)
                        email.send(fail_silently=True)
                        sleep(1)
                    
                except Exception:
                    non_envoye+=str(inscription_)+'\n'
                    continue
    except Exception:
        trace_create(user, user, 'Une erreur s\'est produite lors de l\'envoi des convocations aux étudiants.')
        if settings.DEBUG:
            raise Exception
        else:
            if activation_emails():
                email = EmailMessage('[Talents] Erreur Envoi de Convocations',
                                     'Bonjour,\n'+ 
                                     'Une erreur s\'est produite lors de l\'envoi des convocations.\n'+ 
                                     'Nn envoyés: '+non_envoye+'\n'+
                                     'Bien cordialement.\n'+
                                     signature_emails(), to=[user.get_email()] )
                email.send(fail_silently=True)
    else:
        trace_create(user, user, 'L\'envoi des convocations a été effectué avec succès')
        if activation_emails():
            email = EmailMessage('[Talents] Envoi des convocations pour examens',
                                 'Bonjour,\n'+ 
                                 'L\'envoi des convocations a été effectué avec succès'+'\n'+
                                 'Bien cordialement.\n'+
                                 signature_emails(), to=[user.get_email()] )
            email.send(fail_silently=True)

@login_required
def pv_salle_examen_list_view(request):
    # if this is a POST request we need to process the form data

    if not request.user.has_perm('scolar.fonctionnalitenav_examens_visualisationexamens'):
        messages.error(request,"Vous n'êtes pas autorisés à accéder à cette fonction.")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        #form = AffichageExamenSelectForm(request.POST)
        form = ExamenListSelectForm(request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:
                form_data=form.cleaned_data
                # Sélectionner les examens des formations compris dans l'intervalle des dates indiquées
                examen_list = form_data['examen_list'].order_by('date', 'heure_debut')
                # Pour chaque salle lister les réservations de places pour chaque examen
                salle_list = {}
                
                inscription_examen_salle_list=ReservationPlaceEtudiant.objects.filter(
                    seance__in=examen_list,
                ).order_by('inscription__etudiant__nom', 'inscription__etudiant__prenom', 'seance__date', 'seance__heure_debut')
                
                for reservation_ in inscription_examen_salle_list:
                    if not reservation_.place.salle.code in salle_list.keys():
                        salle_list[reservation_.place.salle.code]={
                                'examen_list':[],
                                'inscription_examen_list':{}
                            }
                    if not reservation_.seance in salle_list[reservation_.place.salle.code]['examen_list']:
                        salle_list[reservation_.place.salle.code]['examen_list'].append(reservation_.seance)
                        
                    if not reservation_.inscription in salle_list[reservation_.place.salle.code]['inscription_examen_list'].keys(): 
                        salle_list[reservation_.place.salle.code]['inscription_examen_list'][reservation_.inscription]={}
                    
                    salle_list[reservation_.place.salle.code]['inscription_examen_list'][reservation_.inscription][reservation_.seance.activite.module.matiere.code]=reservation_
                    

                context={}
                context['formation']=form_data['formation']
                if len(examen_list) > 0:
                    context['date_debut']=examen_list[0].date
                    context['date_fin']=examen_list[len(examen_list)-1].date
                context['salle_list']=salle_list
                return render(request, 'scolar/pv_salle_examen_list.html', context)
            
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: lors de la génération de l'affichage des convocations.")
                    return HttpResponseRedirect(reverse('examen_list'))
    else:

        form = ExamenListSelectForm()
        messages.info(request, "Merci de renseigner le formulaire pour sélectionner les examens à publier.")
        context={}
        context['form'] = form
        context['titre'] = "Sélection des examens à publier"
        return render(request, 'scolar/import.html', context)

@login_required
def affichage_convocations_examens_view(request):
    # if this is a POST request we need to process the form data

    if not (request.user.has_perm('scolar.fonctionnalitenav_examens_visualisationplacesetudiants') or request.user.has_perm('scolar.fonctionnalite_examens_gestionexamens')):
        messages.error(request,"Vous n'êtes pas autorisés à accéder à cette fonction.")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = AffichageExamenSelectForm(request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:
                form_data=form.cleaned_data
                # Sélectionner les examens des formations compris dans l'intervalle des dates indiquées
                examen_list = Seance.objects.filter(activite__type__in=form_data['activite_type_list'],
                                                    activite__module__formation=form_data['formation'],
                                                   date__gte=form_data['date_debut'],
                                                   date__lte=form_data['date_fin']
                                                   ).order_by('date', 'heure_debut')
                # afficher les convocations des étudiants
                inscription_examen_list={}
                reservation_place_etudiant_list=ReservationPlaceEtudiant.objects.filter(
                        seance__in=examen_list,
                    ).order_by('inscription__etudiant__nom', 'inscription__etudiant__prenom', 'seance__date', 'seance__heure_debut')
                for reservation_ in reservation_place_etudiant_list:
                    if not reservation_.inscription in inscription_examen_list.keys():
                        inscription_examen_list[reservation_.inscription]={}
                    inscription_examen_list[reservation_.inscription][reservation_.seance.id]=reservation_

                context={}
                context['formation']=form_data['formation']
                context['date_debut']=form_data['date_debut']
                context['date_fin']=form_data['date_fin']
                context['examen_list']=examen_list
                context['inscription_examen_list']=inscription_examen_list
                return render(request, 'scolar/affichage_convocations_examens.html', context)
            
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: lors de la génération de l'affichage des convocations.")
                    return HttpResponseRedirect(reverse('examen_list'))
    else:
        form = AffichageExamenSelectForm()
        messages.info(request, "Merci de renseigner le formulaire pour sélectionner les examens à publier.")
        context={}
        context['form'] = form
        context['titre'] = "Sélection des examens à publier"
        return render(request, 'scolar/import.html', context)
        
@login_required
def affichage_reprographie_view(request):
    # if this is a POST request we need to process the form data

    if not (request.user.has_perm('scolar.fonctionnalite_examens_visualisationreprographie') or request.user.has_perm('scolar.fonctionnalite_examens_gestionexamens')):
        messages.error(request,"Vous n'êtes pas autorisés à accéder à cette fonction.")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = AffichageExamenSelectForm(request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:
                form_data=form.cleaned_data
                # Sélectionner les examens des formations compris dans l'intervalle des dates indiquées
                examen_list = Seance.objects.filter(activite__type__in=form_data['activite_type_list'],
                                                    activite__module__formation=form_data['formation'],
                                                   date__gte=form_data['date_debut'],
                                                   date__lte=form_data['date_fin']
                                                   ).order_by('date', 'heure_debut')

                context={}
                context['institution']=request.user.institution()
                context['formation']=form_data['formation']
                context['date_debut']=form_data['date_debut']
                context['date_fin']=form_data['date_fin']
                context['examen_list']=examen_list
                
                cmd_options={
                    'orientation':'Portrait',
                    'page-size':'A4',
                }
                pdf_=render_pdf_from_template(input_template='scolar/affichage_reprographie_pdf.html', 
                                      header_template=None,
                                      footer_template=None,
                                      context=context, 
                                      cmd_options=cmd_options)
    
                filename='EXAMEN_'+str(form_data['formation'])+'.pdf'
                filename=filename.replace(' ','_')

                response = HttpResponse(content_type='application/pdf')
                response['Content-Disposition'] = 'attachment; filename='+filename+";"
                response.write(pdf_)                
                return response
            
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: lors de la génération de l'affichage pour reprographie.")
                    return HttpResponseRedirect(reverse('examen_list'))
    else:
        form = AffichageExamenSelectForm()
        messages.info(request, "Merci de renseigner le formulaire pour sélectionner les examens à publier.")
        context={}
        context['form'] = form
        context['titre'] = "Sélection des examens à publier"
        return render(request, 'scolar/import.html', context)

        
@login_required
def affichage_surveillance_view(request):
    # if this is a POST request we need to process the form data

    if not (request.user.has_perm('scolar.fonctionnalitenav_examens_visualisationsurveillance') or request.user.has_perm('scolar.fonctionnalite_examens_gestionexamens')):
        messages.error(request,"Vous n'êtes pas autorisés à accéder à cette fonction.")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = AffichageExamenSelectForm(request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:
                form_data=form.cleaned_data
                # Sélectionner les examens des formations compris dans l'intervalle des dates indiquées
                examen_list = Seance.objects.filter(activite__type__in=form_data['activite_type_list'],
                                                    activite__module__formation=form_data['formation'],
                                                   date__gte=form_data['date_debut'],
                                                   date__lte=form_data['date_fin']
                                                   ).order_by('date', 'heure_debut')

                context={}
                context['institution']=request.user.institution()
                context['formation']=form_data['formation']
                context['date_debut']=form_data['date_debut']
                context['date_fin']=form_data['date_fin']
                context['examen_list']=examen_list
                
                cmd_options={
                    'orientation':'Portrait',
                    'page-size':'A4',
                }
                pdf_=render_pdf_from_template(input_template='scolar/affichage_surveillance_pdf.html', 
                                      header_template=None,
                                      footer_template=None,
                                      context=context, 
                                      cmd_options=cmd_options)
    
                filename='EXAMEN_'+str(form_data['formation'])+'.pdf'
                filename=filename.replace(' ','_')

                response = HttpResponse(content_type='application/pdf')
                response['Content-Disposition'] = 'attachment; filename='+filename+";"
                response.write(pdf_)                
                return response
            
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: lors de la génération de l'affichage pour surveillance.")
                    return HttpResponseRedirect(reverse('examen_list'))
    else:
        form = AffichageExamenSelectForm()
        messages.info(request, "Merci de renseigner le formulaire pour sélectionner les examens à publier.")
        context={}
        context['form'] = form
        context['titre'] = "Sélection des examens à publier"
        return render(request, 'scolar/import.html', context)

class RepartitionCreditChart(Chart):
    chart_type='pie'
    
    def __init__(self, qs, *args, **kwargs):
        super(RepartitionCreditChart, self).__init__(*args, **kwargs)
        self.data=[]
        self.labels=[]
        self.colors=[]
        try:
            ddc_data=Matiere.objects.filter(id__in=qs, credit__isnull=False).values('ddc__intitule').annotate(somme_credits=Sum(F('credit')))
            total_data=Matiere.objects.filter(id__in=qs).aggregate(total=Sum(F('credit')))
    
            for ddc_ in ddc_data:
                self.labels.append(ddc_['ddc__intitule'])
                if total_data['total'] :
                    self.data.append(round(ddc_['somme_credits']/total_data['total'], 2))
                else :
                    self.data.append(0)
                    
                self.colors.append("#%06x" % random.randint(0, 0xFFFFFF))
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors de la génération du graphique sur la répartition des crédits. Merci de le signaler à l'administrateur")
    def get_labels(self, *args, **kwargs):
        return self.labels
    
    def get_datasets(self, **kwargs):
        return [DataSet(data=self.data, backgroundColor=self.colors)]

class ProgrammeDesignView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name='scolar/programme_design.html'
    
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalitenav_pedagogie_gestionprogrammes')
    
    def get_context_data(self, **kwargs):
        context = super(ProgrammeDesignView, self).get_context_data(**kwargs)
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalitenav_pedagogie_gestionprogrammes'):
            exclude_.append('edit')
            exclude_.append('admin')
        table_programme = ProgrammeTable(Programme.objects.all().order_by('ordre'), exclude=exclude_)
        RequestConfig(self.request).configure(table_programme)
        context['table_programme'] = table_programme
        table_specialite = SpecialiteTable(Specialite.objects.all(), exclude=exclude_)
        RequestConfig(self.request).configure(table_specialite)
        context['table_specialite'] = table_specialite
        table_periode = PeriodeTable(Periode.objects.all(), exclude=exclude_)
        RequestConfig(self.request).configure(table_periode)
        context['table_periode'] = table_periode
        filter_ = MatiereFilter(self.request.GET, Matiere.objects.all().distinct().order_by('code'))
        filter_.form.helper = FormHelper()
        context['filter_matiere']= filter_
        if not activation_ddc() :
            exclude_.append('ddc')
        table_matiere = MatiereTable(filter_.qs, exclude=exclude_)
        RequestConfig(self.request, paginate={"per_page": 30}).configure(table_matiere)
        context['table_matiere'] = table_matiere
        context['repartition_credits_chart']=RepartitionCreditChart(filter_.qs)
        table_diplome = DiplomeTable(Diplome.objects.all(), exclude=exclude_)
        RequestConfig(self.request).configure(table_diplome)
        context['table_diplome'] = table_diplome
        table_cycle = CycleTable(Cycle.objects.all(), exclude=exclude_) 
        RequestConfig(self.request).configure(table_cycle)
        context['table_cycle'] = table_cycle
        if activation_ddc() :
            table_ddc = DomaineConnaissanceTable(DomaineConnaissance.objects.all().order_by('intitule'), exclude=exclude_) 
            RequestConfig(self.request).configure(table_ddc)
            context['table_ddc'] = table_ddc
        return context


class ProgrammeListView(TemplateView):
    template_name='scolar/programme_list.html'
        
    def get_context_data(self, **kwargs):
        context = super(ProgrammeListView, self).get_context_data(**kwargs)
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalitenav_pedagogie_gestionprogrammes'):
            exclude_.append('edit')
            exclude_.append('admin')
        table_programme = ProgrammeTable(Programme.objects.all().order_by('ordre'), exclude=exclude_)
        RequestConfig(self.request).configure(table_programme)
        context['table_programme'] = table_programme
        table_specialite = SpecialiteTable(Specialite.objects.all(), exclude=exclude_)
        RequestConfig(self.request).configure(table_specialite)
        context['table_specialite'] = table_specialite

        if not self.request.user.has_perm('scolar.fonctionnalitenav_pedagogie_gestionprogrammes'):
            filter_ = MatiereFilter(self.request.GET, Matiere.objects.exclude(ddc__isnull=True).order_by('code'))
        else :    
            filter_ = MatiereFilter(self.request.GET, Matiere.objects.all().order_by('code'))

        filter_.form.helper = FormHelper()
        if not activation_ddc() :
            exclude_.append('ddc')
        table_matiere = MatiereTable(filter_.qs, exclude=exclude_)
        RequestConfig(self.request, paginate={"per_page": 30}).configure(table_matiere)
        context['filter_matiere']= filter_
        context['table_matiere'] = table_matiere
        context['repartition_credits_chart']=RepartitionCreditChart(filter_.qs)
        table_diplome = DiplomeTable(Diplome.objects.all(), exclude=exclude_)
        RequestConfig(self.request).configure(table_diplome)
        context['table_diplome'] = table_diplome
        table_cycle = CycleTable(Cycle.objects.all(), exclude=exclude_) 
        RequestConfig(self.request).configure(table_cycle)
        context['table_cycle'] = table_cycle

        return context
  
class ProgrammeCreateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, CreateView): 
    model = Programme
    fields = ['code', 'ordre', 'titre', 'titre_a', 'titre_en', 'doctorat', 'diplome', 'specialite', 'cycle', 'description', 'assistant', 'code_serv_national', 'programme_complementaire_master', 'fictif', 'matiere_equipe']
    template_name = 'scolar/create.html'
    permission_required = 'scolar.fonctionnalitenav_pedagogie_gestionprogrammes'
    success_message = "Le programme a été bien créé."
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.fields['matiere_equipe']=forms.ModelChoiceField(queryset=Matiere.objects.filter(equipe=True).order_by('code'), required=False, widget=
                            ModelSelect2Widget(
                                Model=Matiere,
                                search_fields=['code__icontains','titre__icontains']
                            ), 
                            help_text="Tapez le nom de la matière/stage, se déroulant en équipe. Tapez deux espaces pour avoir la liste complète")
        form.fields['periode']=forms.ModelChoiceField(queryset=Periode.objects.all().order_by('code'), required=False, help_text="Code de période du module d'équipe (uniquement dans le cas d'une formation fictive)")        
        form.fields['periode_code']=forms.ChoiceField(choices=PERIODES, required=False, help_text="Période du module d'équipe (uniquement dans le cas d'une formation fictive)")        
        form.helper.add_input(Submit('submit','Ajouter', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('programme_design')
        return form

    def form_valid(self, form):
        response = super(ProgrammeCreateView, self).form_valid(form)
        programme_=self.object
        matiere_equipe=form.cleaned_data['matiere_equipe']
        if form.cleaned_data['fictif']==True and matiere_equipe :
            periode_=form.cleaned_data['periode']
            periode_code=form.cleaned_data['periode_code']
            periode_programme_=PeriodeProgramme.objects.create(
                periode=periode_,
                programme=programme_,
                code=periode_code
                ) 
            ue_=UE.objects.create(
                periode=periode_programme_,
                code=matiere_equipe.code,
                nature='OBL',
                type='F'
                )
            ue_.matieres.add(matiere_equipe)
        return response

    def get_context_data(self, **kwargs):
        context = super(ProgrammeCreateView, self).get_context_data(**kwargs)
        context['titre'] = 'Ajouter un programme'
        context['webhelp']=format_html(HELP_PROGRAMME_CREATE)
        return context

class ProgrammeUpdateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, UpdateView): 
    model = Programme
    fields = ['code', 'ordre', 'concours','diplome', 'titre', 'titre_a','titre_en', 'doctorat', 'diplome', 'specialite', 'cycle', 'description', 'assistant', 'code_serv_national', 'programme_complementaire_master', 'fictif', 'matiere_equipe']
    template_name = 'scolar/update.html'
    permission_required = 'scolar.fonctionnalitenav_pedagogie_gestionprogrammes'
    success_message = 'Le programme a été bien modifié.'
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.fields['matiere_equipe']=forms.ModelChoiceField(queryset=Matiere.objects.filter(equipe=True).order_by('code'), required=False, widget=
                            ModelSelect2Widget(
                                Model=Matiere,
                                search_fields=['code__icontains','titre__icontains']
                            ), 
                            help_text="Tapez le nom de la matière/stage, se déroulant en équipe. Tapez deux espaces pour avoir la liste complète")
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-warning'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('programme_design')
        return form

    def get_context_data(self, **kwargs):
        context = super(ProgrammeUpdateView, self).get_context_data(**kwargs)
        context['titre'] = 'Modifier le programme'
        return context

        
class ProgrammeDetailView(DetailView):
    model = Programme
    template_name_suffix = '_detail'

    def get_context_data(self, **kwargs):
        context = super(ProgrammeDetailView, self).get_context_data(**kwargs)
        context['categorie_ue']=dict(CAT_UE)
        return context


class CycleUpdateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, UpdateView): 
    model = Cycle
    fields = '__all__'
    template_name = 'scolar/update.html'
    permission_required = 'scolar.fonctionnalitenav_pedagogie_gestionprogrammes'
    success_message = 'Le cycle a été bien modifié.'
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.fields['users_visualisation_notes']=forms.ModelMultipleChoiceField(
            queryset=User.objects.all().order_by('username'),
            label=u"Utilisateurs pouvant visualiser les notes du cycle",
            widget=ModelSelect2MultipleWidget(
                    model=User,
                    search_fields=['username__icontains', 'email__icontains'],

                ),
            help_text = "Tapez un nom d'utilisateur/email ou une partie du nom d'utilisateur/email pour faire une recherche",
            required = False
        )
        form.fields['users_gestion_notes']=forms.ModelMultipleChoiceField(
            queryset=User.objects.all().order_by('username'),
            label=u"Utilisateurs pouvant gérer les notes du cycle",
            widget=ModelSelect2MultipleWidget(
                    model=User,
                    search_fields=['username__icontains', 'email__icontains'],

                ),
            help_text = "Tapez un nom d'utilisateur/email ou une partie du nom d'utilisateur/email pour faire une recherche",
            required = False
        )
        form.fields['users_gestion_etudiants']=forms.ModelMultipleChoiceField(
            queryset=User.objects.all().order_by('username'),
            label=u"Utilisateurs pouvant gérer les inscriptions du cycle : Modification groupes, décisions jury, observations, ..",
            widget=ModelSelect2MultipleWidget(
                    model=User,
                    search_fields=['username__icontains', 'email__icontains'],

                ),
            help_text = "Tapez un nom d'utilisateur/email ou une partie du nom d'utilisateur/email pour faire une recherche",
            required = False
        )
        if not self.request.user.has_perm('scolar.fonctionnalite_configurationetablissement_modification') :
            form.fields['users_visualisation_notes'].disabled=True
            form.fields['users_visualisation_notes'].help_text="Vous devez avoir la permission de configuration des droits d'accès pour éditer ce paramètre"
            form.fields['users_gestion_notes'].disabled=True
            form.fields['users_gestion_notes'].help_text="Vous devez avoir la permission de configuration des droits d'accès pour éditer ce paramètre"
            form.fields['users_gestion_etudiants'].disabled=True
            form.fields['users_gestion_etudiants'].help_text="Vous devez avoir la permission de configuration des droits d'accès pour éditer ce paramètre"
        
        form.helper = FormHelper()
        #form.fields['signature']=forms.ImageField(label='Signature', required=False, widget=forms.FileInput(attrs={'class':"custom-file-input"}))        
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-warning'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('programme_design')
        return form

class CycleCreateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, CreateView): 
    model = Cycle
    fields = '__all__'
    template_name = 'scolar/create.html'
    permission_required = 'scolar.fonctionnalitenav_pedagogie_gestionprogrammes'
    success_message = 'Le cycle a bien été créé.'
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.fields['users_visualisation_notes']=forms.ModelMultipleChoiceField(
            queryset=User.objects.all().order_by('username'),
            label=u"Utilisateurs pouvant visualiser les notes du cycle",
            widget=ModelSelect2MultipleWidget(
                    model=User,
                    search_fields=['username__icontains', 'email__icontains'],

                ),
            help_text = "Tapez un nom d'utilisateur/email ou une partie du nom d'utilisateur/email pour faire une recherche",
            required = False
        )
        form.fields['users_gestion_notes']=forms.ModelMultipleChoiceField(
            queryset=User.objects.all().order_by('username'),
            label=u"Utilisateurs pouvant gérer les notes du cycle",
            widget=ModelSelect2MultipleWidget(
                    model=User,
                    search_fields=['username__icontains', 'email__icontains'],

                ),
            help_text = "Tapez un nom d'utilisateur/email ou une partie du nom d'utilisateur/email pour faire une recherche",
            required = False
        )
        form.fields['users_gestion_etudiants']=forms.ModelMultipleChoiceField(
            queryset=User.objects.all().order_by('username'),
            label=u"Utilisateurs pouvant gérer les inscriptions du cycle : Modification groupes, décisions jury, observations, ..",
            widget=ModelSelect2MultipleWidget(
                    model=User,
                    search_fields=['username__icontains', 'email__icontains'],

                ),
            help_text = "Tapez un nom d'utilisateur/email ou une partie du nom d'utilisateur/email pour faire une recherche",
            required = False
        )
        if not self.request.user.has_perm('scolar.fonctionnalite_configurationetablissement_modification') :
            form.fields['users_visualisation_notes'].disabled=True
            form.fields['users_visualisation_notes'].help_text="Vous devez avoir la permission de configuration des droits d'accès pour éditer ce paramètre"
            form.fields['users_gestion_notes'].disabled=True
            form.fields['users_gestion_notes'].help_text="Vous devez avoir la permission de configuration des droits d'accès pour éditer ce paramètre"
            form.fields['users_gestion_etudiants'].disabled=True
            form.fields['users_gestion_etudiants'].help_text="Vous devez avoir la permission de configuration des droits d'accès pour éditer ce paramètre"
        
        form.helper = FormHelper()
        form.helper.add_input(Submit('submit','Ajouter', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('programme_design')
        return form

    def get_context_data(self, **kwargs):
        context = super(CycleCreateView, self).get_context_data(**kwargs)
        context['titre'] = 'Créer un cycle'
        return context

class CycleDeleteView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, DeleteView):
    model = Cycle
    template_name= 'scolar/delete.html'
    permission_required = 'scolar.fonctionnalitenav_pedagogie_gestionprogrammes'
    success_message = "Le cycle a été bien supprimé."

    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression du cycle : "+str(object_))
        return super(CycleDeleteView, self).delete(*args, **kwargs)
    
    def get_success_url(self):
        return reverse('programme_design')
    

class DomaineConnaissanceUpdateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, UpdateView): 
    model = DomaineConnaissance
    fields = '__all__'
    template_name = 'scolar/update.html'
    permission_required = 'scolar.fonctionnalitenav_pedagogie_gestionprogrammes'
    success_message = 'Le domaine de connaissances a été bien modifié.'
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        #form.fields['signature']=forms.ImageField(label='Signature', required=False, widget=forms.FileInput(attrs={'class':"custom-file-input"}))        
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-warning'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('programme_design')
        return form

class DomaineConnaissanceCreateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, CreateView): 
    model = DomaineConnaissance
    fields = '__all__'
    template_name = 'scolar/create.html'
    permission_required = 'scolar.fonctionnalitenav_pedagogie_gestionprogrammes'
    success_message = 'Le domaine de connaissances a bien été créé.'
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.helper.add_input(Submit('submit','Ajouter', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('programme_design')
        return form

    def get_context_data(self, **kwargs):
        context = super(DomaineConnaissanceCreateView, self).get_context_data(**kwargs)
        context['titre'] = 'Créer un domaine de connaissances'
        return context

class DomaineConnaissanceDeleteView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, DeleteView):
    model = DomaineConnaissance
    template_name= 'scolar/delete.html'
    permission_required = 'scolar.fonctionnalitenav_pedagogie_gestionprogrammes'
    success_message = "Le domaine de connaissances a été bien supprimé."

    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression du domaine de connaissances : "+str(object_))
        return super(DomaineConnaissanceDeleteView, self).delete(*args, **kwargs)
    
    def get_success_url(self):
        return reverse('programme_design')

class AutoriteUpdateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, UpdateView): 
    model = Autorite
    fields = ['intitule', 'intitule_a', 'intitule_en', 'responsable', 'titre_responsable', 'titre_responsable_a', 'titre_responsable_en', 'signature', 'autorite']
    template_name = 'scolar/update.html'
    permission_required = 'scolar.fonctionnalite_configurationetablissement_modification'
    success_message = "L'autorité a bien été modifiée."
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.fields['responsable'].queryset = Enseignant.objects.all().order_by('nom', 'prenom')
        #form.fields['signature']=forms.ImageField(label='Signature', required=False, widget=forms.FileInput(attrs={'class':"custom-file-input"}))        
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-warning'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('settings')
        return form

class AutoriteCreateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, CreateView): 
    model = Autorite
    fields = ['intitule', 'intitule_a', 'intitule_en', 'responsable', 'titre_responsable', 'titre_responsable_a', 'titre_responsable_en', 'signature', 'autorite']
    template_name = 'scolar/create.html'
    permission_required = 'scolar.fonctionnalite_configurationetablissement_modification'
    success_message = "L'autorité a bien été créée."
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.fields['responsable'].queryset = Enseignant.objects.all().order_by('nom', 'prenom')
        form.helper.add_input(Submit('submit','Ajouter', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('settings')
        return form

    def get_context_data(self, **kwargs):
        context = super(AutoriteCreateView, self).get_context_data(**kwargs)
        context['titre'] = 'Créer une autorité'
        return context

class AutoriteDeleteView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, DeleteView):
    model = Autorite
    template_name= 'scolar/delete.html'
    permission_required = 'scolar.fonctionnalite_configurationetablissement_modification'
    success_message = "L'autorité a bien été supprimée."

    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression de l'autorité : "+str(object_))
        return super(AutoriteDeleteView, self).delete(*args, **kwargs)
    
    def get_success_url(self):
        return reverse('settings')     

class DiplomeCreateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, CreateView):
    permission_required=['scolar.fonctionnalitenav_pedagogie_gestionprogrammes']
    template_name = 'scolar/create.html'
    model = Diplome
    fields = ['intitule','intitule_a', 'intitule_en', 'domaine', 'domaine_en', 'filiere', 'filiere_en', 'code_filiere','code_diplome','code_cycle']
    success_message = "Le diplôme a bien été créé."

    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.helper.add_input(Submit('submit','Ajouter', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('programme_design')+'#diplomes'
        return form

    def get_context_data(self, **kwargs):
        context = super(DiplomeCreateView, self).get_context_data(**kwargs)
        context['titre'] = 'Ajouter un diplôme'
        return context

class DiplomeUpdateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, UpdateView):
    permission_required=['scolar.fonctionnalitenav_pedagogie_gestionprogrammes']
    template_name = 'scolar/update.html'
    model = Diplome
    fields = ['intitule','intitule_a', 'intitule_en', 'domaine', 'domaine_en', 'filiere', 'filiere_en', 'code_filiere','code_diplome','code_cycle']
    success_message = "Le diplôme a bien été modifié."

    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-warning'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('programme_design')
        return form

class DiplomeDeleteView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, DeleteView):
    model = Diplome
    template_name= 'scolar/delete.html'
    permission_required = 'scolar.fonctionnalitenav_pedagogie_gestionprogrammes'
    success_message = "Le diplôme a bien éte supprimé"

    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression du diplôme : "+str(object_))
        return super(DiplomeDeleteView, self).delete(*args, **kwargs)
    
    def get_success_url(self):
        return reverse('programme_design')
      
class MatiereDetailView(DetailView):
    model = Matiere
    template_name_suffix = '_detail'

    def get_context_data(self, **kwargs):
        context = super(MatiereDetailView, self).get_context_data(**kwargs)
        context['object'] = {}
        try:
            context['object']['matiere'] = Matiere.objects.get(id=self.kwargs.get('pk'))
            context['object'].update(get_competence_context(MatiereCompetenceElement.objects.filter(matiere=self.kwargs.get('pk'))))
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors de la construction de la matrice de compétence pour la matière")
        context['pdf'] = False
        return context

class MatiereDetailPDFView(PDFTemplateView):
    template_name = 'scolar/matiere_detail_pdf.html'
    cmd_options={
        'orientation':'Portrait',
        'page-size':'A4',
        }
    def get_context_data(self, **kwargs):
        context = super(MatiereDetailPDFView, self).get_context_data(**kwargs)
        context['object'] = {}
        try:
            context['object']['matiere'] = Matiere.objects.get(id=self.kwargs.get('pk'))
            self.filename=str(context['object']['matiere'])+'.pdf'
            context['object'].update(get_competence_context(MatiereCompetenceElement.objects.filter(matiere=self.kwargs.get('pk'))))
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors de la construction de la matrice de compétence pour la matière")
        context['pdf'] = True
        return context

class MatiereDetailListPDFView(PDFTemplateView):
    template_name = 'scolar/matiere_detail_list_pdf.html'
    cmd_options={
        'orientation':'Portrait',
        'page-size':'A4',
        }
    def get_context_data(self, **kwargs):
        context = super(MatiereDetailListPDFView, self).get_context_data(**kwargs)
        programme_=Programme.objects.get(id=self.kwargs.get('programme_pk'))
        self.filename = "SYLLABUS_"+str(programme_)+".pdf"
        context['object'] = programme_
        context['matieres'] = {}
        try:
            for periode in programme_.periodes.all():
                for ue in periode.ues.all():
                    for matiere_ in ue.matieres.all():
                        if not matiere_.code in context['matieres'].keys():
                            context['matieres'][matiere_.code]={}
                            context['matieres'][matiere_.code]['matiere'] = matiere_
                            context['matieres'][matiere_.code].update(get_competence_context(MatiereCompetenceElement.objects.filter(matiere=matiere_)))
            context['categorie_ue']=dict(CAT_UE)
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors de la construction de la matrice de compétence pour les matière")
        context['pdf'] = True
        return context
    
class MatiereUpdateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, UpdateView): 
    model = Matiere
    fields=['code','precision', 'pfe', 'mode_projet', 'equipe', 'validable', 'seminaire', 'ddc', 'titre','titre_a','titre_en','coef','credit','edition','vh_cours','vh_td', 'vh_tp', 'pre_requis','objectifs','contenu','bibliographie','travail_perso']
    template_name = 'scolar/update.html'
    permission_required = 'scolar.fonctionnalitenav_pedagogie_gestionprogrammes'
    success_message = "La matière a bien été modifiée."
                           
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = MatiereFormHelper()
        if not activation_ddc() :
            form.fields['ddc'].disabled=True
            form.fields['ddc'].help_text="Les domaines de connaissances sont désactivés dans les paramètres de la plateforme."
        form.fields['credit'].help_text="Crédits (ou Nombre de semaines pour les formations modulaires)"
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        if activation_competences() :
            form.helper.add_input(Button('modifier','Définir Compétences', css_class='btn-warning', onclick="window.location.href='"+reverse('matiere_competence_update', kwargs={'matiere_pk':self.kwargs.get('pk')})+"'"))
        self.success_url =  self.request.META.get('HTTP_REFERER')
        return form
    
    def get_context_data(self, **kwargs):
        context = super(MatiereUpdateView, self).get_context_data(**kwargs)
        context['titre'] = 'Modifier la matière'
        return context

class MatiereCreateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, CreateView): 
    model = Matiere
    fields=['code', 'precision', 'pfe', 'mode_projet', 'equipe', 'validable', 'seminaire', 'ddc', 'titre','titre_a','titre_en','coef','credit','edition','vh_cours','vh_td', 'vh_tp', 'pre_requis','objectifs','contenu','bibliographie','travail_perso']
    template_name = 'scolar/create.html'
    permission_required = 'scolar.fonctionnalitenav_pedagogie_gestionprogrammes'
    success_message = "La matière a bien été créée."
                  
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = MatiereFormHelper()
        if not activation_ddc() :
            form.fields['ddc'].disabled=True
            form.fields['ddc'].help_text="Les domaines de connaissances sont désactivés dans les paramètres de la plateforme."
        form.fields['credit'].help_text="Crédits (ou Nombre de semaines pour les formations modulaires"
        form.helper.add_input(Submit('submit','Enregistrer', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))

        self.success_url =  reverse("programme_design")
        return form
    
    def get_context_data(self, **kwargs):
        context = super(MatiereCreateView, self).get_context_data(**kwargs)
        context['titre'] = 'Créer une nouvelle matière'
        return context


class MatiereDeleteView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, DeleteView):
    model = Matiere
    template_name= 'scolar/delete.html'
    permission_required = 'scolar.fonctionnalitenav_pedagogie_gestionprogrammes'
    success_message = "La matière a bien été supprimée."

    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression de la matière : "+str(object_))
        return super(MatiereDeleteView, self).delete(*args, **kwargs)
    
    def get_success_url(self):
        return reverse("programme_design")


class MatiereCompetenceElementUpdateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, UpdateView): 
    model = MatiereCompetenceElement
    fields=['niveau',]
    template_name = 'scolar/update.html'
    permission_required = 'scolar.fonctionnalitenav_pedagogie_gestionprogrammes'
    success_message = "L'élément de compétence a bien été modifié."
        
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url =  reverse('matiere_competence_update', kwargs={'matiere_pk':self.kwargs.get('matiere_pk')})
        return form
    
    def get_context_data(self, **kwargs):
        context = super(MatiereCompetenceElementUpdateView, self).get_context_data(**kwargs)
        context['titre'] = 'Modifier Niveau d\'acquisition de l\'élément de compétence'
        return context

class MatiereCompetenceElementDeleteView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, DeleteView):
    model = MatiereCompetenceElement
    template_name= 'scolar/delete.html'
    permission_required = 'scolar.fonctionnalitenav_pedagogie_gestionprogrammes'
    success_message = "L'élément de compétence a bien été supprimé."

    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression Matiere Competence Element : "+str(object_))
        return super(MatiereCompetenceElementDeleteView, self).delete(*args, **kwargs)
    
    def get_success_url(self):
        return reverse('matiere_competence_update', kwargs={'matiere_pk':self.kwargs.get('matiere_pk')})

def get_competence_context(matiere_competence_element_qs):
    # on construit ici la représentation matricielle des compétences:
    # ddc_list : en colonne la liste des domaines de connaissance
    # pgm_list : en colonne la liste des programmes (niveau d'études)
    # ce_list: en ligne la liste des éléments de compétence
    # ce_ddc_list: dans les cellules la liste des matières qui assurent cette élément de compétence
    # ce_pgm_list : dans les cellules la liste des matières qui assrent cet élement de compétence
    ddc_list=DomaineConnaissance.objects.all()
    pgm_list=Programme.objects.all().order_by('ordre')
    ce_ddc_list={}
    ce_pgm_list={}  
    cf_list={}
    matiere_ce_list={}


    for matiere_ce_ in matiere_competence_element_qs :
        competence_element_=matiere_ce_.competence_element
        competence_=competence_element_.competence
        competence_family_=competence_.competence_family
        
        if not competence_family_.code in cf_list.keys():
            cf_list[competence_family_.code]={
                'competence_family':competence_family_,
                'c_list':{},
                'nb_ce':0
                }                
        if not competence_.id in cf_list[competence_family_.code]['c_list'].keys():
            cf_list[competence_family_.code]['c_list'][competence_.id]={
                    'competence':competence_,
                    'ce_list':[],
                    'nb_ce':0
                }
        if not competence_element_ in cf_list[competence_family_.code]['c_list'][competence_.id]['ce_list']:
            cf_list[competence_family_.code]['c_list'][competence_.id]['ce_list'].append(competence_element_)
            cf_list[competence_family_.code]['c_list'][competence_.id]['nb_ce']+=1
            cf_list[competence_family_.code]['nb_ce']+=1
            for ddc_ in ddc_list:
                key_= str(competence_element_.id)+'_'+str(ddc_.id)
                ce_ddc_list[key_]=[]
            for pgm_ in pgm_list:
                key_= str(competence_element_.id)+'_'+str(pgm_.id)
                ce_pgm_list[key_]=[]
        if matiere_ce_.matiere.ddc :
            key_=str(competence_element_.id)+'_'+str(matiere_ce_.matiere.ddc.id)
        else : #Domaine de connaissance fictif ayant l'ID 0, permettant d'afficher les matières sans domaines de connaissances et de les prendre en charge dans la matrice de compétences
            key_=str(competence_element_.id)+'_0'
        if not key_ in ce_ddc_list.keys() :
            ce_ddc_list[key_]=[]
        ce_ddc_list[key_].append(matiere_ce_)
        
        for ue_ in matiere_ce_.matiere.matiere_ues.all():
            key_=str(competence_element_.id)+'_'+str(ue_.periode.programme.id)
            ce_pgm_list[key_].append(matiere_ce_)
            
    
    context={}
    context['pgm_list']=pgm_list
    context['cf_list']=cf_list
    context['ddc_list']=ddc_list
    context['ce_ddc_list']=ce_ddc_list
    context['ce_pgm_list']=ce_pgm_list
    context['ce_ddc_list_zero']=True
    
    return context

def competence_list_view(request):
    # if this is a POST request we need to process the form data
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = CompetenceForm(request.POST)
        # check whether it's valid:
        if form.is_valid():
            form_data=form.cleaned_data
            competence_family_=form_data['competence_family']
            competence_=form_data['competence']
            competence_element_=form_data['competence_element']
            
            if competence_element_:
                qs=MatiereCompetenceElement.objects.filter(competence_element__in = competence_element_).order_by('competence_element__competence__competence_family__code', 'competence_element__competence__code', 'competence_element__code', 'matiere__code')
            elif competence_:
                qs=MatiereCompetenceElement.objects.filter(competence_element__competence = competence_).order_by('competence_element__competence__competence_family__code', 'competence_element__competence__code', 'competence_element__code', 'matiere__code')
            elif competence_family_:
                qs=MatiereCompetenceElement.objects.filter(competence_element__competence__competence_family = competence_family_).order_by('competence_element__competence__competence_family__code', 'competence_element__competence__code', 'competence_element__code', 'matiere__code')
            else :
                qs=MatiereCompetenceElement.objects.all().order_by('competence_element__competence__competence_family__code', 'competence_element__competence__code', 'competence_element__code', 'matiere__code')
            exclude_=[]
            if not request.user.has_perm('scolar.fonctionnalite_pedagogie_gestioncompetences'):
                exclude_.append('edit')
                exclude_.append('admin')
            table =MatiereCompetenceElementTable(qs, exclude=exclude_)
            messages.success(request, "Les éléments de compétence ont bien été sélectionnés. Vous pouvez les visualiser dans le tableau ci-bas.")
            messages.success(request, "Vous pouvez visualiser la matrice de compétence construite avec ces éléments de compétence.")
    else:
        
        qs = MatiereCompetenceElement.objects.all().order_by('competence_element__competence__competence_family__code', 'competence_element__competence__code', 'competence_element__code', 'matiere__code')
        exclude_=[]
        if not request.user.has_perm('scolar.fonctionnalite_pedagogie_gestioncompetences'):
            exclude_.append('edit')
            exclude_.append('admin')
        table = MatiereCompetenceElementTable(qs, exclude=exclude_)
        
        form = CompetenceForm()
        #messages.info(request, "Utilisez ce formulaire pour sélectionner les éléments de compétences et visualiser la matrice de compétence.")
        #messages.info(request, "Par défaut, tous les éléments de compétence de la catégorie choisie seront sélectionnés.")
    try:
        context=get_competence_context(qs)
    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            messages.error(request, "ERREUR: lors de la création de la matrice de compétence. Merci de le signaler à l'administrateur.")
    context['form']=form
    context['table']=table
    context['titre']='Compétences développées à l\'issue de nos formations'
    return render(request, 'scolar/competence_matrice.html', context)

class ReferentielCompetenceView(TemplateView):
    template_name= 'scolar/referentiel_competence.html'
    titre = 'Référentiel de Compétences'
    
    def get_context_data(self, **kwargs):
        context = super(ReferentielCompetenceView, self).get_context_data(**kwargs)
        qs = MatiereCompetenceElement.objects.all().order_by('competence_element__competence__competence_family__code', 'competence_element__competence__code', 'competence_element__code', 'matiere__code')
        context.update(get_competence_context(qs))
        context['titre'] = self.titre
        matiere_list={}
        for matiere_ in Matiere.objects.all().order_by('code'):
            matiere_list[matiere_.id] = {}
            matiere_list[matiere_.id]['matiere']= matiere_
            matiere_list[matiere_.id].update(get_competence_context(MatiereCompetenceElement.objects.filter(matiere=matiere_)))

        context['matiere_list']= matiere_list
        context['categorie_ue']=dict(CAT_UE)
        
        return context

class MatriceCompetenceDDCView(ReferentielCompetenceView):
    template_name = 'scolar/matrice_competence_ddc.html'
    titre = 'Matrice des Compétences par Domaine de Connaissance'    

class MatriceCompetenceNiveauView(ReferentielCompetenceView):
    template_name = 'scolar/matrice_competence_niveau.html'
    titre = 'Matrice des Compétences par Niveau d\'étude'    

class CatalogueProgrammeView(ReferentielCompetenceView):
    template_name = 'scolar/catalogue_programme.html'
    titre = 'Catalogue des Programmes'
    
@login_required
@permission_required('scolar.fonctionnalitenav_pedagogie_gestionprogrammes')
def matiere_competence_update_view(request, matiere_pk):
    # if this is a POST request we need to process the form data
    matiere_=get_object_or_404(Matiere, id=matiere_pk)

    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = CompetenceForm(request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:
                form_data=form.cleaned_data
                competence_family_=form_data['competence_family']
                competence_=form_data['competence']
                competence_element_list=form_data['competence_element']
                for competence_element_ in competence_element_list:
                    MatiereCompetenceElement.objects.get_or_create(matiere=matiere_, competence_element=competence_element_, defaults={
                        'matiere':matiere_,
                        'competence_element':competence_element_,
                        'niveau':'B',
                    })
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: lors de l'ajout des éléments de compétence à la matière. Merci de le signaler à l'administrateur")
            messages.success(request, "Les éléments de compétence sélectionnés ont bien été rajouté à la matière.")
    else:
        form = CompetenceForm()
        messages.info(request, "Merci de sélectionner les éléments de compétence à rajouter à la matière.")

    qs = MatiereCompetenceElement.objects.filter(matiere=matiere_).order_by('competence_element__competence__competence_family__code', 'competence_element__competence__code', 'competence_element__code', 'matiere__code')
    exclude_=[]
    if not request.user.has_perm('scolar.fonctionnalite_pedagogie_gestioncompetences'):
        exclude_.append('edit')
        exclude_.append('admin')
    table = MatiereCompetenceElementTable(qs, exclude=exclude_)
    try:
        context=get_competence_context(qs)
    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            messages.error(request, "ERREUR: lors de la construction de la matrice de compétences. Merci de le signaler à l'administrateur.")
    context['form']=form
    context['table']=table
    context['titre']='Compétences développées à l\'issue de nos formations'

    return render(request, 'scolar/competence_matrice.html', context)
    
class CompetenceFamilyListView(TemplateView):

    template_name = 'scolar/list.html'
    
    def get_context_data(self, **kwargs):
        context = super(CompetenceFamilyListView, self).get_context_data(**kwargs)
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalite_pedagogie_gestioncompetences'):
            exclude_.append('edit')
            exclude_.append('admin')
        table = CompetenceFamilyTable(CompetenceFamily.objects.all().order_by('code'), exclude=exclude_)
        
        RequestConfig(self.request).configure(table)
        context['titre'] = 'Familles de Compétences'
        context['table'] = table
        context['back'] = reverse('competence_list')
        if self.request.user.has_perm('scolar.fonctionnalite_pedagogie_gestioncompetences'):
            context['create_url'] = reverse('competence_family_create')
            context['create_btn'] = 'Famille Compétences'
        btn_list={
            'Référentiel Compétences':reverse('referentiel_competence'),
            'Matrice Compétence / DDC': reverse('matrice_competence_ddc'),
            'Matrice Compétence / Niveau': reverse('matrice_competence_niveau')
        }
        if not activation_ddc() :
            del btn_list['Matrice Compétence / DDC']
        context['btn_list']=btn_list
        return context

class CompetenceFamilyCreateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, CreateView):
    model = CompetenceFamily
    fields = ['code', 'intitule']
    template_name = 'scolar/create.html'
    permission_required = 'scolar.fonctionnalite_pedagogie_gestioncompetences'
    success_message = "La famille de compétences a bien été créée."
        
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.helper.add_input(Submit('submit','Ajouter', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('competence_family_list')
        return form

    def get_context_data(self, **kwargs):
        context = super(CompetenceFamilyCreateView, self).get_context_data(**kwargs)
        context['titre'] = 'Ajouter une Famille de Compétences'
        return context

class CompetenceFamilyUpdateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, UpdateView):
    model = CompetenceFamily
    fields = ['code', 'intitule']
    template_name = 'scolar/update.html'
    permission_required = 'scolar.fonctionnalite_pedagogie_gestioncompetences'
    success_message = "La famille de compétence a bien été modifiée."
        
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url =  reverse('competence_family_list')
        return form

class CompetenceFamilyDeleteView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, DeleteView):
    model = CompetenceFamily
    template_name= 'scolar/delete.html'
    permission_required = 'scolar.fonctionnalite_pedagogie_gestioncompetences'
    success_message = "La famille de compétence a bien été supprimée."

    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression de la famille de compétences : "+str(object_))
        return super(CompetenceFamilyDeleteView, self).delete(*args, **kwargs)
    
    def get_success_url(self):
        return reverse('competence_family_list')


class CompetenceListView(TemplateView):

    template_name = 'scolar/list.html'
    
    def get_context_data(self, **kwargs):
        context = super(CompetenceListView, self).get_context_data(**kwargs)
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalite_pedagogie_gestioncompetences'):
            exclude_.append('edit')
            exclude_.append('admin')
        table = CompetenceTable(Competence.objects.filter(competence_family=self.kwargs.get('competence_family_pk')).order_by('code'), exclude=exclude_)
        
        RequestConfig(self.request).configure(table)
        context['titre'] = 'Liste de Compétences de la famille '+self.kwargs.get('competence_family_pk')
        context['table'] = table
        context['back'] = reverse('competence_family_list')
        if self.request.user.has_perm('scolar.fonctionnalite_pedagogie_gestioncompetences'):
            context['create_url'] = reverse('competence_create', kwargs={'competence_family_pk': self.kwargs.get('competence_family_pk')})
            context['create_btn'] = 'Compétence'
        return context

class CompetenceCreateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, CreateView):
    model = Competence
    fields = ['code', 'competence_family', 'intitule']
    template_name = 'scolar/create.html'
    permission_required = 'scolar.fonctionnalite_pedagogie_gestioncompetences'
    success_message = "La compétence a bien été créée."
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.fields['competence_family']=forms.ModelChoiceField(queryset=CompetenceFamily.objects.filter(code=self.kwargs.get('competence_family_pk')), initial=0)
        form.helper.add_input(Submit('submit','Ajouter', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('competence_list', kwargs={'competence_family_pk':self.kwargs.get('competence_family_pk')})
        return form

    def get_context_data(self, **kwargs):
        context = super(CompetenceCreateView, self).get_context_data(**kwargs)
        context['titre'] = 'Ajouter une Compétences à '+ self.kwargs.get('competence_family_pk')
        return context

class CompetenceUpdateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, UpdateView):
    model = Competence
    fields = ['code', 'competence_family', 'intitule']
    template_name = 'scolar/update.html'
    permission_required = 'scolar.fonctionnalite_pedagogie_gestioncompetences'
    success_message = "La compétence a bien été modifiée."

    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('competence_list', kwargs={'competence_family_pk':self.kwargs.get('competence_family_pk')})
        return form

class CompetenceDeleteView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, DeleteView):
    model = Competence
    template_name= 'scolar/delete.html'
    permission_required = 'scolar.fonctionnalite_pedagogie_gestioncompetences'
    success_message = "La compétence a bien été supprimée."

    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression de la compétence : "+str(object_))
        return super(CompetenceDeleteView, self).delete(*args, **kwargs)
    
    def get_success_url(self):
        return reverse('competence_list', kwargs={'competence_family_pk':self.kwargs.get('competence_family_pk')})

class CompetenceElementListView(TemplateView):

    template_name = 'scolar/list.html'
    
    def get_context_data(self, **kwargs):
        context = super(CompetenceElementListView, self).get_context_data(**kwargs)
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalite_pedagogie_gestioncompetences'):
            exclude_.append('edit')
            exclude_.append('admin')
        table = CompetenceElementTable(CompetenceElement.objects.filter(competence=self.kwargs.get('competence_pk')).order_by('code'), exclude=exclude_)
        competence_=get_object_or_404(Competence, id=self.kwargs.get('competence_pk'))
        RequestConfig(self.request).configure(table)
        context['titre'] = 'Liste des éléments de Compétences'
        context['table'] = table
        context['back'] = reverse('competence_list', kwargs={'competence_family_pk':competence_.competence_family.code})
        if self.request.user.has_perm('scolar.fonctionnalite_pedagogie_gestioncompetences'):
            context['create_url'] = reverse('competence_element_create', kwargs={'competence_pk': self.kwargs.get('competence_pk')})
            context['create_btn'] = 'Element de Compétence'
        return context

class CompetenceElementCreateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, CreateView):
    model = CompetenceElement
    fields = ['code', 'competence', 'intitule', 'type', 'objectif']
    template_name = 'scolar/create.html'
    permission_required = 'scolar.fonctionnalite_pedagogie_gestioncompetences'
    success_message = "L'étément de compétence a bien été créé."
        
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.fields['competence']=forms.ModelChoiceField(queryset=Competence.objects.filter(id=self.kwargs.get('competence_pk')), initial=0)
        form.helper.add_input(Submit('submit','Ajouter', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('competence_element_list', kwargs={'competence_pk':self.kwargs.get('competence_pk')})
        return form

    def get_context_data(self, **kwargs):
        context = super(CompetenceElementCreateView, self).get_context_data(**kwargs)
        context['titre'] = 'Ajouter un Element de Compétence'
        return context

class CompetenceElementUpdateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, UpdateView):
    model = CompetenceElement
    fields = ['code', 'competence', 'intitule', 'type', 'objectif']
    template_name = 'scolar/update.html'
    permission_required = 'scolar.fonctionnalite_pedagogie_gestioncompetences'
    success_message = "L'étément de compétence a bien été modifié."        
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('competence_element_list', kwargs={'competence_pk':self.kwargs.get('competence_pk')})
        return form

class CompetenceElementDeleteView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, DeleteView):
    model = CompetenceElement
    template_name= 'scolar/delete.html'
    permission_required = 'scolar.fonctionnalite_pedagogie_gestioncompetences'
    success_message = "L'étément de compétence a bien été supprimé."
 
    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression de l'élément de compétence : "+str(object_))
        return super(CompetenceElementDeleteView, self).delete(*args, **kwargs)
       
    def get_success_url(self):
        return reverse('competence_element_list', kwargs={'competence_pk':self.kwargs.get('competence_pk')})

@login_required
def livret_competences_generation(request, etudiant_pk):
    try :
        if (activation_livret_competences() and request.user.has_perm_or_student_himself('scolar.fonctionnalite_etudiants_documents', etudiant_pk)) :
            pass
        else :
            messages.error(request, "Vous n'êtes pas autorisé à exécuter cette opération.")
            return HttpResponseRedirect(reverse('etudiant_documents_list', kwargs={'etudiant_pk': etudiant_pk}))
        etudiant_=Etudiant.objects.get(matricule=etudiant_pk)
        already_generated=False
        if request.user == etudiant_.user and not request.user.has_perm('scolar.fonctionnalite_etudiants_documents') :
            if etudiant_.livret_last_upload :
                if (etudiant_.livret_last_upload+ datetime.timedelta(hours=1)) > timezone.now() :
                    already_generated=True
                    messages.error(request, "Le livret de compétences a déjà été généré dans la dernière heure. Veuillez patienter 1H à compter de votre dernière génération.")
                    return HttpResponseRedirect(reverse('etudiant_documents_list', kwargs={'etudiant_pk': etudiant_pk}))
        
        if not already_generated :
            messages.info(request, "La demande de génération du livret de compétences a été prise en compte. Veuillez patienter de quelques secondes à quelques minutes. Une fois le livret de compétences généré, il pourra être téléchargé sur cette même page.")
            t = threading.Thread(target=task_livret_competences,args=[etudiant_pk, request.user])
            t.setDaemon(True)
            t.start()            
            return HttpResponseRedirect(reverse('etudiant_documents_list', kwargs={'etudiant_pk': etudiant_pk}))
            
    except Exception :
        raise Exception("Erreur dans la génération du livret de compétences de l'étudiant "+str(etudiant_pk))
    

def task_livret_competences(etudiant_pk, user):
    
    try :
        #if not (activation_livret_competences() and self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_etudiants_documents', self.kwargs.get('etudiant_pk')))
        #    return
        etudiant_=Etudiant.objects.get(matricule=etudiant_pk)
        inscriptions_avec_admission_list_tmp = Inscription.objects.filter(etudiant=etudiant_).filter( Q(decision_jury='A') | Q(decision_jury='AR') | Q(decision_jury='AC') | Q(decision_jury='CR')| Q(decision_jury='AD')| Q(decision_jury='SR')).order_by('formation__programme__ordre') 
        inscriptions_avec_admission_list = []
        for inscription_ in inscriptions_avec_admission_list_tmp :
            if ((inscription_.formation.archive ==True) | ((inscription_.formation.annee_univ.encours == False)&( inscription_.formation.programme.inclut_pfe()))) :
                inscriptions_avec_admission_list.append(inscription_)
        competence_competenceelementlist={}
        competencefamily_competences={}
        inscriptions_competencefamily={}
        elements_matieres={}
        matieres_ects={}
        calcul_ects_modules={}
        
        for inscription_ in inscriptions_avec_admission_list:
            modules_suivis_=[] 
            for module_suivi_ in inscription_.groupe.modules_suivis.all():
                modules_suivis_.append(module_suivi_) 
            modules_suivis_=Module.objects.filter(groupes_suivis__groupe__inscrits=inscription_).distinct()
            competence_elements_=CompetenceElement.objects.filter(competence_elements__matiere__matiere_ues__periode__programme=inscription_.formation.programme).filter(competence_elements__matiere__module__in=modules_suivis_).order_by('code').distinct()
            competences_=Competence.objects.filter(competence_elements__in=competence_elements_).order_by('code').distinct()
            competencefamilys_=CompetenceFamily.objects.filter(competences__in=competences_).order_by('code').distinct()
            for family_ in competencefamilys_:
                competences_dans_la_famille=competences_.filter(competence_family=family_) .distinct()  
                for competence_ in competences_dans_la_famille:                     
                    elements_dans_la_competence=competence_elements_.filter(competence=competence_).distinct()
                    nb_lignes_elements_multiplie_par_matieres=0      
                    for element_ in elements_dans_la_competence:   
                        matieres_pour_element=Matiere.objects.filter(matierecompetenceelement__competence_element=element_, matiere_ues__periode__programme=inscription_.formation.programme).filter( module__in=modules_suivis_).distinct()
                        nb_matieres_pour_element=matieres_pour_element.count()
                        nb_lignes_elements_multiplie_par_matieres+=nb_matieres_pour_element
                        for matiere_ in matieres_pour_element:
                            resultat_module=Resultat.objects.get(inscription=inscription_, module__matiere=matiere_)
                            ects_et_niveau=[]
                            ects_et_niveau.append(resultat_module.calcul_ects())
                            matiere_competence_element_=MatiereCompetenceElement.objects.get(matiere=matiere_, competence_element=element_)
                            ects_et_niveau.append(matiere_competence_element_.niveau)
                            matieres_ects[matiere_]=ects_et_niveau
                        matieres_ects_et_ects_moyen_et_nb=[]
                        matieres_ects_et_ects_moyen_et_nb.append(matieres_ects)
                        modules_des_matieres_=Module.objects.filter(matiere__in=matieres_pour_element, groupes_suivis__groupe__inscrits=inscription_)                    
                        set_modules_pour_calcul_ects=frozenset(modules_des_matieres_)
                        if set_modules_pour_calcul_ects in calcul_ects_modules.keys() :
                            ects_moyen_matieres=calcul_ects_modules[set_modules_pour_calcul_ects] 
                        else :
                            calcul_ects_modules[set_modules_pour_calcul_ects]=etudiant_.ects_agrege_de_plusieurs_modules(modules_des_matieres_)
                            ects_moyen_matieres=calcul_ects_modules[set_modules_pour_calcul_ects]
                        matieres_ects_et_ects_moyen_et_nb.append(ects_moyen_matieres)       
                        matieres_ects_et_ects_moyen_et_nb.append(nb_matieres_pour_element)          
                        elements_matieres[element_]=matieres_ects_et_ects_moyen_et_nb
                        matieres_ects={}                      
                    elements_et_nb_lignes_elements_multiplie_par_matieres_et_ects_moyen=[]
                    elements_et_nb_lignes_elements_multiplie_par_matieres_et_ects_moyen.append(elements_matieres)
                    elements_et_nb_lignes_elements_multiplie_par_matieres_et_ects_moyen.append(nb_lignes_elements_multiplie_par_matieres)  
                    matieres_des_elements=Matiere.objects.filter(matierecompetenceelement__competence_element__in=elements_dans_la_competence, matiere_ues__periode__programme=inscription_.formation.programme).filter( module__in=modules_suivis_).distinct()
                    modules_des_elements_=Module.objects.filter(matiere__in=matieres_des_elements, groupes_suivis__groupe__inscrits=inscription_)                    
                    set_modules_pour_calcul_ects=frozenset(modules_des_elements_)
                    if set_modules_pour_calcul_ects in calcul_ects_modules.keys() :
                        ects_moyen_elements=calcul_ects_modules[set_modules_pour_calcul_ects] 
                    else :
                        calcul_ects_modules[set_modules_pour_calcul_ects]=etudiant_.ects_agrege_de_plusieurs_modules(modules_des_elements_)
                        ects_moyen_elements=calcul_ects_modules[set_modules_pour_calcul_ects]                    
                    elements_et_nb_lignes_elements_multiplie_par_matieres_et_ects_moyen.append(ects_moyen_elements) 
                    competence_competenceelementlist[competence_]=elements_et_nb_lignes_elements_multiplie_par_matieres_et_ects_moyen
                    elements_matieres={}
                competences_et_ects_moyen=[]
                competences_et_ects_moyen.append(competence_competenceelementlist)
                matieres_des_competences=Matiere.objects.filter(matierecompetenceelement__competence_element__competence__in=competences_dans_la_famille, matiere_ues__periode__programme=inscription_.formation.programme).filter( module__in=modules_suivis_).distinct()
                modules_des_competences_= Module.objects.filter(matiere__in=matieres_des_competences, groupes_suivis__groupe__inscrits=inscription_)
                set_modules_pour_calcul_ects=frozenset(modules_des_competences_)
                if set_modules_pour_calcul_ects in calcul_ects_modules.keys() :
                    ects_moyen_competences=calcul_ects_modules[set_modules_pour_calcul_ects] 
                else :
                    calcul_ects_modules[set_modules_pour_calcul_ects]=etudiant_.ects_agrege_de_plusieurs_modules(modules_des_competences_)
                    ects_moyen_competences=calcul_ects_modules[set_modules_pour_calcul_ects]                   
                competences_et_ects_moyen.append(ects_moyen_competences)               
                competencefamily_competences[family_]=competences_et_ects_moyen
                competence_competenceelementlist={}                          
            inscriptions_competencefamily[inscription_]=competencefamily_competences
            competencefamily_competences={}            
        
        modules_suivis_global_=Module.objects.filter(groupes_suivis__groupe__inscrits__in=inscriptions_avec_admission_list).distinct()
        familles_=CompetenceFamily.objects.filter(competences__competence_elements__competence_elements__matiere__matiere_ues__periode__programme__formation__inscription__in=inscriptions_avec_admission_list, competences__competence_elements__competence_elements__matiere__module__in=modules_suivis_global_).order_by('code').distinct()
        familles_ects_global={}
        for famille_ in familles_:
            modules_suivis_famille_=modules_suivis_global_.filter(matiere__matierecompetenceelement__competence_element__competence__competence_family=famille_).distinct()
            familles_ects_global[famille_]=etudiant_.ects_agrege_de_plusieurs_modules(modules_suivis_famille_)
        context={}
        context['etudiant'] = etudiant_
        context['inscriptions_competencefamilys']=inscriptions_competencefamily
        context['familles_ects_global']=  familles_ects_global
        context['date'] = datetime.date.today()
        context['pdf']=1
        context['institution']=user.institution()
        random_string=''.join(random.choices(string.ascii_uppercase + string.digits, k=10))
        filename = 'Livret_'+random_string+'.pdf'

        cmd_options={
            'orientation':'Portrait',
            'page-size':'A4',
        }
        pdf_=render_pdf_from_template(input_template='scolar/livret_competences_pdf.html', 
                                      header_template=None,
                                      footer_template=None,
                                      context=context, 
                                      cmd_options=cmd_options)

        etudiant_.livret_competences.save(filename, io.BytesIO(pdf_))
        etudiant_.livret_last_upload=timezone.now()
        etudiant_.save(update_fields=['livret_last_upload',])
        return
    except Exception :
        raise Exception('Erreur dans la génération du livret de compétences')


class PeriodeDeleteView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, DeleteView):
    model = Periode
    template_name= 'scolar/delete.html'
    permission_required = 'scolar.fonctionnalitenav_pedagogie_gestionprogrammes'
    success_message = "La période a bien été supprimée."

    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression de la période : "+str(object_))
        return super(PeriodeDeleteView, self).delete(*args, **kwargs)
        
    def get_success_url(self):
        return reverse('programme_design')

class UEDeleteView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, DeleteView):
    model = UE
    template_name = 'scolar/delete.html'
    permission_required = 'scolar.fonctionnalitenav_pedagogie_gestionprogrammes'
    success_message = "L'UE a bien été supprimée.."

    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression de l'UE : "+str(object_))
        return super(UEDeleteView, self).delete(*args, **kwargs)
        
    def get_success_url(self):
        return reverse('programme_detail',kwargs={'pk': str(self.kwargs.get('programme_pk'))})


class UEUpdateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, UpdateView):
    model = UE
    print("ue create function")
    fields = ['code', 'code_a', 'type','nature','periode','matieres']
    template_name = 'scolar/update.html'
    permission_required = 'scolar.fonctionnalitenav_pedagogie_gestionprogrammes'
    success_message = "L'UE a bien été modifiée."
    
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.fields['periode']=forms.ModelChoiceField(queryset=PeriodeProgramme.objects.filter(programme=self.kwargs.get('programme_pk')), initial=self.kwargs.get('periode_pk'))
        form.fields['matieres']=forms.ModelMultipleChoiceField(queryset=Matiere.objects.all().order_by('code'),widget=
                                    ModelSelect2MultipleWidget(
                                        Model=Matiere,
                                        search_fields=['code__icontains','titre__icontains']
                                    ), 
                                    help_text="Tapez le nom de la matière. Vous pouvez sélectionner plusieurs. Tapez deux espaces pour avoir la liste complète")
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-warning'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('programme_detail',kwargs={'pk': str(self.kwargs.get('programme_pk'))})
        return form

# @receiver(m2m_changed, sender=UE.matieres.through)
# def update_modulessuivis_resultats(sender, instance, action, **kwargs):
#     print("print add ")
#     if action=="post_add" :
#         try:
#             with transaction.atomic():
#                 # déclencher les signaux qui permettent de synchroniser ModulesSuivis par les groupes
#                 # qui suivent ce programme qui vient d'être modifié
#                 groupe_list_=Groupe.objects.filter(section__formation__programme=instance.periode.programme)
#                 for groupe_ in groupe_list_:
#                     # déclencher la mise à jour de MosulesSuivis par le groupe
#                     # Attention ceci ne déclenche pas les modules optionnels. Pour ce faire il faut modifier le groupe et supprimer et ajouter la nouvelle UE pour déclencher le m2m_changed du groupe
#                     groupe_.save()
            
#                 inscription_periode_list_=InscriptionPeriode.objects.filter(periodepgm=instance.periode)
             
#                 for inscription_periode_ in inscription_periode_list_:
#                     # déclencher la mise à jour des résultats 
#                     inscription_periode_.save()
#         except Exception as e:
#             if settings.DEBUG:
#                 raise Exception
#             else:
#                 if activation_emails():
#                     email = EmailMessage('[Talents] Erreur lors de la modification de l\'UE '+str(instance),
#                                          'Bonjour,\n'+ 
#                                          'Une erreur s\'est produite lors de la modification de l\'UE '+ str(instance)+'\n'+
#                                          'Bien cordialement.\n'+
#                                          signature_emails()+'\n'+
#                                          str(e), to=email_webmaster() )
#                     email.send(fail_silently=True)
            
        
class ResultatUEDeleteView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, DeleteView):
    model = ResultatUE
    template_name = 'scolar/delete.html'
    permission_required = 'scolar.fonctionnalite_etudiants_reinitialisationnotesetacquis'
    success_message = "L'UE a bien été supprimée.."
    
    def get_success_url(self):
        return reverse('releve_notes',kwargs={'inscription_pk': str(self.kwargs.get('inscription_pk'))})
    
    def delete(self, *args, **kwargs):
        resultat_ue_=self.get_object()
        trace_create(self.request.user, resultat_ue_.inscription_periode.inscription.etudiant, "Suppression Résultat UE : "+str(resultat_ue_))
        return super(ResultatUEDeleteView, self).delete(*args, **kwargs)

class PeriodeProgrammeCreateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, CreateView):
    model = PeriodeProgramme
    fields = ['periode', 'programme', 'code']
    template_name = 'scolar/create.html'
    permission_required = 'scolar.fonctionnalitenav_pedagogie_gestionprogrammes'
    success_message = "La période a bien été créée."
        
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.fields['programme']=forms.ModelChoiceField(queryset=Programme.objects.filter(id=self.kwargs.get('programme_pk')), initial=0)
        form.fields['periode']=forms.ModelChoiceField(queryset=Periode.objects.all())
        form.helper.add_input(Submit('submit','Ajouter', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('programme_detail', kwargs={'pk':self.kwargs.get('programme_pk')})
        return form

    def get_context_data(self, **kwargs):
        context = super(PeriodeProgrammeCreateView, self).get_context_data(**kwargs)
        context['titre'] = 'Ajouter une période'
        return context
    
class PeriodeProgrammeUpdateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, UpdateView):
    model = PeriodeProgramme
    fields = ['periode', 'programme', 'code']
    template_name = 'scolar/update.html'
    permission_required = 'scolar.fonctionnalitenav_pedagogie_gestionprogrammes'
    success_message = "La période a bien été modifié."
        
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.fields['programme']=forms.ModelChoiceField(queryset=Programme.objects.filter(id=self.kwargs.get('programme_pk')), initial=0)
        form.fields['periode']=forms.ModelChoiceField(queryset=Periode.objects.all())
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-warning'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('programme_detail', kwargs={'pk':self.kwargs.get('programme_pk')})
        return form

class PeriodeProgrammeDeleteView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, DeleteView):
    model = PeriodeProgramme
    template_name = 'scolar/delete.html'
    permission_required = 'scolar.fonctionnalitenav_pedagogie_gestionprogrammes'
    success_message = "La période a bien été supprimée."

    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression de la période programme : "+str(object_))
        return super(PeriodeProgrammeDeleteView, self).delete(*args, **kwargs)
        
    def get_success_url(self):
        return reverse('programme_detail',kwargs={'pk': str(self.kwargs.get('programme_pk'))})

class PeriodeCreateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, CreateView):
    model = Periode
    fields = ['code', 'session', 'ordre', 'nb_semaines']
    template_name = 'scolar/create.html'
    permission_required = 'scolar.fonctionnalitenav_pedagogie_gestionprogrammes'
    success_message = "La période a bien été créée."
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.helper.add_input(Submit('submit','Ajouter', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('programme_design')
        return form

    def get_context_data(self, **kwargs):
        context = super(PeriodeCreateView, self).get_context_data(**kwargs)
        context['titre'] = 'Ajouter une période'
        return context

class PeriodeUpdateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, UpdateView):
    model = Periode
    fields = ['code', 'ordre', 'session', 'nb_semaines']
    template_name = 'scolar/update.html'
    permission_required = 'scolar.fonctionnalitenav_pedagogie_gestionprogrammes'
    success_message = "La période a bien été modifiée."
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-primary'))
        self.success_url = reverse('programme_design')
        return form



class UECreateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, CreateView):
    model = UE
    fields = ['code', 'code_a', 'type','nature','periode','matieres']
    template_name = 'scolar/create.html'
    permission_required = 'scolar.fonctionnalitenav_pedagogie_gestionprogrammes'
    success_message = "L'UE a bien été créée."
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.fields['periode']=forms.ModelChoiceField(queryset=PeriodeProgramme.objects.filter(id=self.kwargs.get('periode_pk')),initial=0)
        form.fields['matieres']=forms.ModelMultipleChoiceField(queryset=Matiere.objects.all().order_by('code'), widget=
                                    ModelSelect2MultipleWidget(
                                        Model=Matiere,
                                        search_fields=['code__icontains','titre__icontains']
                                    ), 
                                    help_text="Tapez le nom de la matière. Vous pouvez sélectionner plusieurs. Tapez deux espaces pour avoir la liste complète")
        form.helper.add_input(Submit('submit','Ajouter', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('programme_detail',kwargs={'pk': str(self.kwargs.get('programme_pk'))})
        return form

    def get_context_data(self, **kwargs):
        context = super(UECreateView, self).get_context_data(**kwargs)
        context['titre'] = 'Ajouter une UE'
        return context
        
@login_required          
def absencesform(request, activite_pk, groupe_pk):
    activite_=get_object_or_404(Activite, id=activite_pk)
    if not request.user.has_perm('scolar.fonctionnalitenav_etudiants_signalementabsences') :
        if request.user.is_enseignant():
            if not assure_module(request.user.enseignant, activite_.module):
                messages.error(request, "Vous n'êtes pas autorisés à excécuter cette opération")
                return redirect('/accounts/login/?next=%s' % request.path)
        else :
            messages.error(request, "Vous n'êtes pas autorisés à excécuter cette opération")
            return redirect('/accounts/login/?next=%s' % request.path)
    
        
        # if this is a POST request we need to process the form data
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = AbsencesForm(groupe_pk, activite_.module.id, request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:
                # process the data in form.cleaned_data as required
                data=form.cleaned_data
                seance_, created = Seance.objects.get_or_create(activite=activite_.id, date=data['seance_date'], rattrapage=data['seance_rattrapage'], defaults={
                        'activite':activite_,
                        'date': data['seance_date'],
                        'rattrapage':data['seance_rattrapage'] 
                    })
                absence_list=''
                for matricule_ in data['absence_list']:
                    etudiant_=get_object_or_404(Etudiant,matricule=matricule_)
#                 if data[inscrit]==True:
#                     etudiant_=get_object_or_404(Etudiant,matricule=inscrit)
                    absence_etudiant_, created = AbsenceEtudiant.objects.get_or_create(etudiant=etudiant_, seance=seance_, defaults={
                            'etudiant':etudiant_,
                            'seance':seance_
                        })
                    absence_list+=str(etudiant_)+'\n'
                    
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: Le signalement des absences s'est terminé avec echec. Merci de le signaler à l'administrateur.")
                    return HttpResponseRedirect(reverse('assiduite', kwargs={'activite_pk': seance_.activite.id}))
            messages.success(request, "Le signalement des absences s'est terminé avec succès!")
            # envoyer un message à l'enseignant + assistant
            
            if activation_emails():
                liste_emails=[]
                if request.user.email :
                    liste_emails.append(request.user.email)
                if request.user.email and not (request.user.email == activite_.module.formation.programme.get_email_assistant()) :
                    liste_emails.append(activite_.module.formation.programme.get_email_assistant())
                email = EmailMessage('[Talents] Absences Signalées en '+str(seance_),
                                     'Bonjour '+str(request.user.enseignant.prenom)+',\n'+ 
                                     'Nous confirmons le signalement des absences suivantes \n'+ 
                                     absence_list +
                                     'Les concernés ont été notifiés et invités à justifier leur absence dans les 48h\n'
                                     'Bien cordialement.\n'+
                                     signature_emails(), to=liste_emails )
                email.send(fail_silently=True)

            # redirect to a new URL:
            return HttpResponseRedirect(reverse('assiduite', kwargs={'activite_pk': seance_.activite.id})) 
    # if a GET (or any other method) we'll create a blank form
    else:
        form = AbsencesForm(groupe_pk, activite_.module.id)
        messages.info(request,"Merci de cocher les étudiants absents.")
    return render(request, 'scolar/import.html', {'form': form, 'titre':"Fiche d'absences"})



@receiver(post_save, sender=AbsenceEtudiant)
def email_absence_etudiant(sender, update_fields, instance, created, **kwargs):
    try:
        if activation_emails():
            if created:
                nb_absences = instance.nb_absences()
                if nb_absences < 3:
                    email = EmailMessage(str(nb_absences)+' Absences Signalées en '+str(instance.seance.activite),
                                         'Bonjour,\n'+ 
                                         'Nous espérons que vous allez bien!\n Nous vous informons qu\'une nouvelle absence en '+ str(instance.seance.activite) +
                                         ' a été signalée en date du : '+instance.seance.date.strftime('%d/%m/%Y')+'\n'+
                                         'Veuillez vous rapprocher de la surveillance ('+str(instance.seance.activite.module.formation.programme.get_email_assistant())+
                                         ') dans les 48h pour justifier votre absence.\n'+
                                         'Sinon, vous allez vous exposez à des sanctions.\n'+
                                         'Merci de préciser dans votre justification le module et la date de l\'absence' +
                                         'Bien cordialement.\n'+
                                         signature_emails(), to=[instance.etudiant.get_email()] )
                elif nb_absences < 5:
                    email = EmailMessage('AVERTISSEMENT & CONVOCATION '+str(nb_absences)+' Absences Signalées en '+instance.seance.activite.module.matiere.code,
                             'Matricule: '+instance.etudiant.matricule+'\n'+
                             'Nom & Prénoms: '+instance.etudiant.nom+' '+ instance.etudiant.prenom+'\n'+
                             'Année d\'études: '+str(instance.seance.activite.module.formation)+'\n'+
                             'Email: '+instance.etudiant.get_email()+'\n'+
                             'Tel: '+str(instance.etudiant.tel)+'\n\n\n'
                             'Bonjour,\n'+
                             'Nous espérons que vous allez bien!\n'+
                             'Nous vous informons que '+ str(nb_absences) + ' absences au module '+ instance.seance.activite.module.matiere.code +' ont été signalées\n'+
                             'Ceci est un AVERTISSEMENT.\n'+
                             'Veuillez vous rapprocher du Chef de Département pour clarifier votre situation.\n'+
                             'Nous vous rappelons que la réglementation des études stipule l\'exclusion d\'une matière dans le cas de:\n'+
                             '3 absences consécutives non justifiées, ou\n'+
                             '5 absences mêmes justifiées.\n'+
                             'Bien cordialement.\n'+
                             signature_emails(), to=[instance.etudiant.get_email(), instance.seance.activite.module.formation.programme.get_email_responsable_autorite_cycle()]+[x.user.get_email() for x in instance.seance.activite.assuree_par.all()] )
                else:
                    email = EmailMessage('EXCLUSION suite à '+str(nb_absences)+' Absences Signalées en '+instance.seance.activite.module.matiere.code,
                         'Matricule: '+instance.etudiant.matricule+'\n'+
                         'Nom & Prénoms: '+instance.etudiant.nom+' '+ instance.etudiant.prenom+'\n'+
                         'Année d\'études: '+str(instance.seance.activite.module.formation)+'\n'+
                         'Email: '+instance.etudiant.get_email()+'\n'+
                         'Tel: \n\n\n'
                         'Bonjour,\n'+
                         'Nous espérons que vous allez bien!\n'+
                         'Nous vous informons que '+ str(nb_absences) + ' absences au module '+ instance.seance.activite.module.matiere.code +' ont été signalées\n'+
                         'Nous vous rappelons que la réglementation des études stipule l\'exclusion d\'une matière dans le cas de:\n'+
                         '3 absences consécutives non justifiées, ou\n'+
                         '5 absences mêmes justifiées.\n'+
                         'Veuillez donc vous rapprocher du Département pour clarifier votre situation et demander le cas échéant un billet d\'accès en salle.'
                         'Si vous êtes redoublant ou en 1ère année, nous vous conseillons d\'entamer vos prospections de réorientation dès maintenant car il est difficile de trouver des places à l\'université en mois de septembre.\n'+
                         'Bien cordialement.\n'+
                         signature_emails(), to=[instance.etudiant.get_email(), instance.seance.activite.module.formation.programme.get_email_responsable_autorite_cycle()]+ email_scolarite()+ email_direction() )
                    # basculer l'état d'inscription vers ABANDON
                    #inscription_=Inscription.objects.get(etudiant=instance.etudiant, formation__annee_univ__encours=True)
                    #inscription_.decision_jury__startswith='F'
                    #inscription_.save(update_fields=['decision_jury'])
                email.send(fail_silently=True)
            elif instance.justif:
                email = EmailMessage('[Talents] Justification Absence en '+str(instance.seance),
                                         'Bonjour '+instance.etudiant.prenom+',\n'+ 
                                         'Nous vous informons que Talents a enregistré votre justification de votre absence en:\n'+
                                         str(instance.seance)+' du '+instance.seance.date.strftime('%d/%m/%Y')+'\n'+
                                         'Bien cordialement.\n'+
                                         signature_emails(), to=[instance.etudiant.get_email()] )
                email.send(fail_silently=True)
    except Exception:
        print("ERREUR: un ou plusieurs notifications par mail non pas été envoyées.")
        
        
def absence_etudiant_justification_view(request):
    if not request.user.has_perm('scolar.fonctionnalite_etudiants_justificationabsences'):
        messages.error(request, "Vous n'êtes pas autorisés à accéder à cette fonction.")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    # if this is a POST request we need to process the form data
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = AbsenceEtudiantSelectForm(request.POST)
        
        # check whether it's valid:
        if form.is_valid():
            try:
                form_data=form.cleaned_data
                etudiant_=form.data['etudiant']
                debut_periode=form_data['debut_periode']
                fin_periode=form_data['fin_periode']
                date_justification_=form_data['date_justification']
                motif_=form_data['motif']
                if debut_periode or fin_periode :
                    if debut_periode :
                        absences_a_charger=AbsenceEtudiant.objects.filter(etudiant=etudiant_, seance__activite__module__formation__annee_univ__encours=True, seance__date__gte=debut_periode, justif=False).order_by('-seance__date','seance__activite__module__matiere__code')
                    else :
                        absences_a_charger=AbsenceEtudiant.objects.filter(etudiant=etudiant_, seance__activite__module__formation__annee_univ__encours=True, justif=False).order_by('-seance__date','seance__activite__module__matiere__code')
                    if fin_periode :
                        absences_a_charger=absences_a_charger.filter(seance__date__lte=fin_periode)
                    
                    form = AbsenceEtudiantSelectForm(etudiant=form.cleaned_data['etudiant'], absences_a_charger=absences_a_charger, date_justification=date_justification_, motif=motif_)
                    messages.info(request, "Vous pouvez désormais justifier les absences de la période chargée (sans renseigner la période)") 
                    return render(request, 'scolar/import.html', {'form': form, 'titre':'Justifier des absences.'})
                absence_list_=form_data['absence_list']
                for absence_ in absence_list_:
                    absence_.justif=True
                    absence_.motif=motif_
                    absence_.date_justif=date_justification_
                    absence_.save()
                    
                        
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: lors de la justification des absences. Merci de le signaler à l'administrateur")

                    return render(request, 'scolar/import.html', {'form': form, 'titre':'Justifier des absences.'})
            messages.info(request, "La justification des absences a été effectuée avec succès.")         
            # redirect to a new URL:
            return HttpResponseRedirect(reverse('absence_list')) 
    # if a GET (or any other method) we'll create a blank form
    else:
        form = AbsenceEtudiantSelectForm()
        messages.info(request, "Merci de renseigner ce formulaire pour justifier une liste d'absences avec le même motif.")
        messages.info(request, "Pour justifier l'ensemble des absences d'une période, veuillez sélectionnez la date début et/ou la date fin. Le sélectionnement d'au moins l'un de ces deux champs a comme effet : Au clic sur le bouton 'Charger les absences / Justifier', les absences de la période sont chargées dans la liste des absences. Ne renseignez pas ces dates dans un second temps lorsque les absences sont déjà chargées, la justification ne peut se faire que si les deux dates sont vides.")
    return render(request, 'scolar/import.html', {'form': form, 'titre':'Justifier des Absences'})

    

@login_required
def export_notes(request, groupe_pk, module_pk):
    module=get_object_or_404(Module, id=module_pk)

    if not (request.user.has_perm('scolar.fonctionnalitenav_pedagogie_visualisationnotes') or request.user.has_acces_visualisation_notes_programme(module.formation.programme)):
        if request.user.is_enseignant() :
            if not assure_module(request.user.enseignant, module) :
                return redirect('/accounts/login/?next=%s' % request.path)
        else :
            return redirect('/accounts/login/?next=%s' % request.path)
            
    try:
        # Create the HttpResponse object with the appropriate CSV header.
        activation_rattrapage=module.activation_rattrapage()
        groupe=get_object_or_404(Groupe, id=groupe_pk)
        resultat_list=[]
        inscription_list_=Inscription.objects.filter(inscription_periodes__groupe=groupe, inscription_periodes__periodepgm__periode=module.periode.periode).order_by('etudiant__nom', 'etudiant__prenom')
        for inscrit_ in inscription_list_ :
            # le résultat d'un étudiant dans un module est déjà créé lors de son inscription à un groupe
            resultat_=Resultat.objects.get(inscription=inscrit_,module__matiere=module.matiere, ancien_resultat__isnull=True)
            resultat_list.append(resultat_)

        header=['Matricule','Nom','Prenom', 'Nb Absences', 'Situation', 'Acquis']
        if module.activation_rattrapage() :
            header.append('Entrée en rattrapage')
        evaluation_list=module.evaluations.all()
        for eval_ in evaluation_list: 
            header.append(eval_.type)
        if module.formation.archive or not evaluation_list.exists():
            header.append('Moy'+module.matiere.code)
            if activation_rattrapage :
                header.append('Moy_Rattrapage_'+module.matiere.code)
        sheet=Dataset()
        sheet.headers = header
    
        for resultat_ in resultat_list :
            row_=[]
            row_.append(resultat_.inscription.etudiant.matricule)
            row_.append(resultat_.inscription.etudiant.nom)
            row_.append(resultat_.inscription.etudiant.prenom)
            row_.append(resultat_.module.nb_absences(resultat_.inscription.etudiant))
            row_.append(dict(DECISIONS_JURY)[resultat_.inscription.decision_jury])
            row_.append('Oui' if resultat_.acquis else 'Non')
            if module.activation_rattrapage() :
                row_.append('Oui' if resultat_.entree_rattrapage else 'Non')
            for eval_ in evaluation_list :
                if not resultat_.acquis:
                    note_, created= Note.objects.get_or_create(resultat=resultat_, evaluation=eval_, defaults={'resultat':resultat_,'evaluation':eval_, 'note':0})
                    row_.append(note_.note)
                else:
                    note_qs= Note.objects.filter(resultat=resultat_, evaluation=eval_)
                    if note_qs.exists() :
                        note_=note_qs.first()
                        row_.append(note_.note)
                    else :
                        row_.append(0)
            if module.formation.archive or not evaluation_list.exists():
                row_.append(resultat_.moy)
                if activation_rattrapage :
                    row_.append(resultat_.moy_rattrapage)
            sheet.append(row_)
            
        filename=str(module.matiere.code)+'_'+str(groupe)+'.xlsx'
        filename=filename.replace(' ','_')

        response = HttpResponse(content_type='application/vnd.ms-excel')
        response['Content-Disposition'] = 'attachment; filename='+filename+";"
        response.write(sheet.xlsx)
    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            messages.error(request, "ERREUR: Il y a eu une erreur lors de l'export du fichier des notes. Merci de le signaler à l'administrateur.")
    return response
 
class ProgresFormationListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name='scolar/filter_list.html'
    
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalitenav_Export_exportationprogres')
    
    def get_queryset(self,**kwargs):
        return Formation.objects.all().order_by('-annee_univ__annee_univ','programme__ordre')
    
    def get_context_data(self, **kwargs):
        context = super(ProgresFormationListView, self).get_context_data(**kwargs)     
        filter_ = FormationFilter(self.request.GET, queryset=self.get_queryset(**kwargs))
        filter_.form.helper = FormHelper()
        exclude_=[]   
        exclude_.append('moyenne_passage')  
        table = ProgresFormationTable(filter_.qs, exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['filter'] = filter_
        context['table'] = table
        context['titre'] = 'Liste des formations et fichiers à télécharger par période'
        context['back'] = reverse('home')
        context['webhelp']=format_html(HELP_EXPORT_PROGRES)
        return context

def export_notes_progres_full(request,formation_pk, periode_pk):
    try :
        formation_=get_object_or_404(Formation, id=formation_pk)  
        periode_=get_object_or_404(PeriodeProgramme, id= periode_pk)  
        if not request.user.has_perm('scolar.fonctionnalitenav_Export_exportationprogres') :
            return redirect('/accounts/login/?next=%s' % request.path)          
        book=Databook()
        #Create then add ADMINISTRATION information sheet
        sheet=Dataset(title= "affectations")
        inscription_list=Inscription.objects.filter(formation=formation_).filter(Q(decision_jury = 'C')|Q(decision_jury = 'A')|Q(decision_jury = 'AR')|Q(decision_jury = 'SR')|Q(decision_jury = 'AD')|Q(decision_jury = 'AC')|Q(decision_jury = 'CR')).order_by('etudiant__nom', 'etudiant__prenom')
        header=['Numéro Inscription','Année Bac','Matricule','Nom', 'Prénom','Section','Groupe']
        sheet.headers = header
        for inscription_ in inscription_list :
            row_=[]
            if (inscription_.etudiant.user):
                institution = inscription_.etudiant.user.institution()
                numero_inscription = (institution.identifiant_progres+ inscription_.formation.annee_univ.annee_univ+inscription_.etudiant.matricule_progres) if (institution.identifiant_progres and inscription_.etudiant.matricule_progres) else ''
                row_.append(numero_inscription)
            else : 
                row_.append('')
                
            row_.append(inscription_.etudiant.annee_bac if inscription_.etudiant.annee_bac else '')
            row_.append(inscription_.etudiant.n_inscription_bac if inscription_.etudiant.n_inscription_bac else '')
            row_.append(inscription_.etudiant.nom)
            row_.append(inscription_.etudiant.prenom)
            row_.append(inscription_.groupe.section.code if (inscription_.groupe and inscription_.groupe.section and inscription_.groupe.section.code) else '')
            row_.append(inscription_.groupe.code if inscription_.groupe else '')
            sheet.append(row_)
        book.add_sheet(sheet)
        module_list_=Module.objects.filter(formation=formation_,periode = periode_ )
        for module in module_list_:       
            evaluation_list=Evaluation.objects.filter(module=module).distinct()
            sheet=Dataset(title= module.matiere.code)# nom module 
            header=[]
            header.append('Matricule')
            header.append('Nom')
            header.append('Prénom')
            for evaluation_ in evaluation_list :
                header.append(evaluation_.type)
            header.append('Note')
            header.append('Absent')
            header.append('Absence Justifiée')
            header.append('Observation')
            header.append('Section')
            header.append('Groupe')
            
            sheet.headers = header           
            resultat_list=Resultat.objects.filter(module=module, ancien_resultat__isnull=True).filter(Q(inscription__decision_jury = 'C')|Q(inscription__decision_jury = 'A')|Q(inscription__decision_jury = 'AR')|Q(inscription__decision_jury = 'SR')|Q(inscription__decision_jury = 'AD')|Q(inscription__decision_jury = 'AC')|Q(inscription__decision_jury = 'CR')).order_by('inscription__etudiant__nom', 'inscription__etudiant__prenom')    
            for resultat_ in resultat_list:
                row_=[]    
                row_.append(resultat_.inscription.etudiant.matricule_progres if resultat_.inscription.etudiant.matricule_progres else '')
                row_.append(resultat_.inscription.etudiant.nom )#+ '/' +resultat_.inscription.etudiant.nom_a)
                row_.append(resultat_.inscription.etudiant.prenom)#+ '/' +resultat_.inscription.etudiant.prenom_a)
                for evaluation_ in evaluation_list :
                    note_qs=Note.objects.filter(evaluation=evaluation_, resultat=resultat_)
                    if note_qs.exists() :
                        row_.append(note_qs.first().note)
                    else :
                        row_.append(' ')
                row_.append(resultat_.moy)
                row_.append(' ')
                row_.append('false')
                row_.append(' ')
                row_.append(resultat_.inscription.groupe.section.code)
                row_.append(resultat_.inscription.groupe.code)
                sheet.append(row_)
                
            book.add_sheet(sheet)
        filename='notes_examens_'+str(formation_.programme.code)+'.xlsx'

        response = HttpResponse(content_type='application/vnd.ms-excel')
        response['Content-Disposition'] = 'attachment; filename='+filename+";"
        response.write(book.export('xlsx'))
    
    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            messages.error(request, "ERREUR: Il y a eu une erreur lors de l'export du fichier d'export des notes selon le canevas progres. Merci de le signaler à l'administrateur.")
    return response
@login_required
def export_pfe_reservation_list(request):
    if not request.user.has_perm('scolar.fonctionnalitenav_stages_exportationstages') :
        messages.error(request, "ERREUR: Vous n'êtes pas autorisés à exécuter cette opération")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    try:
        # Create the HttpResponse object with the appropriate CSV header.
        # retourner la liste des PFE réservés
        pfe_list=PFE.objects.filter(Q(type='P')|Q(type='M'), groupe__isnull=True, reserve_pour__isnull=False).distinct()
        header=['Type', 'Groupe', 'ID', 'Matricule', 'Nom', 'Prenom', 'Specialite', 'Promoteur','EmailPromoteur','Coencadrants','EmailCoencadrants', 'Titre','Organisme', 'Adresse', 'Pays', ]
        sheet=Dataset()
        sheet.headers = header
    
        for pfe_ in pfe_list :
            row_=[]
            row_.append(dict(TYPE_STAGE)[pfe_.type])
            row_.append(pfe_.groupe.code if pfe_.groupe else '')
            row_.append(str(pfe_.id))
            matricule_=''
            nom_=''
            prenom_=''
            specialite_=''
            for inscription_ in pfe_.reserve_pour.all():
                matricule_+=inscription_.etudiant.matricule+'\n'
                nom_+=inscription_.etudiant.nom+'\n'
                prenom_+=inscription_.etudiant.prenom+'\n'
                specialite_+=inscription_.formation.programme.specialite.code+'\n'
            row_.append(matricule_)
            row_.append(nom_)
            row_.append(prenom_)
            row_.append(specialite_)
            row_.append(pfe_.promoteur)
            if pfe_.email_promoteur:
                row_.append(str(pfe_.email_promoteur))  
            else: 
                row_.append('')
            coencadrants_=''
            email_coencadrants_=''
            for enseignant_ in pfe_.coencadrants.all():
                coencadrants_+=str(enseignant_)+'\n'
                email_coencadrants_+=str(enseignant_.user.email)+'\n' if enseignant_.user else '\n'
            row_.append(coencadrants_)
            row_.append(email_coencadrants_)            
            row_.append(pfe_.intitule)
            row_.append(str(pfe_.organisme))
            row_.append(pfe_.organisme.adresse if pfe_.organisme else '')
            row_.append(pfe_.organisme.pays if pfe_.organisme else '')
            sheet.append(row_)
            
        filename='Liste_PFE_Réservés.xlsx'

        response = HttpResponse(content_type='application/vnd.ms-excel')
        response['Content-Disposition'] = 'attachment; filename='+filename+";"
        response.write(sheet.xlsx)
    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            messages.error(request, "ERREUR: Il y a eu une erreur lors de l'export du fichier des PFE validés")
            return HttpResponseRedirect(reverse('home'))            
    return response

@login_required
def export_pfe_list(request, annee_univ_pk):
    if not request.user.has_perm('scolar.fonctionnalitenav_stages_exportationstages') :
        messages.error(request, "ERREUR: Vous n'êtes pas autorisés à exécuter cette opération")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    try:
        # Create the HttpResponse object with the appropriate CSV header.
        # retourner la liste des PFE officiellement attribués pour un déroulement durant l'année universitaire indiquée
        annee_univ_=AnneeUniv.objects.get(annee_univ=annee_univ_pk)
        pfe_list=PFE.objects.filter(groupe__isnull=False, groupe__section__formation__annee_univ=annee_univ_pk).exclude(groupe__section__formation__programme__matiere_equipe__isnull=False).distinct()
        header=['Type', 'Groupe', 'ID', 'Matricule', 'Nom', 'Prenom','EmailEtudiant','Specialite','Promoteur','EmailPromoteur', 'Coencadrants', 'EmailCoencadrants', 'Titre','Organisme', 'Adresse', 'Pays', 'Note', 'Dépôt Mémoire']
        sheet=Dataset()
        sheet.headers = header
    
        for pfe_ in pfe_list :
            row_=[]
            row_.append(dict(TYPE_STAGE)[pfe_.type])
            row_.append(pfe_.groupe.code)
            row_.append(str(pfe_.id))
            matricule_=''
            nom_=''
            prenom_=''
            specialite_=''
            note_=''
            email_=''
            for inscription_ in pfe_.groupe.inscrits.all():
                matricule_+=inscription_.etudiant.matricule+'\n'
                nom_+=inscription_.etudiant.nom+'\n'
                prenom_+=inscription_.etudiant.prenom+'\n'
                email_+=inscription_.etudiant.get_email()+'\n'                
                specialite_+=inscription_.formation.programme.specialite.code+'\n'                
                resultat_=Resultat.objects.filter(inscription=inscription_, module__matiere__pfe=True, module__matiere=inscription_.formation.matiere_pfe(), ancien_resultat__isnull=True)
                if resultat_.exists() :
                    note_+=str(resultat_.first().moy)+'\n'
                else :
                    note_+='\n'
                
            row_.append(matricule_)
            row_.append(nom_)
            row_.append(prenom_)
            row_.append(email_)            
            row_.append(specialite_)            
            row_.append(pfe_.promoteur)
            if pfe_.email_promoteur:
                row_.append(str(pfe_.email_promoteur))  
            else: 
                row_.append('')
            coencadrants_=''
            email_coencadrants_=''
            for enseignant_ in pfe_.coencadrants.all():
                coencadrants_+=str(enseignant_)+'\n'
                email_coencadrants_+=str(enseignant_.user.email)+'\n' if enseignant_.user else '\n'
            row_.append(coencadrants_)
            row_.append(email_coencadrants_)
            
            row_.append(pfe_.intitule)
            row_.append(str(pfe_.organisme))
            row_.append(pfe_.organisme.adresse if pfe_.organisme else '')
            row_.append(pfe_.organisme.pays if pfe_.organisme else '')
            row_.append(note_)
            soutenance_qs=Soutenance.objects.filter(groupe__pfe=pfe_)
            if soutenance_qs.exists() :
                row_.append(dict(OPTIONS_DEPOT).get(soutenance_qs.first().depot_biblio))
            else :
                row_.append('')
            
            sheet.append(row_)
            
        filename='Liste_PFE_'+str(annee_univ_)+'.xlsx'
        filename=filename.replace(' ','_')

        response = HttpResponse(content_type='application/vnd.ms-excel')
        response['Content-Disposition'] = 'attachment; filename='+filename+";"
        response.write(sheet.xlsx)
    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            messages.error(request, "ERREUR: Il y a eu une erreur lors de l'export du fichier des PFE validés")
            return HttpResponseRedirect(reverse('home'))            
    return response

@login_required
def export_organisme_list(request):
    if not request.user.has_perm('scolar.fonctionnalitenav_stages_exportationpartenaires') :
        messages.error(request, "ERREUR: Vous n'êtes pas autorisés à exécuter cette opération")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    try:
        # Create the HttpResponse object with the appropriate CSV header.
        organisme_list=Organisme.objects.all()
        header=['Sigle', 'Nom', 'Adresse', 'Pays', 'Type', 'Nature', 'Statut', 'Taille','Secteur' ]
        sheet=Dataset()
        sheet.headers = header
    
        for organisme_ in organisme_list :
            row_=[]
            row_.append(organisme_.sigle)
            row_.append(organisme_.nom)
            row_.append(organisme_.adresse)
            row_.append(organisme_.pays)
            row_.append(dict(TYPE_ORGANISME)[organisme_.type] if organisme_.type else '')
            row_.append(dict(NATURE_ORGANISME)[organisme_.nature] if organisme_.nature else '')
            row_.append(dict(STATUT_ORGANISME)[organisme_.statut] if organisme_.statut else '')
            row_.append(organisme_.taille)
            row_.append(dict(SECTEUR_ORGANISME)[organisme_.secteur] if organisme_.secteur else '')
            sheet.append(row_)
            
        filename='Liste_Organismes_Partenaires.xlsx'

        response = HttpResponse(content_type='application/vnd.ms-excel')
        response['Content-Disposition'] = 'attachment; filename='+filename+";"
        response.write(sheet.xlsx)
    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            messages.error(request, "ERREUR: Il y a eu une erreur lors de l'export du fichier des Organismes Partenaires")
    return response

@login_required
def export_etudiant_pfe_list(request, formation_pk):
    formation_=get_object_or_404(Formation, id=formation_pk)
    if not (request.user.has_perm('scolar.fonctionnalitenav_stages_exportationstages') or request.user.has_acces_visualisation_notes_programme(formation_.programme)) :
        return redirect('/accounts/login/?next=%s' % request.path)
    
    try:
        # Create the HttpResponse object with the appropriate CSV header.
        inscription_list=Inscription.objects.filter(groupe__section__formation=formation_pk).order_by('etudiant__nom', 'etudiant__prenom')
        header=['Matricule','Nom', 'Prenom', 'Specialite', 'Situation', 'ID_PFE ','Promoteur','Coencadrants', 'Titre','Organisme', 'Pays', 'Validation', 'Note', 'Dépôt Mémoire', 'Président', 'Examinateur', 'Rapporteur', 'Assesseur 1', 'Assesseur 2']
        sheet=Dataset()
        sheet.headers = header
        
    
        for inscription_ in inscription_list :
            pfe_list=PFE.objects.filter(reserve_pour__etudiant=inscription_.etudiant, groupe__section__formation=formation_).order_by('id')
            if pfe_list.exists():
                for pfe_ in pfe_list:
                    resultat_=Resultat.objects.filter(inscription=inscription_, module__matiere__pfe=True, module__matiere=inscription_.formation.matiere_pfe(), ancien_resultat__isnull=True)
                    row_=[]
                    row_.append(inscription_.etudiant.matricule)
                    row_.append(inscription_.etudiant.nom)
                    row_.append(inscription_.etudiant.prenom)
                    row_.append(inscription_.formation.programme.specialite.code if inscription_.formation.programme.specialite else '')
                    row_.append(dict(DECISIONS_JURY)[inscription_.decision_jury])
                    row_.append(pfe_.id)
                    row_.append(pfe_.promoteur)
                    coencadrants=''
                    for coencadrant_ in pfe_.coencadrants.all():
                        coencadrants+=str(coencadrant_)+' + '
                    row_.append(coencadrants)
                    row_.append(pfe_.intitule)
                    if pfe_.organisme :
                        row_.append(pfe_.organisme.sigle)
                        row_.append(pfe_.organisme.pays.nom)
                    else :
                        row_.append('/')
                        row_.append('/')
                    row_.append(dict(STATUT_VALIDATION)[pfe_.statut_validation])
                    if resultat_.exists() :
                        row_.append(resultat_.first().moy)
                    else :
                        row_.append('/')
                    soutenance_qs=Soutenance.objects.filter(groupe__pfe=pfe_)
                    if soutenance_qs.exists() :
                        row_.append(dict(OPTIONS_DEPOT).get(soutenance_qs.first().depot_biblio))
                        row_.append(str(soutenance_qs.first().president) if soutenance_qs.first().president else '')
                        row_.append(str(soutenance_qs.first().examinateur) if soutenance_qs.first().examinateur else '')
                        row_.append(str(soutenance_qs.first().rapporteur) if soutenance_qs.first().rapporteur else '')
                        row_.append(str(soutenance_qs.first().assesseur1) if soutenance_qs.first().assesseur1 else '')
                        row_.append(str(soutenance_qs.first().assesseur2) if soutenance_qs.first().assesseur2 else '')                                                                                                
                    else :
                        row_.append('')
                        row_.append('')
                        row_.append('')
                        row_.append('')
                        row_.append('')
                        row_.append('')
                    sheet.append(row_)
                    
            else:
                row_=[]
                row_.append(inscription_.etudiant.matricule)
                row_.append(inscription_.etudiant.nom)
                row_.append(inscription_.etudiant.prenom)
                row_.append(inscription_.formation.programme.specialite.code if inscription_.formation.programme.specialite else '')
                row_.append(dict(DECISIONS_JURY)[inscription_.decision_jury])
                row_.append(0)
                row_.append('')
                row_.append('')
                row_.append('')
                row_.append('')
                row_.append('')
                row_.append('')
                row_.append('')
                row_.append('')
                row_.append('')
                row_.append('')
                row_.append('')
                row_.append('')
                row_.append('')                
                sheet.append(row_)
        filename='Liste_Etudiant_PFE_'+str(formation_)+'.xlsx'.replace(' ','_')

        response = HttpResponse(content_type='application/vnd.ms-excel')
        response['Content-Disposition'] = 'attachment; filename='+filename+";"
        response.write(sheet.xlsx)
    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            messages.error(request, "ERREUR: Il y a eu une erreur lors de l'export du fichier des Etudiant - PFE validés")
    return response

@login_required
def export_fiche_eval_pfe(request, groupe_pk, module_pk):
    try :
        groupe=get_object_or_404(Groupe, id=groupe_pk)
        module=get_object_or_404(Module, id=module_pk)
        if not ((request.user.has_perm('scolar.fonctionnalitenav_stages_visualisationsoutenances') and module.matiere.pfe) or ((request.user.is_coordinateur(module) or request.user.has_perm('scolar.fonctionnalitenav_stages_visualisationsoutenancesequipes'))and module.formation.programme.matiere_equipe==module.matiere)) :
            return redirect('/accounts/login/?next=%s' % request.path)   
        
        if not groupe.is_equipe() :
            resultat_list=Resultat.objects.filter(module=module_pk, resultat_ue__inscription_periode__groupe=groupe_pk, ancien_resultat__isnull=True).order_by('inscription__etudiant__nom', 'inscription__etudiant__prenom')
        else :
            resultat_list=Resultat.objects.filter(module__matiere=module.matiere, inscription__in=groupe.pfe.equipe.inscriptions.all(), ancien_resultat__isnull=True).order_by('inscription__etudiant__nom', 'inscription__etudiant__prenom')    
        # create the DataBook object that will comprise the different information and evaluation sheets 
        book=Databook()
        
        #Create then add ADMINISTRATION information sheet
        sheet=Dataset(title="ADMINISTRATION")
        sheet.append(["PARTIE RESERVEE A L'ADMINISTRATION"," "," "])
        sheet.append([" "," "," "])
        sheet.append(['PROMOTION:', str(module.formation.annee_univ.annee_univ)+'/'+str(module.formation.annee_univ.annee_suivante())," "])
        sheet.append(['CODE '+module.matiere.code+': ', groupe.code," "])
        sheet.append([" "," "," "])
        sheet.append(['Noms et Prénoms des Candidats', 'Matricule', 'Option'])
        for resultat_ in resultat_list:
            sheet.append([resultat_.inscription.etudiant.nom+' '+resultat_.inscription.etudiant.prenom, resultat_.inscription.etudiant.matricule, resultat_.inscription.formation.programme.specialite.intitule +' -- '+ resultat_.inscription.formation.programme.specialite.code])
        sheet.append([" "," "," "])
        sheet.append(['Intitulé du mémoire: ', " "," "])
        sheet.append([groupe.pfe.intitule," "," "])
        sheet.append([" "," "," "])
        if groupe.soutenance.date :
            sheet.append(['Date de soutenance: ', groupe.soutenance.date.strftime("%d/%m/%Y")," "])
        else :
            sheet.append(['Date de soutenance: ', 'Aucune date' ," "])
        sheet.append([" "," "," "])
        sheet.append(['COMPOSITION DU JURY'," "," "])
        if groupe.soutenance.president:
            sheet.append(['Président', str(groupe.soutenance.president)," "])
        if groupe.soutenance.examinateur:
            sheet.append(['Examinateur', str(groupe.soutenance.examinateur)," "])
        if groupe.soutenance.rapporteur:
            sheet.append(['Rapporteur', str(groupe.soutenance.rapporteur)," "])
        if groupe.soutenance.coencadrant:
            sheet.append(['Coencadrant', str(groupe.soutenance.coencadrant)," "])
        if groupe.soutenance.assesseur1:
            sheet.append(['Assesseur 1', str(groupe.soutenance.assesseur1)," "])
        if groupe.soutenance.assesseur2:
            sheet.append(['Assesseur 2', str(groupe.soutenance.assesseur2)," "])
            
        book.add_sheet(sheet)
        
        # add evaluations to the book
        for eval_ in module.evaluations.all() :
            try :
                competence_eval_config_=get_object_or_404(CompetenceEvalConfig, evaluation=eval_)
            except Http404 :
                competence_eval_config_choices={'0.0000' : 'Choisir', str(round(decimal.Decimal(dict(NOTES_PAR_DEFAUT).get('A')/20),4)): 'A: Très bien', str(round(decimal.Decimal(dict(NOTES_PAR_DEFAUT).get('B')/20),4)):'B: Bien', str(round(decimal.Decimal(dict(NOTES_PAR_DEFAUT).get('C')/20),4)): 'C: Assez bien', str(round(decimal.Decimal(dict(NOTES_PAR_DEFAUT).get('D')/20), 4)): 'D: Passable', str(round(decimal.Decimal(dict(NOTES_PAR_DEFAUT).get('E')/20),4)): 'E: Médiocre', str(round(decimal.Decimal(dict(NOTES_PAR_DEFAUT).get('F')/20),4)) : 'F: Mauvais'}
            else :
                competence_eval_config_choices={'0.0000' : 'Choisir', str(round(competence_eval_config_.A/20,4)): 'A: Très bien', str(round(competence_eval_config_.B/20,4)):'B: Bien', str(round(competence_eval_config_.C/20,4)) :'C: Assez bien', str(round(competence_eval_config_.D/20,4)): 'D: Passable', str(round(competence_eval_config_.E/20,4)): 'E: Médiocre', str(round(competence_eval_config_.F/20,4)) : 'F: Mauvais'}    
    
            sheet=Dataset(title=eval_.type)
            sheet.append(['FICHE DE NOTATION DE '+module.matiere.code+', VOLET: '+ eval_.type, " "," "])
            for resultat_ in resultat_list:
                sheet.append([" "," "," "])
                sheet.append(["EVALUATION DE: "+ str(resultat_.inscription.etudiant)," "," "])
                sheet.append([" "," "," "])
                sheet.append(['Elément de Compétence', 'Commun', 'Appréciation'])
                note_, created=Note.objects.get_or_create(resultat=resultat_, evaluation=eval_, defaults = {
                    'resultat':resultat_,
                    'evaluation':eval_,
                    'note':0
                    })
                
                for competence_ in eval_.competence_elements.all().order_by('commune_au_groupe','competence_element__code'):
                    note_competence_element, created= NoteCompetenceElement.objects.get_or_create(evaluation_competence_element=competence_, note_globale=note_, defaults={
                            'evaluation_competence_element':competence_, 
                            'note_globale':note_,
                            'valeur':0,
                        })
                    sheet.append([competence_.competence_element.intitule, 
                                  'OUI' if competence_.commune_au_groupe else 'NON', 
                                  competence_eval_config_choices.get(str(round(decimal.Decimal(note_competence_element.valeur),4)))
                                  ])
            book.add_sheet(sheet)
            
        filename='FICHE_EVALUATION_'+str(groupe.code)+'.xlsx'

        response = HttpResponse(content_type='application/vnd.ms-excel')
        response['Content-Disposition'] = 'attachment; filename='+filename+";"
        response.write(book.export('xlsx'))
    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            messages.error(request, "ERREUR: Il y a eu une erreur lors de l'export du fichier d'évaluation du PFE. Merci de le signaler à l'administrateur.")
    return response



@login_required
def notes_clear_view(request, inscription_periode_pk):
    inscription_periode_=get_object_or_404(InscriptionPeriode, id=inscription_periode_pk)
    if request.user.has_perm('scolar.fonctionnalite_etudiants_reinitialisationnotesetacquis') and not inscription_periode_.inscription.formation.archive :
            pass
    else:
        messages.error(request, "Vous n'êtes pas autorisé à exécuter cette opération ou la formation est archivée.")
        return HttpResponseRedirect(reverse('releve_notes', kwargs={'inscription_pk': inscription_periode_.inscription.id}))
    try:
        Note.objects.filter(resultat__resultat_ue__inscription_periode=inscription_periode_pk).delete()
        Resultat.objects.filter(resultat_ue__inscription_periode=inscription_periode_pk).update(
                moy=0,
                moy_rattrapage=0,
                moy_post_delib=0,
                ects='F',
                acquis=False
            )
        InscriptionPeriode.objects.filter(id=inscription_periode_pk).update(
                moy=0,
                rang=0,
                ne=inscription_periode_.nb_matieres()
            )
        inscription_periode_.inscription.reset_moy()
        Inscription.objects.filter(id=inscription_periode_.inscription.id).update(
                moy=inscription_periode_.inscription.moyenne(),
                rang=inscription_periode_.inscription.ranking()
            )
        trace_create(request.user, inscription_periode_.inscription.etudiant, "Réinitialisation Période "+str(inscription_periode_))
        # redirect to a new URL:
        messages.success(request,"La période a été bien ré-initialisée")
        return HttpResponseRedirect(reverse('releve_notes', kwargs={'inscription_pk': inscription_periode_.inscription.id})) 

    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            messages.error(request,"ERREUR: lors de la ré-initialisation de la période")
            return HttpResponseRedirect(reverse('releve_notes', kwargs={'inscription_pk': inscription_periode_.inscription.id}))


@login_required
def notes_clear_confirmation(request, inscription_periode_pk):
    
    context={}
    context['info']="La réinitialisation la période de cette inscription entrainera la remise à zéro des notes."
    context['lien']=reverse('notes_clear', kwargs={'inscription_periode_pk': inscription_periode_pk}) 
    return render(request, 'scolar/confirmation.html', context)

    

@login_required
def acquis_clear_view(request, resultat_pk):
    
    resultat_=get_object_or_404(Resultat, id=resultat_pk)
    if request.user.has_perm('scolar.fonctionnalite_etudiants_reinitialisationnotesetacquis') and not resultat_.inscription.formation.archive:
            pass
    else:
        messages.error(request, "Vous n'êtes pas autorisé à exécuter cette opération ou la formation est archivée.")
        return HttpResponseRedirect(reverse('releve_notes', kwargs={'inscription_pk': resultat_.inscription.id}))

    try:
        Note.objects.filter(resultat=resultat_pk).delete()
        ancienne_moy=resultat_.moyenne_finale()
        Resultat.objects.filter(id=resultat_pk).update(
                moy=0,
                moy_rattrapage=0,
                entree_rattrapage=False,
                dette=False,
                moy_post_delib=0,
                ects='F',
                acquis=False
            )
        trace_create(request.user, resultat_.inscription.etudiant, "Réinitialisation Moy Module "+str(resultat_.module)+" de "+str(resultat_.inscription) + " de "+str(ancienne_moy)+" à 0")
        # redirect to a new URL:
        messages.success(request,"La note a été bien ré-initialisée")
        return HttpResponseRedirect(reverse('releve_notes', kwargs={'inscription_pk': resultat_.inscription.id})) 

    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            messages.error(request,"ERREUR: lors de la ré-initialisation de la note. veuillez la signaler à l'administrateur.")
            return HttpResponseRedirect(reverse('releve_notes', kwargs={'inscription_pk': resultat_.inscription.id}))

@login_required
def acquis_clear_confirmation(request, resultat_pk):
    
    context={}
    context['info']="La réinitialisation de la note de ce module entraînera sa remise à 0."
    context['lien']=reverse('acquis_clear', kwargs={'resultat_pk': resultat_pk}) 
    return render(request, 'scolar/confirmation.html', context)

def moyenne_clear_view(request, inscription_pk):
    
    inscription_=get_object_or_404(Inscription, id=inscription_pk)
    if request.user.has_perm('scolar.fonctionnalite_etudiants_reinitialisationnotesetacquis') and not inscription_.formation.archive:
            pass
    else:
        messages.error(request, "Vous n'êtes pas autorisé à exécuter cette opération ou la formation est archivée.")
        return HttpResponseRedirect(reverse('releve_notes', kwargs={'inscription_pk': inscription_pk}))   
    try:
        ancienne_moy=inscription_.moy
        ancienne_moy_ra=inscription_.moy_ra
        Inscription.objects.filter(id=inscription_pk).update(
                moy=0,
                moy_ra=0,
            )        
        #trace_create(request.user, inscription_.inscription.etudiant, "Réinitialisation Moy Module "+str(resultat_.module)+" de "+str(resultat_.inscription) + " de "+str(ancienne_moy)+" à 0")
        trace_create(request.user, inscription_.etudiant, "Réinitialisation de la moyenne annuelle de "+str(inscription_)+" : "+str(ancienne_moy)+" vers 0")
        if inscription_.moy_ra :
            trace_create(request.user, inscription_.etudiant, "Réinitialisation de la moyenne annuelle de rachat de "+str(inscription_)+" : "+str(ancienne_moy_ra)+" vers 0")
        # redirect to a new URL:
        messages.success(request,"La moyenne a été bien ré-initialisée")
        return HttpResponseRedirect(reverse('releve_notes', kwargs={'inscription_pk': inscription_pk})) 

    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            messages.error(request,"ERREUR: lors de la ré-initialisation de la moyenne. veuillez la signaler à l'administrateur.")
            return HttpResponseRedirect(reverse('releve_notes', kwargs={'inscription_pk': inscription_.inscription.id}))
def moyenne_clear_confirmation(request, inscription_pk):
    
    context={}
    context['info']="La réinitialisation de la moyenne de cette inscription entraînera sa remise à 0."    
    context['lien']=reverse('moyenne_clear', kwargs={'inscription_pk': inscription_pk}) 
    return render(request, 'scolar/confirmation.html', context)    

@login_required
def modules_acquis_view(request, inscription_pk):
    
    inscription_=get_object_or_404(Inscription, id=inscription_pk)
    if request.user.has_perm('scolar.fonctionnalite_etudiants_reinitialisationnotesetacquis') and not inscription_.formation.archive :
            pass
    else:
        messages.error(request, "Vous n'êtes pas autorisé à exécuter cette opération ou la formation est archivée.")
        return HttpResponseRedirect(reverse('releve_notes', kwargs={'inscription_pk': inscription_pk}))
    
    try:
        #parcourir tous les semestres de l'inscription en cours
        for semestre_ in InscriptionPeriode.objects.filter(inscription=inscription_pk, inscription__etudiant=inscription_.etudiant):
            #si semestre acquis alors copier l'ancien dans le nouveau
            sem_=InscriptionPeriode.objects.filter(inscription__etudiant=semestre_.inscription.etudiant, periodepgm=semestre_.periodepgm)\
                                               .filter(moy__gte=10.0).filter(ne=0)
            
            if sem_.exists():
                sem_=sem_[0]
                semestre_.acquis=True
                semestre_.save(update_fields=['acquis'])
            
                #parcourir tous les resultats de l'inscription en cours
                for resultat_ in Resultat.objects.filter(inscription=inscription_pk, ancien_resultat__isnull=True):
                    old_resultat_=Resultat.objects.filter(ancien_resultat__isnull=True, inscription__etudiant=resultat_.inscription.etudiant, 
                                                  module__matiere__code=resultat_.module.matiere.code, resultat_ue__inscription_periode__periodepgm=semestre_.periodepgm,
                                                  inscription__formation__annee_univ__annee_univ__lt=resultat_.inscription.formation.annee_univ.annee_univ)\
                                                  .order_by('-inscription__formation__annee_univ__annee_univ')
                    if old_resultat_.exists():
                        old_resultat_=old_resultat_[0]
                        ancienne_moy=resultat_.moy
                        ancienne_moy_post_delib=resultat_.moy_post_delib
                        ancienne_moy_rattrapage=resultat_.moy_rattrapage
                        resultat_.moy=old_resultat_.moy
                        resultat_.moy_rattrapage=old_resultat_.moy_rattrapage
                        resultat_.entree_rattrapage=old_resultat_.entree_rattrapage
                        resultat_.moy_post_delib=old_resultat_.moy_post_delib
                        resultat_.ects=old_resultat_.ects
                        resultat_.acquis=True
                        resultat_.save(update_fields=['moy','moy_rattrapage', 'entree_rattrapage', 'moy_post_delib', 'ects', 'acquis'])
                
                        action="Insertion Module Acquis "+str(resultat_.module)+" de "+str(resultat_.inscription) + " : Moy de "+str(ancienne_moy)+" à "+str(resultat_.moy)+". Moy Post Delib de "+str(ancienne_moy_post_delib)+" à "+str(resultat_.moy_post_delib) +". "
                        if resultat_.activation_rattrapage() :
                             action+="Moy Rattrapage de "+str(ancienne_moy_rattrapage)+" à "+str(resultat_.moy_rattrapage) +". "
                        trace_create(request.user, resultat_.inscription.etudiant, action)
     
            else: 
                 #parcourir tous les résultats de l'inscription en cours
                 for resultat_ in Resultat.objects.filter(inscription=inscription_pk, ancien_resultat__isnull=True):
                 # Si module acquis alors copier l'ancien dans le nouveau
                     old_resultat_=Resultat.objects.filter(ancien_resultat__isnull=True, inscription__etudiant=resultat_.inscription.etudiant, 
                                                   module__matiere__code=resultat_.module.matiere.code, 
                                                   inscription__formation__annee_univ__annee_univ__lt=resultat_.inscription.formation.annee_univ.annee_univ)\
                                                   .filter(Q(moy__gte=10.0)|Q(moy_rattrapage__gte=10.0)|Q(moy_post_delib__gte=10.0)).order_by('-inscription__formation__annee_univ__annee_univ')
                     if old_resultat_.exists():
                         old_resultat_=old_resultat_[0]
                         ancienne_moy=resultat_.moy
                         ancienne_moy_post_delib=resultat_.moy_post_delib
                         ancienne_moy_rattrapage=resultat_.moy_rattrapage
                         resultat_.moy=old_resultat_.moy
                         resultat_.moy_rattrapage=old_resultat_.moy_rattrapage
                         resultat_.entree_rattrapage=old_resultat_.entree_rattrapage
                         resultat_.moy_post_delib=old_resultat_.moy_post_delib
                         resultat_.ects=old_resultat_.ects
                         resultat_.acquis=True
                         resultat_.save(update_fields=['moy','moy_rattrapage', 'entree_rattrapage', 'moy_post_delib', 'ects', 'acquis'])
                    
                         action="Insertion Module Acquis "+str(resultat_.module)+" de "+str(resultat_.inscription) + " : Moy de "+str(ancienne_moy)+" à "+str(resultat_.moy)+". Moy Post Delib de "+str(ancienne_moy_post_delib)+" à "+str(resultat_.moy_post_delib) +". "
                         if resultat_.activation_rattrapage() :
                            action+="Moy Rattrapage de "+str(ancienne_moy_rattrapage)+" à "+str(resultat_.moy_rattrapage) +". "
                         trace_create(request.user, resultat_.inscription.etudiant, action)
        
     
        messages.success(request,"Le semestre  /  les modules acquis ont bien été insérés dans cette inscription")
        return HttpResponseRedirect(reverse('releve_notes', kwargs={'inscription_pk': inscription_pk})) 

    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            messages.error(request,"ERREUR: lors de l'insertion des modules acquis. Veuillez la signaler à l'administrateur.")
            return HttpResponseRedirect(reverse('releve_notes', kwargs={'inscription_pk': inscription_pk}))
    
@login_required
def modules_acquis_confirmation(request, inscription_pk):
    
    context={}
    context['info']="L'insertion des modules ou bien semestre acquis, en cas de redoublement par exemple, permet d'affecter les résultats acquis de l'étudiant de l'inscription passée à l'inscription en cours pour le même programme."
    context['lien']=reverse('modules_acquis', kwargs={'inscription_pk': inscription_pk}) 
    return render(request, 'scolar/confirmation.html', context)


@login_required
def note_update(request, matiere_pk, groupe_pk):
    # Il faudra refaire le traitement des données du formuliare pour n'enregistrer
    # que les données ayant changé et pas toutes (form.changed_data) pour éviter des
    # problèmes de performance
    
    module_=get_object_or_404(ModulesSuivis, groupe=groupe_pk, module__matiere=matiere_pk).module
    groupe_=get_object_or_404(Groupe, id = groupe_pk)
    liste_inscrits=Inscription.objects.filter(inscription_periodes__groupe=groupe_.id, inscription_periodes__periodepgm=module_.periode).order_by('etudiant__nom', 'etudiant__prenom')
    liste_evaluations=Evaluation.objects.filter(module=module_.id)
    resultat_list={}
    for inscrit_ in liste_inscrits :
        resultat_=Resultat.objects.get(ancien_resultat__isnull=True, inscription=inscrit_,module__matiere=module_.matiere)
        resultat_list[inscrit_.etudiant.matricule]=resultat_
    groupe_section=groupe_.section.groupes.all().filter(code__isnull=True).get()
    
    #Si la formation est archivée ou si un PV est déjà établit alors ne pas autoriser la modification
    if request.user.has_perm('scolar.fonctionnalite_pedagogie_modificationnotes') or request.user.has_acces_gestion_notes_programme(module_.formation.programme):
            pass
    elif module_.formation.archive or module_.pv_existe():
        messages.error(request, "Il n'est plus possible de modifier les notes car un PV a été établit ou la saisie est clôturée.")
        return HttpResponseRedirect(reverse('note_list', kwargs={'groupe_pk': groupe_pk, 'matiere_pk': matiere_pk}))
    elif request.user.is_enseignant():
        if not (assure_module_groupe(request.user.enseignant, module_, groupe_) or assure_module_groupe(request.user.enseignant, module_, groupe_section)):
            messages.error(request, "Vous n'êtes pas autorisé à effectuer cette opération")
            return redirect('/accounts/login/?next=%s' % request.path)
    else:
        messages.error(request,"Vous n'avez pas les permissions d'accès à cette page.")
        return redirect('/accounts/login/?next=%s' % request.path)
    # Cette condition permet de tester si on doit utiliser le SMS pour envoie de code secret à usage unique
    sms_=settings.SMS_ENABLED and not (request.user.has_perm('scolar.fonctionnalite_pedagogie_modificationnotes') or request.user.has_acces_gestion_notes_programme(module_.formation.programme))
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = NotesUpdateForm(sms_, groupe_pk , module_.id, request, request.POST)
        # check whether it's valid:
        if form.is_valid():
            if module_.formation.archive:
                messages.error(request, "La saisie des notes est clôturée pour cette formation.")
            else:
                if sms_:
                    otp_=form.cleaned_data['otp']
                else:
                    otp_="-1"
                #Vérifier que l'OTP est correct
                if not sms_ or request.user.enseignant.check_otp(otp_):
                    # submit as background task
                    t = threading.Thread(target=task_note_update,args=[form, module_, groupe_, request.user])
                    t.setDaemon(True)
                    t.start()
                    messages.info(request, "Votre demande d'enregistrement des notes a été prise en compte. Une notification vous sera transmise.")
                else:
                    messages.error(request, "Le Code Secret saisi est incorrect.")
            # redirect to a new URL:
            return HttpResponseRedirect(reverse('note_list', kwargs={'groupe_pk': groupe_pk, 'matiere_pk': matiere_pk})) 
    # if a GET (or any other method) we'll create a blank form
    else:
        if sms_ and not request.user.enseignant.tel:
            messages.error(request, "Votre numéro de téléphone n'est pas enregsitré dans la base. Il est nécessaire pour vous envoyer un Mot de passe à Usage Unique.")
            messages.info(request, "Merci de communiquer votre numéro à l'administration afin que vous puissiez saisir les notes.")
            return HttpResponseRedirect(reverse('note_list', kwargs={'groupe_pk': groupe_pk, 'matiere_pk': module_.matiere.id}))
        else:
            
            form = NotesUpdateForm(sms_, groupe_pk, module_.id, request)
            messages.info(request, "Merci de renseigner les notes dans le formulaire")
            messages.warning(request, "Si vous ne retrouvez pas les colonnes correspondantes aux évaluations prévues, merci de demander au coordinateur(trice) d'introduire la formule de calcul.")
            return render(request, 'scolar/note_update.html', {'form': form, 'liste_inscrits':liste_inscrits,'liste_evaluations':liste_evaluations,'module_':module_,'groupe_':groupe_,
                                                               'sms':sms_,
                                                               'url':settings.SMS_URL,
                                                               'function':'sms_send',
                                                               'apikey':settings.SMS_API_KEY,
                                                               'userkey':settings.SMS_USER_KEY,
                                                               'message':'Talents Code Secret: '+request.user.enseignant.set_otp() if request.user.is_enseignant() else None,
                                                               'message_priority':'Urgent', 
                                                               'to':request.user.enseignant.tel if request.user.is_enseignant() else None,
                                                               'decisions_jury' : dict(DECISIONS_JURY),
                                                               'resultat_list' : resultat_list,
                                                               })


@transaction.atomic
def task_note_update(form, module_, groupe_, user):
    try:
        # if this is a POST request we need to process the form data
        liste_inscrits=Inscription.objects.filter(inscription_periodes__groupe=groupe_.id, inscription_periodes__periodepgm=module_.periode).order_by('etudiant__nom', 'etudiant__prenom')
        #liste_inscrits=Inscription.objects.filter(groupe=groupe_.id).order_by('etudiant__nom', 'etudiant__prenom')
        liste_evaluations=Evaluation.objects.filter(module=module_.id)
        module_suivi_=get_object_or_404(ModulesSuivis, groupe=groupe_, module=module_)
        activation_rattrapage=module_.activation_rattrapage()
        
        # process the data in form.cleaned_data as required
        data=form.cleaned_data
        for inscrit_ in liste_inscrits:
                resultat_=get_object_or_404(Resultat, inscription=inscrit_, module = module_.id)
                if not resultat_.acquis and not inscrit_.is_admis():
                    if liste_evaluations.exists():
                            
                        if activation_rattrapage and user.has_perm('scolar.fonctionnalite_pedagogie_modificationnotes'):
                            key_=str(inscrit_.etudiant.matricule)+'_entree_rattrapage'
                            if resultat_.entree_rattrapage != data[key_] :
                                resultat_.entree_rattrapage=data[key_]
                                resultat_.save(update_fields=['entree_rattrapage'])  
                                if data[key_] :
                                    trace_create(user, inscrit_.etudiant, "Modification de l'entrée rattrapage de "+str(resultat_.module)+" de Non vers Oui")
                                else :
                                    trace_create(user, inscrit_.etudiant, "Modification de l'entrée rattrapage de "+str(resultat_.module)+" de Oui vers Non")
                                
                        ancienne_moy=resultat_.moy
                        ancienne_moy_rattrapage=resultat_.moy_rattrapage
                        for eval_ in liste_evaluations :
                            key_=str(inscrit_.etudiant.matricule)+'_'+str(eval_.id)
                            ancienne_note_qs=Note.objects.filter(resultat=resultat_, evaluation=eval_)
                            if ancienne_note_qs.exists() :
                                ancienne_note=ancienne_note_qs.first().note
                            else :
                                ancienne_note=0
                            
                            with transaction.atomic() :
                                note_, created=Note.objects.update_or_create(resultat=resultat_, evaluation=eval_, defaults={
                                        'resultat':resultat_,
                                        'evaluation':eval_,
                                        'note':data[key_]
                                    })
                                if ancienne_note != note_.note :
                                    trace_create(user, inscrit_.etudiant, "Modification de la note de "+str(eval_)+" de "+str(ancienne_note)+" vers "+str(note_.note))
    
                        # Pour que ce soit possible de renseigner la moyenne et la moyenne rattrapage depuis le formulaire sans pour autant renseigner les notes des évaluations :
                        key_=str(inscrit_.etudiant.matricule)+'_moy'
                        moy=data[key_]
                        resultat_moyenne=resultat_.moyenne()
                        if moy != resultat_moyenne :
                            resultat_.moy=moy
                            resultat_.save(update_fields=['moy'])
                            if ancienne_moy != resultat_.moy :
                                trace_create(user, inscrit_.etudiant, "Modification de la moyenne de "+str(resultat_.module)+" de "+str(ancienne_moy)+" vers "+str(resultat_.moy)) 
                        else :
                            moy = resultat_moyenne  
                        if activation_rattrapage :
                            key_=str(inscrit_.etudiant.matricule)+'_moy_rattrapage'
                            moy_rattrapage=data[key_]
                            resultat_moyenne_rattrapage=resultat_.moyenne_rattrapage()
                            if moy_rattrapage != resultat_moyenne_rattrapage :
                                resultat_.moy_rattrapage=moy_rattrapage
                                resultat_.save(update_fields=['moy_rattrapage'])
                                if ancienne_moy_rattrapage != resultat_.moy_rattrapage :
                                    trace_create(user, inscrit_.etudiant, "Modification de la moyenne de rattrapage de "+str(resultat_.module)+" de "+str(ancienne_moy_rattrapage)+" vers "+str(resultat_.moy_rattrapage))
                            else :
                                moy_rattrapage=resultat_moyenne_rattrapage
                            if resultat_.entree_rattrapage==True:
                                if resultat_.module.activation_max_moy_normale_et_rattrapage :
                                    resultat_.moy_post_delib=max(moy_rattrapage, moy)
                                else :
                                    resultat_.moy_post_delib=resultat_.module.ponderation_moy_rattrapage*moy_rattrapage + resultat_.module.ponderation_moy*resultat_.moy
                                resultat_.save(update_fields=['moy_post_delib']) 
                        else :
                            resultat_.moy_post_delib=moy
                            resultat_.save(update_fields=['moy_post_delib'])  
                            #if not moy_rattrapage :
                            #    resultat_.moy_post_delib=resultat_.moy
                            #    resultat_.save(update_fields=['moy_post_delib'])                                                                
                        
                    else:
                        # ce cas se pose quand on n'a que la moyenne générale du module
                        key_=str(inscrit_.etudiant.matricule)+'_moy'
                        ancienne_moy=resultat_.moy
                        with transaction.atomic() :
                            resultat_.moy=data[key_]
                            resultat_.save(update_fields=['moy'])
                            if ancienne_moy != resultat_.moy :
                                trace_create(user, inscrit_.etudiant, "Modification de la moyenne de "+str(resultat_.module)+" de "+str(ancienne_moy)+" vers "+str(resultat_.moy))    
                        if activation_rattrapage :
                            key_=str(inscrit_.etudiant.matricule)+'_moy_rattrapage'
                            ancienne_moy_rattrapage=resultat_.moy_rattrapage
                            with transaction.atomic() :
                                resultat_.moy_rattrapage=data[key_]
                                resultat_.save(update_fields=['moy_rattrapage'])
                                if ancienne_moy_rattrapage != resultat_.moy_rattrapage :
                                    trace_create(user, inscrit_.etudiant, "Modification de la moyenne de rattrapage de "+str(resultat_.module)+" de "+str(ancienne_moy_rattrapage)+" vers "+str(resultat_.moy_rattrapage))
                                
                        if not activation_rattrapage :
                            resultat_.moy_post_delib=resultat_.moy
                        else :
                            if resultat_.module.activation_max_moy_normale_et_rattrapage :
                                resultat_.moy_post_delib=max(resultat_.moy_rattrapage, resultat_.moy)
                            else :
                                resultat_.moy_post_delib=resultat_.module.ponderation_moy_rattrapage*resultat_.moy_rattrapage + resultat_.module.ponderation_moy*resultat_.moy
                        resultat_.save(update_fields=['moy_post_delib'])  
                    
                    
                if user.has_perm('scolar.fonctionnalite_etudiants_reinitialisationnotesetacquis'):
                    key_=str(inscrit_.etudiant.matricule)+'_acquis'
                    if resultat_.acquis != data[key_] :
                        resultat_.acquis=data[key_]
                        resultat_.save(update_fields=['acquis'])
                        if data[key_] :
                            trace_create(user, inscrit_.etudiant, "Modification de l'état de "+str(resultat_.module)+" de Non Acquis vers Acquis")
                        else :
                            trace_create(user, inscrit_.etudiant, "Modification de l'état de "+str(resultat_.module)+" de Acquis vers Non Acquis")
                    
                        
        etat_saisie_=data[str(groupe_.id)+'_'+str(module_.id)]
        if etat_saisie_==True:
            module_suivi_.saisie_notes='T'
        else:
            module_suivi_.saisie_notes='C'
        module_suivi_.save()
    except Exception:
        trace_create(user, user, 'Une erreur s\'est produite lors de l\'enregistrement des notes de '+str(module_)+' du groupe '+str(groupe_))
        if settings.DEBUG:
            raise Exception
        else:
            if activation_emails():
                email = EmailMessage('[Talents] Erreur lors de l\'enregistrement des notes de'+str(module_)+' du groupe '+str(groupe_),
                                     'Bonjour,\n'+ 
                                     'Une erreur s\'est produite lors de l\'enregistrement des notes de '+str(module_)+' du groupe '+str(groupe_)+'\n'+
                                     'Demande de modification effectuée via le compte '+user.email+'\n'+
                                     'Veuillez réessayer la saisie et l\'enregistrement \n'+
                                     'Bien cordialement.\n'+
                                     signature_emails(), to=[user.get_email(), module_.formation.programme.get_email_responsable_autorite_cycle()] )
                email.send(fail_silently=True)
    else:
        trace_create(user, user, 'L\'enregistrement des notes de '+str(module_.matiere.code)+' du groupe '+str(groupe_)+' a bien été effectué')
        if activation_emails():
            email = EmailMessage('[Talents] Confirmation de l\'enregistrement des notes de '+str(module_.matiere.code)+' du groupe '+str(groupe_),
                                 'Bonjour,\n'+ 
                                 'L\'enregistrement des notes de '+str(module_.matiere.code)+' du groupe '+str(groupe_)+' a bien été effectué \n'+
                                 'Modification effectuée via le compte '+user.email+'\n'+
                                 'Nous vous en remercions \n'+
                                 'Bien cordialement.\n'+
                                 signature_emails(), to=[user.get_email(), module_.formation.programme.get_email_responsable_autorite_cycle() ] )
            email.send(fail_silently=True)



@login_required
def organisme_select_for_pfe_create(request):
    
    if not (request.user.has_perm('scolar.fonctionnalitenav_stages_soumission') or request.user.is_enseignant() or request.user.is_partenaire() or request.user.is_etudiant()):
        messages.error(request,"Vous n'avez pas les permissions pour executer cette opération.")
        return redirect('/accounts/login/?next=%s' % request.path)
   
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = SelectOrCreateOrganismeForm(request.POST)
        # check whether it's valid:
        if form.is_valid():
            data=form.cleaned_data
            
            # redirect to a new URL:
            return HttpResponseRedirect(reverse('pfe_create', kwargs={'organisme_pk': data['organisme'].sigle})) 
        else:
            return render(request, 'scolar/import.html', {'form': form, 'titre':"Sélectionner ou créer un organisme"})
    # if a GET (or any other method) we'll create a blank form
    else:
        form = SelectOrCreateOrganismeForm()
        
        messages.info(request, "Merci de sélectionner un organisme d'accueil")
        messages.info(request, "Si l'organisme recherché n'existe pas, merci de le créer.")
        return render(request, 'scolar/import.html', {'form': form, 'titre':"Sélectionner ou créer un organisme"})

@login_required
def organisme_create_for_pfe_create(request):
    
    if not (request.user.has_perm('scolar.fonctionnalitenav_stages_soumission') or request.user.is_enseignant() or request.user.is_partenaire() or request.user.is_etudiant()):
        messages.error(request,"Vous n'avez pas les permissions pour executer cette opération.")
        return redirect('/accounts/login/?next=%s' % request.path)
     
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = OrganismeForm(request.POST)
        # check whether it's valid:
        if form.is_valid():
            organisme=form.save()
            # redirect to a new URL:
            return HttpResponseRedirect(reverse('pfe_create', kwargs={'organisme_pk': organisme.sigle})) 
        else:
            return render(request, 'scolar/import.html', {'form': form, 'titre':"Créer un organisme"})
    # if a GET (or any other method) we'll create a blank form
    else:
        form = OrganismeForm()
        messages.info(request, "Merci d'utiliser ce formulaire pour créer un nouvel organisme d'accueil")
        return render(request, 'scolar/import.html', {'form': form, 'titre':"Créer un organisme"})

@login_required
def partenaire_create_view(request):
    
    if not request.user.has_perm('scolar.fonctionnalite_stages_gestionpartenaires'):
        messages.error(request,"Vous n'avez pas les permissions pour executer cette opération.")
        return redirect('/accounts/login/?next=%s' % request.path)
     
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = PartenaireCreateForm(request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:
                data = form.cleaned_data
                group = Group.objects.get(name='partenaire')
                psw=User.objects.make_random_password()
                user=User.objects.create_user(username=data['email'], 
                                              email=data['email'], 
                                              password=psw,
                                              first_name=data['prenom'],
                                              last_name=data['nom'])
                user.groups.add(group)
                user.save()
                
                trace_create(request.user, user, "Création de l'utilisateur (partenaire) : "+ data['email'])
                if activation_emails():
                    institution_=get_institution()
                    nom_institution=""
                    if institution_.sigle :
                        nom_institution = nom_institution + institution_.sigle
                        if institution_.wilaya_institution :
                            nom_institution = nom_institution + "-"+institution_.wilaya_institution.nom
                    else :
                        nom_institution = nom_institution + institution_.nom
                        if institution_.wilaya_institution :
                            nom_institution = nom_institution + " - "+institution_.wilaya_institution.nom
                    email = EmailMessage("[Talents] Création de votre compte dans la plateforme pédagogique de "+nom_institution,
                                         'Bonjour,\n'+
                                         "Un compte vous a été créé dans la plateforme Talents pour vous permettre la soumission de sujets de fin d'études à : "+ nom_institution+"\n"+
                                         "Pour vous connecter: \n"+
                                         "- Merci de visiter cette page: "+
                                         settings.PROTOCOLE_HOST+reverse('login')+'\n'+
                                         "- Nom d'utilisateur : votre adresse mail.\n"+
                                         "- Mot de passe: "+psw+'\n'+
                                         "Vous pouvez modifier votre mot de passe en vous connectant ou en cliquant sur Mot de passe oublié."+
                                         'Cordialement', to=[data['email']], cc=email_stage()+email_offres() )
                    email.send(fail_silently=True)
            except Exception:
                if settings.DEBUG:
                    raise Exception('Création de partenaire')
                else:
                    messages.error("ERREUR: lors de la création d'un partenaire. vérifiez qu'il n'existe pas dans la base.")
                    HttpResponseRedirect(reverse('organisme_list'))
            messages.success(request, "Le partenaire a été créé avec succès. Les informations de connexion lui ont été transmises par email.")
            # redirect to a new URL:
            return HttpResponseRedirect(reverse('organisme_list')) 
        else:
            return render(request, 'scolar/import.html', {'form': form, 'titre':"Créer un organisme"})
    # if a GET (or any other method) we'll create a blank form
    else:
        form = PartenaireCreateForm()
        messages.info(request, "Merci d'utiliser ce formulaire pour créer un nouveau partenaire")
        return render(request, 'scolar/import.html', {'form': form, 'titre':"Créer un partenaire"})

class OrganismeCreateView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, CreateView):
    model = Organisme
    fields = ['sigle', 'nom', 'adresse', 'pays', 'type', 'statut', 'nature', 'secteur', 'taille', 'interne']
    template_name = 'scolar/create.html'
    success_message = "L'organisme a été créé avec succès!"

    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalite_stages_gestionpartenaires')
        
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.fields['pays']=forms.ModelChoiceField(queryset=Pays.objects.all().order_by('nom'), initial='DZ', required=True)
        form.helper.add_input(Submit('submit','Ajouter', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('organisme_list')
        return form
    
    def get_context_data(self, **kwargs):
        context = super(OrganismeCreateView, self).get_context_data(**kwargs)
        titre='Créer un nouvel organisme partenaire'        
        context['titre'] = titre
        return context

class OrganismeUpdateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, UpdateView):
    permission_required = 'scolar.fonctionnalite_stages_gestionpartenaires'
    model = Organisme
    fields = ['sigle', 'nom', 'adresse', 'pays', 'type', 'statut', 'nature', 'secteur', 'taille', 'interne']
    template_name = 'scolar/update.html'
    success_message = "L'organisme a été modifié avec succès!"
        
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.fields['sigle'].widget.attrs['readonly']=True
        form.fields['sigle'].required=False
        form.fields['pays']=forms.ModelChoiceField(queryset=Pays.objects.all().order_by('nom'), initial='DZ', required=True)
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-warning'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('organisme_list')
        return form

class OrganismeDeleteView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, DeleteView):
    model = Organisme
    template_name = 'scolar/delete.html'
    permission_required='scolar.fonctionnalite_stages_gestionpartenaires'
    success_message = "L'organisme a bien été supprimé"

    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression de l'organisme : "+str(object_))
        return super(OrganismeDeleteView, self).delete(*args, **kwargs)
        
    def get_success_url(self):
        return reverse('organisme_list')

class OrganismeListView(LoginRequiredMixin, PermissionRequiredMixin, TemplateView):
    template_name = 'scolar/filter_list.html'
    permission_required='scolar.fonctionnalitenav_stages_visualisationpartenaires'
 
    def get_context_data(self, **kwargs):
        context = super(OrganismeListView, self).get_context_data(**kwargs)

        filter_ = OrganismeFilter(self.request.GET, queryset=Organisme.objects.all().order_by('sigle'))
        
        filter_.form.helper = FormHelper()
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalite_stages_gestionpartenaires'):
            exclude_.append('edit')
            exclude_.append('admin')
        table = OrganismeTable(filter_.qs, exclude=exclude_)
        RequestConfig(self.request).configure(table)
            
        context['filter'] = filter_
        context['table'] = table
        context['titre'] = "Liste des organismes partenaires / organismes d'accueil en stages / ..."
        if self.request.user.has_perm('scolar.fonctionnalite_stages_gestionpartenaires'):
            context['btn_list']={
                    'Créer Organisme':reverse('organisme_create'),
                    'Importer Organismes': reverse('organismes_import'),
                    'Créer Partenaire': reverse('partenaire_create'),
                }
        return context



class PFECreateView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, CreateView):
    model = PFE
    fields = [ 'type', 'intitule', 'specialites', 'organisme', 'promoteur', 'email_promoteur', 'tel_promoteur', 'coencadrants', 'reserve_pour', 'resume',  'keywords', 'bibliographie', 'objectifs', 'resultats_attendus', 'antecedents', 'echeancier', 'moyens_informatiques', 'projet_recherche' ]
    template_name = 'scolar/create.html'
    success_message = "La proposition de PFE a bien été enregistrée. Elle sera soumise à un processus de validation."
    
    def test_func(self):
        if self.request.user.has_perm('scolar.fonctionnalitenav_stages_soumission') or self.request.user.is_enseignant() or self.request.user.is_partenaire() :
            return True
        elif self.request.user.is_etudiant():
            if self.request.user.etudiant.eligible_pfe():
                if self.request.user.etudiant.nb_depots_stages()>=1:
                    messages.error(self.request, "Vous avez atteint le nombre maximum de réservations de sujets de stage. Il faut supprimer une réservation avant d'en faire une autre.")
                    return False
                else:
                    return True
            else:
                return False
        else: 
            return False
                
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        #form.fields['type'].help_text="PFE ou Master. Merci de soumettre deux sujets différents pour le PFE et Master."
        form.fields['type']=forms.ChoiceField(choices=set(TYPE_STAGE) ^ set((('D', 'Doctorat'),)), initial='P', required=True) 
        form.fields['intitule'].widget = forms.Textarea(attrs={'rows':1})
        form.fields['promoteur'].help_text="Si le promoteur est enseignant à l'établissement, merci de le rajouter aux encadrants aussi."
        form.fields['promoteur'].widget = forms.Textarea(attrs={'rows':1})
        form.fields['email_promoteur'].initial=self.request.user.email
        if self.request.user.is_partenaire_only() :
            form.fields['email_promoteur'].disabled=True
        form.fields['keywords'].widget = forms.Textarea(attrs={'rows':1})
        form.fields['keywords'].required=True
        form.fields['keywords'].help_text="Merci de renseigner au plus 5 mots clés séparés par une virgule."
            
        form.fields['antecedents'].help_text="Renseignez les antécédents de ce stage en termes de travaux, produits, phases réaslisées, etc."
        form.fields['echeancier'].help_text="Mettre les différentes étapes en indiquant la durée en nombre de mois pour chacune. La durée totale doit être entre 9 et 12 mois pour un PFE."
        form.fields['organisme']=forms.ModelChoiceField(
                queryset=Organisme.objects.all(),
                initial=self.kwargs.get("organisme_pk"),
                disabled=True,
                required=True,
            )
        form.fields['specialites'].queryset=Specialite.objects.filter(concernee_par_pfe=True)
        form.fields['specialites'].help_text="Maintenez la touche CTRL enfoncée pour sélectionner plusieurs spécialités."

        form.fields['coencadrants']=forms.ModelMultipleChoiceField(
            label = "Encadrants (enseignants de l'établissement)",
            queryset = Enseignant.objects.all().order_by('nom'),
            initial= self.request.user.enseignant if self.request.user.is_enseignant() else None,
            widget=ModelSelect2MultipleWidget(
                model=Enseignant,
                search_fields=['nom__icontains','prenom__icontains'],
            ),
            required=False,
            help_text = "Sélection multiple possible. Tapez le nom ou prénom de l'enseignant ou deux espaces pour avoir la liste complète.",

        )
        
        
        form.fields['reserve_pour']=forms.ModelMultipleChoiceField(
            # construire la liste des stagiaires potentiels n'ayant pas encore réservé un PFE
            queryset = Inscription.objects.filter(formation__programme__ordre__gte=4, formation__annee_univ__encours=True).annotate(nb_reservations=Count('reservations_pfe')).order_by('etudiant__nom', 'etudiant__prenom').exclude(nb_reservations__gte=1),
            widget=ModelSelect2MultipleWidget(
                model=Inscription,
                search_fields=['etudiant__nom__icontains','etudiant__prenom__icontains'],
            ),
            required=False,
            help_text = "Sélection multiple possible. Tapez le nom ou prénom de l'étudiant",

        )

        form.helper.add_input(Submit('submit','Ajouter', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        if self.request.user.has_perm('scolar.fonctionnalitenav_stages_validation'):
            self.success_url = reverse('service_pfe_list')  
        elif self.request.user.is_enseignant():
            self.success_url = reverse('enseignant_pfe_list')
        elif self.request.user.is_etudiant():
            self.success_url = reverse('etudiant_pfe_list')
        elif self.request.user.is_partenaire():
            self.success_url = reverse('partenaire_pfe_list')
        else:
            self.success_url = reverse('home')
        return form
    
    def get_context_data(self, **kwargs):
        context = super(PFECreateView, self).get_context_data(**kwargs)
        titre='Proposer un nouveau PFE'        
        context['titre'] = titre
        return context
    
    def form_valid(self, form):
        self.object = form.save()
        pfe_=self.object
        try :
            for user_ in users_stage_institution() :
                trace_create(self.request.user, user_, "[Notification] Dépôt d'un nouveau sujet de PFE.\n"+
                                                        "Sujet : "+str(pfe_)+"\n"+
                                                        "Déposant : "+str(self.request.user)+" - "+self.request.user.nom()+" "+self.request.user.prenom()+"\n"+
                                                        "Statut initial : "+dict(STATUT_VALIDATION)[pfe_.statut_validation]+"\n"+
                                                        "Lien de visualisation : "+settings.PROTOCOLE_HOST+reverse('pfe_detail', kwargs={'pk':pfe_.id})+"\n"+
                                                        "Lien de modification : "+settings.PROTOCOLE_HOST+reverse('pfe_update', kwargs={'pk':pfe_.id}))
        except Exception :
            pass
        return HttpResponseRedirect(self.get_success_url())

@receiver(post_save, sender=PFE)
def notifier_pfe(sender, update_fields, instance, created, **kwargs):
        
    if instance.groupe:
        if instance.groupe.section.formation.programme.matiere_equipe :
            return False
    
    if created:
        
        if instance.statut_validation=='C' :
            if instance.type=='D' :
                if activation_emails():
                    email = EmailMessage("[Talents] Proposition d'un nouveau sujet de thèse",
                                         'Bonjour,\n'+
                                         "Un nouveau sujet de thèse non visible (en état de contrôle) a été soumis : "+instance.intitule+"\n"+
                                         "Vous pouvez lancer son processus de validation via votre compte ou en suivant ce lien: \n\n"+
                                         settings.PROTOCOLE_HOST+reverse('these_update', kwargs={'these_pk':instance.id})+'\n\n'+
                                         'Cordialement', to=email_theses() )
                    email.send(fail_silently=True)
                return True
        
            else:
                if activation_emails():
                    email = EmailMessage("[Talents] Proposition d'un nouveau sujet de stage",
                                         'Bonjour,\n'+
                                         "Un nouveau sujet de stage a été soumis\n"+
                                         "Vous pouvez lancer son processus de validation, via votre compte ou en suivant ce lien: \n\n"+
                                         settings.PROTOCOLE_HOST+reverse('pfe_update', kwargs={'pk':instance.id})+'\n\n'+
                                         'Cordialement', to=email_stage() )
                    email.send(fail_silently=True)
            
                #email au promoteur
                    email = EmailMessage("[Talents] Proposition d'un nouveau sujet de stage N° "+str(instance.id),
                                         'Bonjour,\n'+
                                         "Un nouveau sujet de stage a été soumis\n\n"+
                                         
                                         instance.intitule+"\n\n"+
                                         
                                         "Il sera soumis à un processus de validation. Nous vous tiendrons informés de son statut de validation aussitôt terminée.\n"+
                                         'Cordialement', to=[instance.email_promoteur] )
                    email.send(fail_silently=True)

    elif instance.notification:
        if not (instance.type=='D') :
            if instance.statut_validation == 'S':
                if activation_emails():
                #email aux candidats potentiels
                    email = EmailMessage("[Talents] Proposition d'un nouveau sujet de stage N° "+str(instance.id),
                                         'Bonjour,\n'+
                                         "Un nouveau sujet de stage a été soumis\n\n"+
                                         instance.intitule+"\n\n"+
                                         "Vous pouvez consulter la description détaillée ici:\n\n"+
                                         settings.PROTOCOLE_HOST+reverse('pfe_detail', kwargs={'pk':instance.id})+"\n"+
                                         "Liste complète des sujets proposés:\n\n"+
                                         settings.PROTOCOLE_HOST+reverse('pfe_list')+"\n"+
                                         "Si un sujet vous intéresse, merci de contacter le promoteur\n"+
                                         'Cordialement', to=email_futurs_stagiaires() )
                    
                    email.send(fail_silently=True)
                
            elif instance.statut_validation=="RR":
                if activation_emails():
                    email = EmailMessage("[Talents] Votre sujet de stage N° "+str(instance.id)+" (Révision Requise)",
                                         'Bonjour,\n'+
                                         "Nous avons reçu les avis des collègues sur votre proposition de stage N° "+str(instance.id)+"\n"+
                                         "Intitulé: "+instance.intitule+"\n\n"+
                                         "Pourriez-vous apporter les améliorations nécessaires. Merci de renseigner le champs Réponse aux experts pour indiquer ce qui a été modifié.\n"+
                                         "N'oubliez pas de basculer le statut de validation du sujet vers 'Révision Terminée' après la modification\n"+
                                         "Vous pouvez modifier votre sujet en vous connectant à votre compte Talents ou via ce lien:\n\n"+
                                         settings.PROTOCOLE_HOST+reverse('pfe_update', kwargs={'pk':instance.id})+'\n\n'+  
                                         'Cordialement', to=email_stage()+[instance.email_promoteur]+[coencadrant_.get_email() for coencadrant_ in instance.coencadrants.all()]+
                                                            [inscription_.etudiant.get_email() for inscription_ in instance.reserve_pour.all()])
                    email.send(fail_silently=True)
    
    #             email = EmailMessage("[Talents] Votre sujet de stage N° "+str(instance.id)+" (Révision Requise)",
    #                                  'Bonjour,\n'+
    #                                  "Nous avons reçus les avis des collègues sur votre proposition de stage N° "+str(instance.id)+"\n"+
    #                                  "Intitulé: "+instance.intitule+"\n\n"+
    #                                  "Vous pouvez visualiser le retour de la commission, dans le volet Validation, ici:\n\n"+
    #                                  settings.PROTOCOLE_HOST+reverse('pfe_detail', kwargs={'pk':instance.id})+'\n\n'+
    #                                  "Merci d'indiquer aux co-encadrants de l'école ou à défaut à votre futur stagiaire, les modifications à apporter pour répondre aux recommendations de la commission.\n"+
    #                                  'Cordialement', to= [instance.email_promoteur] )
    #             if activation_emails():
    #                 email.send(fail_silently=True)

            elif instance.statut_validation=="V":
                # Supprimer les validations non renseignées
                if activation_emails():
                    email = EmailMessage("[Talents] Votre avis sur le sujet de stage N° "+str(instance.id),
                                         'Bonjour,\n'+
                                         "Nous avons reçu suffisemment d'avis sur la proposition de stage N° "+str(instance.id)+"\n\n"+
                                         "Intitulé: "+instance.intitule+"\n\n"+
                                         "Nous vous informons que votre avis n'est plus requis et le sujet a été validé\n"+
                                         "Nous vous remercions, et espérons vous solliciter pour d'autres avis.\n"+
                                         'Cordialement', to=email_stage()+[validation_.expert.get_email() for validation_ in instance.validations.filter(avis='X')])
                    email.send(fail_silently=True)
                instance.validations.filter(avis='X').delete()
                
                if activation_emails():
                    email = EmailMessage("[Talents] Votre sujet de stage N° "+str(instance.id)+" (Validé)",
                                         'Bonjour,\n'+
                                         "Nous avons reçu les avis des collègues sur votre proposition de stage N° "+str(instance.id)+"\n\n"+
                                         "Intitulé: "+instance.intitule+"\n\n"+
                                         "Nous vous informons que votre sujet est maintenant validé\n"+
                                         'Cordialement', to=email_stage()+[coencadrant_.get_email() for coencadrant_ in instance.coencadrants.all()] +
                                                            [inscription_.etudiant.get_email() for inscription_ in instance.reserve_pour.all()] + [instance.email_promoteur])
                    email.send(fail_silently=True)
    
                # marquer notification False pour qu'il y ait plus d'envoie de notification après de nouvelles mises à jours
                instance.notification=False
                instance.save()
    
            elif instance.statut_validation=="RT":
                if activation_emails():
                    email = EmailMessage("[Talents] Sujet de stage N° "+str(instance.id)+" (Révision Terminée)",
                                         'Bonjour,\n'+
                                         "La révision du sujet de stage N° "+str(instance.id)+" est terminée\n\n"+
                                         "Intitulé: "+instance.intitule+"\n\n"+
                                         "Vous pouvez procéder à son évaluation en vous connectant à votre compte ou via ce lien:\n\n"+
                                         settings.PROTOCOLE_HOST+reverse('pfe_update', kwargs={'pk':instance.id})+'\n\n'+
                                         'Cordialement', to=email_stage())
                    email.send(fail_silently=True)
                
                    email = EmailMessage("[Talents] Sujet de stage N° "+str(instance.id)+" (Révision Terminée)",
                                         'Bonjour,\n'+
                                         "Nous vous remercions d'avoir révisé le sujet de stage N° "+str(instance.id)+" \n\n"+
                                         "Intitulé: "+instance.intitule+"\n\n"+
                                         "Nous vous tiendrons informés de son statut de validation aussitôt terminée.\n"+
                                         'Cordialement', to=[coencadrant_.get_email() for coencadrant_ in instance.coencadrants.all()]+
                                                        [inscription_.etudiant.get_email() for inscription_ in instance.reserve_pour.all()]+
                                                        [instance.email_promoteur])
                    email.send(fail_silently=True)
            elif instance.statut_validation=="LR":
                #identifier les experts qui ont déjà introduit leur avis favorable après révision
                experts_avec_avis_favorable=instance.validations.filter(avis='V').values_list('expert')
                #identifier les validations avec réserve pour leur demander de lever la réserve
                validations_avec_reserve=instance.validations.filter(Q(avis="SR")|Q(avis="MR")).exclude(expert__in=experts_avec_avis_favorable)
                for validation_ in validations_avec_reserve:
                    nouvelle_validation_, created=Validation.objects.get_or_create(pfe=instance.id, expert=validation_.expert, avis="X", defaults={
                            'pfe':instance,
                            'expert': validation_.expert,
                            'avis':'X',
                            'debut': datetime.date.today()
                        })
                    if activation_emails():
                        email = EmailMessage("[Talents] Levée de reserve sur le sujet de stage N° "+str(instance.id),
                                         'Bonjour,\n'+
                                         "Vous aviez émis une reserve sur la proposition de stage N° "+str(instance.id)+"\n\n"+
                                         "Intitulée: "+instance.intitule+"\n\n"+
                                         "Une version révisée a été soumise.\n"+
                                         "Nous vous invitons à réexaminer cette nouvelle version et réintroduire votre avis via votre compte Talents ou en suivant ce lien:\n\n"+
                                         settings.PROTOCOLE_HOST+reverse("validation_update", kwargs={'pk':nouvelle_validation_.id, 'pfe_pk':instance.id })+'\n\n'+
                                         'Cordialement', to=[nouvelle_validation_.expert.get_email()])
                        email.send(fail_silently=True)
            
@receiver(m2m_changed, sender=PFE.coencadrants.through)
def notifier_coencadrants(sender, instance, action, pk_set, **kwargs):
    if activation_emails() and action=="post_add" and not instance.groupe:
        coencadrant_list=[]
        for enseignant_id_ in pk_set:
            enseignant_=get_object_or_404(Enseignant, id=enseignant_id_)
            coencadrant_list.append(enseignant_)
        email = EmailMessage("[Talents] Proposition d'un nouveau sujet de stage N° "+str(instance.id),
                             'Bonjour,\n'+
                             "Un nouveau sujet de stage a été soumis\n\n"+
                             
                             instance.intitule+"\n\n"+
                             
                             "Il sera soumis à un processus de validation. Nous vous tiendrons informés de son statut de validation aussitôt terminée.\n"+
                             'Cordialement', to=[coencadrant_.get_email() for coencadrant_ in coencadrant_list])
        email.send(fail_silently=True)
        
@receiver(m2m_changed, sender=PFE.reserve_pour.through)
def notifier_reserve_pour(sender, instance, action, pk_set, **kwargs):
    if activation_emails() and action=="post_add" and not instance.groupe:
        reserve_pour_list=[]
        for inscription_id_ in pk_set:
            inscription_=get_object_or_404(Inscription, id=inscription_id_)
            reserve_pour_list.append(inscription_)
        email = EmailMessage("[Talents] Proposition d'un nouveau sujet de stage N° "+str(instance.id),
                             'Bonjour,\n'+
                             "Un nouveau sujet de stage a été soumis\n\n"+
                             
                             instance.intitule+"\n\n"+
                             
                             "Il sera soumis à un processus de validation. Nous vous tiendrons informés de son statut de validation aussitôt terminée.\n"+
                             'Cordialement', to=[inscription_.etudiant.get_email() for inscription_ in reserve_pour_list])
        email.send(fail_silently=True)
               

class PFEUpdateView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, UpdateView):
    model = PFE
    fields = [ 'statut_validation', 'type', 'intitule', 'specialites', 'organisme', 'promoteur', 'email_promoteur', 'tel_promoteur', 'coencadrants', 'reserve_pour',  'resume',   'keywords', 'bibliographie', 'objectifs', 'resultats_attendus', 'antecedents', 'echeancier', 'moyens_informatiques', 'projet_recherche', 'reponse_aux_experts']
    template_name = 'scolar/pfe_update.html'
    success_message = "Le sujet a bien été modifié."

    def test_func(self):
        if not (self.request.user.has_perm('scolar.fonctionnalitenav_stages_validation') or self.request.user.is_enseignant() or self.request.user.is_partenaire() or self.request.user.is_etudiant())  :
            return False
        else: 
            pfe_=get_object_or_404(PFE, Q(groupe__section__formation__programme__matiere_equipe__isnull=True), id=self.kwargs.get("pk"))
            if self.request.user.has_perm('scolar.fonctionnalitenav_stages_validation') :
                return True
            elif self.request.user.is_enseignant():
                if self.request.user.enseignant in pfe_.coencadrants.all() :
                    if ((pfe_.statut_validation in ['C', 'S', 'RR', 'N', 'V', 'W'])) :
                        return True
                    else :
                        messages.error(self.request, "Il n'est plus possible de modifier ce sujet")
                        return False
                        
                else:
                    messages.error(self.request, "Vous ne pouvez pas modifier ce sujet car vous ne figurez pas parmi les co-encadrants")
                    return False
            elif self.request.user.is_etudiant():
                allow=False
                etudiant_list=[]
                for inscription_ in pfe_.reserve_pour.all():
                    etudiant_list.append(inscription_.etudiant.matricule)
                if self.request.user.etudiant.matricule in etudiant_list and pfe_.statut_validation in ['C', 'S', 'RR', 'N']:
                    allow=True
                return allow 
            elif self.request.user.is_partenaire() and self.request.user.email and pfe_.email_promoteur :
                if (self.request.user.email.upper() == pfe_.email_promoteur.upper()) and (pfe_.statut_validation in ['C', 'S', 'RR', 'N', 'V', 'W']):
                    return True
                return False 
            else:
                return False
        
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        pfe_=get_object_or_404(PFE, id=self.kwargs.get("pk"))
        form.fields['type']=forms.ChoiceField(choices=set(TYPE_STAGE) ^ set((('D', 'Doctorat'),)), initial=pfe_.type, required=True) 
        form.fields['intitule'].widget = forms.Textarea(attrs={'rows':1})
        form.fields['promoteur'].help_text="Si le promoteur est enseignant à l'établissement, merci de le rajouter aux encadrants aussi."
        form.fields['promoteur'].widget = forms.Textarea(attrs={'rows':1})
        if self.request.user.is_partenaire_only() :
            form.fields['email_promoteur'].disabled=True
        form.fields['specialites'].queryset=Specialite.objects.filter(concernee_par_pfe=True)
        form.fields['specialites'].help_text="Maintenez la touche CTRL enfoncée pour sélectionner plusieurs spécialités."

        form.fields['coencadrants']=forms.ModelMultipleChoiceField(
            label = "Encadrants (enseignants de l'établissement)",
            queryset = Enseignant.objects.all().order_by('nom'),
            initial= pfe_.coencadrants.all(),
            widget=ModelSelect2MultipleWidget(
                model=Enseignant,
                search_fields=['nom__icontains','prenom__icontains'],
            ),
            required=False,
            help_text = "Sélection multiple possible. Tapez le nom ou prénom de l'enseignant ou deux espaces pour avoir la liste complète.",

        )
        # Construire liste des inscrits éligibles à la réservation
        reserve_pour_list = [inscription_.id for inscription_ in pfe_.reserve_pour.all()]
        inscrits_sans_reservation_list = [inscription_.id for inscription_ in Inscription.objects.filter(
                                                        formation__programme__ordre__gte=4, 
                                                        formation__annee_univ__encours=True
                                                        ).annotate(
                                                            nb_reservations=Count('reservations_pfe')
                                                        ).order_by(
                                                            'etudiant__nom', 'etudiant__prenom'
                                                        ).exclude(nb_reservations__gte=1)]
        inscrits_candidats_list = reserve_pour_list + inscrits_sans_reservation_list
        form.fields['reserve_pour']=forms.ModelMultipleChoiceField(
            # construire la liste des inscrits n'ayant pas encore réservé un PFE
            queryset = Inscription.objects.filter(id__in=inscrits_candidats_list).order_by('etudiant__nom', 'etudiant__prenom'),
            initial = pfe_.reserve_pour.all(),
            widget=ModelSelect2MultipleWidget(
                model=Inscription,
                search_fields=['etudiant__nom__icontains','etudiant__prenom__icontains'],
            ),
            required=False,
            help_text = "Sélection multiple possible. Tapez le nom ou prénom de l'étudiant",
            
        )
        form.fields['objectifs'].required=False
        form.fields['keywords'].widget = forms.Textarea(attrs={'rows':1})        
        form.fields['keywords'].required=True
        form.fields['keywords'].help_text="Merci de renseigner au plus 5 mots clés séparés par une virgule."
        form.fields['resultats_attendus'].required=False
        form.fields['echeancier'].required=False

        if not self.request.user.has_perm('scolar.fonctionnalitenav_stages_validation'):
            form.fields['statut_validation'].disabled=True
            if (not self.request.user.is_enseignant()) and (not self.request.user.is_partenaire()) :
                form.fields['reserve_pour'].disabled=True
        
        if self.request.user.has_perm('scolar.fonctionnalitenav_stages_validation'):
            form.fields['statut_validation']=forms.ChoiceField(disabled=False, choices=STATUT_VALIDATION, initial=pfe_.statut_validation)
            form.fields['reponse_aux_experts'].disabled=True
        elif pfe_.statut_validation=="RR":
            form.fields['statut_validation']=forms.ChoiceField(disabled=False, choices=(('RT','Révision Terminée'),('RR','Révision Requise')), initial=pfe_.statut_validation)
            form.fields['statut_validation'].help_text="Sélectionnez Révision Terminée pour signaler la fin de la révision."
            form.fields['reponse_aux_experts'].disabled=False
            form.fields['reponse_aux_experts'].help_text="Utiliser ce champs pour répondre aux experts et indiquer précisemment les modifications apportées"
        elif pfe_.statut_validation=='V' or pfe_.statut_validation=='W' :
            for key_ in form.fields.keys():
                form.fields[key_].disabled=True
            form.fields['reserve_pour'].disabled=False

            
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-warning'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        if self.request.user.has_perm('scolar.fonctionnalitenav_stages_validation'):
            self.success_url = reverse('service_pfe_list')
            form.helper.add_input(Button('modifier','Retour à la liste', css_class='btn-info', onclick="window.location.href='"+reverse('service_pfe_list')+"'"))          
        elif self.request.user.is_enseignant():
            self.success_url = reverse('enseignant_pfe_list')
            form.helper.add_input(Button('modifier','Retour à la liste', css_class='btn-info', onclick="window.location.href='"+reverse('enseignant_pfe_list')+"'"))
        elif self.request.user.is_etudiant():
            self.success_url = reverse('etudiant_pfe_list')
            form.helper.add_input(Button('modifier','Retour à la liste', css_class='btn-info', onclick="window.location.href='"+reverse('etudiant_pfe_list')+"'"))
        elif self.request.user.is_partenaire():
            self.success_url = reverse('partenaire_pfe_list')
            form.helper.add_input(Button('modifier','Retour à la liste', css_class='btn-info', onclick="window.location.href='"+reverse('partenaire_pfe_list')+"'"))
        else:
            self.success_url = reverse('home')
        return form

    def get_context_data(self, **kwargs):
        context = super(PFEUpdateView, self).get_context_data(**kwargs)
        titre="Gérer la soumission d'un sujet de stage"        
        context['titre'] = titre
        exclude_columns_=[]
        if (not self.request.user.has_perm('scolar.fonctionnalitenav_stages_validation')):
            exclude_columns_.append('expert')
            exclude_columns_.append('edit')
            exclude_columns_.append('admin')
        if self.request.user.is_etudiant():
            exclude_columns_.append('action')
        if self.request.user.is_partenaire():
            exclude_columns_.append('action')

        table = ValidationTable(Validation.objects.filter(pfe=self.kwargs.get("pk")), exclude=exclude_columns_)
        RequestConfig(self.request).configure(table)
        context['pfe_validation_table'] = table
        
        return context

    def form_valid(self, form):
        pfe_=self.object
        response = super().form_valid(form)
        try :
            for user_ in users_stage_institution() :
                trace_create(self.request.user, user_, "[Notification] Modification d'une fiche de PFE.\n"+
                                                        "Sujet : "+str(pfe_)+"\n"+
                                                        "Modification par : "+str(self.request.user)+" - "+self.request.user.nom()+" "+self.request.user.prenom()+"\n"+
                                                        "Statut actuel : "+dict(STATUT_VALIDATION)[pfe_.statut_validation]+"\n"+
                                                        "Avis actuels :"+" Favorable : "+str(pfe_.nb_avis_favorables())+" | Réserves mineures : "+str(pfe_.nb_avis_favorables_avec_reserves_mineures())+" | Réserves majeures : "+str(pfe_.nb_avis_favorables_avec_reserves_majeures())+" | Défavorable : "+str(pfe_.nb_avis_defavorables())+" | Non renseigné : "+str(pfe_.nb_avis_non_renseignes())+"\n"+
                                                        "Lien de visualisation : "+settings.PROTOCOLE_HOST+reverse('pfe_detail', kwargs={'pk':pfe_.id})+"\n"+
                                                        "Lien de modification : "+settings.PROTOCOLE_HOST+reverse('pfe_update', kwargs={'pk':pfe_.id}))
        except Exception :
            pass
        return response


class PFEDetailView(UserPassesTestMixin, TemplateView):
    template_name = 'scolar/pfe_detail.html'

    def test_func(self):    
        pfe_=get_object_or_404(PFE, Q(groupe__section__formation__programme__matiere_equipe__isnull=True), id=self.kwargs.get("pk"))  
        if pfe_.statut_validation=='C' :
            if not self.request.user.is_authenticated :
                return False
            if self.request.user.has_perm('scolar.fonctionnalitenav_stages_validation') :
                return True
            elif self.request.user.is_enseignant() :
                return (self.request.user.enseignant in pfe_.coencadrants.all())
            elif self.request.user.is_partenaire() :
                return pfe_.email_promoteur==self.request.user.email
            elif self.request.user.is_etudiant() :
                return PFE.objects.filter(id=pfe_.id, reserve_pour__etudiant__in=[self.request.user.etudiant]).exists()
        else :
            if get_institution().activation_public_stages :
                return True
            elif self.request.user.is_authenticated :
                if self.request.user.is_enseignant() :
                    return (self.request.user.enseignant in pfe_.coencadrants.all()) or self.request.user.has_perm('scolar.fonctionnalitenav_stages_visualisationstages')
                elif self.request.user.is_partenaire() :
                    return pfe_.email_promoteur==self.request.user.email or self.request.user.has_perm('scolar.fonctionnalitenav_stages_visualisationstages')
                elif self.request.user.is_etudiant() :
                    return PFE.objects.filter(id=pfe_.id, reserve_pour__etudiant__in=[self.request.user.etudiant]).exists() or self.request.user.has_perm('scolar.fonctionnalitenav_stages_visualisationstages')
                else :
                    return self.request.user.has_perm('scolar.fonctionnalitenav_stages_visualisationstages')
            else :
                return False
        
    def get_context_data(self, **kwargs):
        context = super(PFEDetailView, self).get_context_data(**kwargs)
        titre='Sujet de Stage N°: '+ self.kwargs.get("pk")
        context['titre'] = titre
        pfe_=get_object_or_404(PFE, Q(groupe__section__formation__programme__matiere_equipe__isnull=True), id=self.kwargs.get("pk"))  
        context['pfe_form'] = PFEDetailForm(instance=pfe_)
        
        exclude_columns_=[]
        if not self.request.user.is_authenticated:
            exclude_columns_.append('expert')
            exclude_columns_.append('action')
            exclude_columns_.append('edit')
            exclude_columns_.append('admin')
        else :
            if (not self.request.user.has_perm('scolar.fonctionnalitenav_stages_validation')):
                exclude_columns_.append('edit')
                exclude_columns_.append('admin')
                exclude_columns_.append('expert')
            if self.request.user.is_etudiant():
                exclude_columns_.append('action')
            if self.request.user.is_partenaire():
                exclude_columns_.append('action')

        table = ValidationTable(Validation.objects.filter(pfe=self.kwargs.get("pk")), exclude=exclude_columns_)
        RequestConfig(self.request).configure(table)
        context['pfe_validation_table'] = table
        
        return context

class PFEPDFView(LoginRequiredMixin, UserPassesTestMixin, PDFTemplateView):
    template_name = 'scolar/pfe_fiche_pdf.html'
    cmd_options={
        'orientation':'Portrait',
        'page-size':'A4',
        }
    def test_func(self):
        pfe_=get_object_or_404(PFE, Q(groupe__section__formation__programme__matiere_equipe__isnull=True), id=self.kwargs.get("pfe_pk"))  
        if self.request.user.has_perm('scolar.fonctionnalitenav_stages_visualisationstages') :
            return True
        elif self.request.user.is_enseignant() :
            return (self.request.user.enseignant in pfe_.coencadrants.all())
        elif self.request.user.is_partenaire() :
            return pfe_.email_promoteur==self.request.user.email
        elif self.request.user.is_etudiant() :
            return PFE.objects.filter(id=pfe_.id, reserve_pour__etudiant__in=[self.request.user.etudiant]).exists()
        else :
            return False
      
    def get_context_data(self, **kwargs):
        context = super(PFEPDFView, self).get_context_data(**kwargs)
        pfe_=get_object_or_404(PFE, id=self.kwargs.get('pfe_pk'))
        self.filename='FICHE_PFE_'+str(pfe_.id)+'.pdf'
        
        context['pfe'] = pfe_
        context['moyens_informatiques']=dict(OPTION_MOYENS)
        context['avis_expert']=dict(OPTIONS_VALIDATION)
        return context

class ExpertsIndexView(LoginRequiredMixin, UserPassesTestMixin, PDFTemplateView):
    template_name = 'scolar/experts_index_pdf.html'
    
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalitenav_stages_experts')
    
    def get_context_data(self, **kwargs):
        context = super(ExpertsIndexView, self).get_context_data(**kwargs)
        
        experts_index={}
        for enseignant_ in Enseignant.objects.all().order_by('nom', 'prenom'):
            expertise_list=Validation.objects.filter(Q(pfe__type='P')|Q(pfe__type='M'), expert=enseignant_, avis__isnull=False, pfe__groupe__section__formation__annee_univ__encours=True).order_by('pfe')
            if expertise_list.exists():
                experts_index[enseignant_]=[]
                for expertise_ in expertise_list:
                    if not expertise_.pfe in  experts_index[enseignant_]:
                        experts_index[enseignant_].append(expertise_.pfe)
        
        context['experts_index'] = experts_index
        context['titre'] = "Index des experts des sujets de PFE"
        context['annee_univ'] = AnneeUniv.objects.get(encours=True)
        return context

@login_required
def experts_pfe_charge_view(request):
    # if this is a POST request we need to process the form data

    if not request.user.has_perm('scolar.fonctionnalitenav_stages_experts'):
        messages.error(request,"Vous n'êtes pas autorisés à accéder à cette fonction.")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = DateSelectForm(request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:
                form_data=form.cleaned_data
                experts_index={}
                for enseignant_ in Enseignant.objects.filter(situation='A', statut='P').order_by('nom', 'prenom'):
                    expertise_list=Validation.objects.filter(Q(pfe__type='P')|Q(pfe__type='M'), expert=enseignant_, avis__isnull=False, debut__gte=form_data['date_debut'])
                    experts_index[enseignant_]=[]
                    for expertise_ in expertise_list:
                        if not expertise_.pfe in experts_index[enseignant_]:
                            experts_index[enseignant_].append(expertise_.pfe)
        
                context={}
                context['experts_index'] = experts_index                
                
                context['date_debut']=form_data['date_debut']
                return render(request, 'scolar/experts_pfe_charge.html', context)
            
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: lors de la génération du listing de la charge d'expertise des PFE.")
                    return HttpResponseRedirect(reverse('home'))
    else:
        form = DateSelectForm()
        messages.info(request, "Merci de renseigner la date de début des expertises PFE.")
        context={}
        context['form'] = form
        context['titre'] = "Sélection de la date de début des expertises pFE"
        return render(request, 'scolar/import.html', context)

@login_required
def pfe_fiche_list_pdf_view(request, formation_pk, periode_pk):
    if not (request.user.has_perm('scolar.fonctionnalitenav_stages_exportationstages') or request.user.perm('scolar.fonctionnalitenav_etudiants_documentsgroupes')):
        messages.error(request,"Vous n'avez pas la permission d'exécution de cette opération")
        return redirect('/accounts/login/?next=%s' % request.path)
    try:
        t = threading.Thread(target=task_pfe_fiche_list_pdf,args=[formation_pk, request.user])
        t.setDaemon(True)
        t.start()
        messages.success(request,"Votre demande de génération des fiches PFE est effectuée avec succès.")
        messages.success(request,"Une notification vous sera transmise une fois la tâche terminée.")

    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            messages.error(request,"ERREUR: lors de la demande de génération des fiches PFE. Merci de le signaler à l'administrateur.")
    return HttpResponseRedirect(reverse('document_list'))


def task_pfe_fiche_list_pdf(formation_pk, user): 
    try:
        context={}
        cmd_options={
            'orientation':'Portrait',
            'page-size':'A4',
            }
        
        formation_=Formation.objects.get(id=formation_pk)
        pfe_list=PFE.objects.filter(groupe__section__formation=formation_).order_by('id')
        filename='FICHES_PFE_'+str(formation_)+'.pdf'
        context['pfe_list'] = pfe_list
        context['date'] = datetime.date.today()
        context['institution'] = user.institution()
        context['moyens_informatiques']=dict(OPTION_MOYENS)
        context['avis_expert']=dict(OPTIONS_VALIDATION)
        
        pdf_=render_pdf_from_template(input_template='scolar/pfe_fiche_list_pdf.html', 
                                      header_template=None,
                                      footer_template=None,
                                      context=context, 
                                      cmd_options=cmd_options)
        random_string=''.join(random.choices(string.ascii_uppercase + string.digits, k=10))
        filename = 'FPE_'+random_string+'.pdf'
        default_storage.save(settings.MEDIA_ROOT+'/files/'+filename, io.BytesIO(pdf_))
        file_url=settings.PROTOCOLE_HOST+'/media/files/'+filename
        trace_create(user, user, 'La génération des fiches PFE de '+str(formation_)+' est terminée : '+ file_url)

        if activation_emails():
            email = EmailMessage('[Talents] Génération des Fiches PFE de '+str(formation_),
                                 'Bonjour,\n'+ 
                                 'La génération des fiches PFE de '+str(formation_)+' est terminée \n'+
                                 'Veuillez trouver ci-jointes les fiches\n'+
                                 'Bien cordialement.\n'+
                                 signature_emails(), to=[user.get_email()]
                                                    )
            email.attach(filename, pdf_, 'application/pdf' )
            email.send(fail_silently=True)
    except Exception:
        trace_create(user, user, 'Une erreur s\'est produite lors de la génération des fiches PFE de la formation '+str(formation_))

        if settings.DEBUG:
            raise Exception
        else:
            if activation_emails():
                email = EmailMessage('[Talents] Erreur lors de la génération des fiches PFE de  la formation '+str(formation_),
                                     'Bonjour,\n'+ 
                                     'Une erreur s\'est produite lors de la génération des fiches PFE de la formation '+str(formation_)+'\n'+
                                     'Bien cordialement.\n'+
                                     signature_emails(), to=[user.get_email()] )
                email.send(fail_silently=True)


class PFEDeleteView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, DeleteView):
    model = PFE
    template_name = 'scolar/delete.html'
    permission_required='scolar.fonctionnalitenav_stages_validation'
    success_message = "Le sujet de stage a bien été supprimé (et éventuellement son groupe de stagiaires + ses charges)"
    
    def get_success_url(self):
        messages.success(self.request, self.success_message)
        return reverse('service_pfe_list')
    
    @transaction.atomic
    def delete(self, *args, **kwargs):
        pfe_=self.get_object()
        groupe_=pfe_.groupe
        if groupe_ :
            activites=Activite.objects.filter(cible__in=[groupe_])
            for activite_ in activites :
                Charge.objects.filter(activite=activite_).delete()    
            activites.delete()
            groupe_.delete()
        #super(PFEDeleteView supprimera l'objet PFE)
        #le champs groupe de PFE a été modifié en SET_NULL, afin que l'objet PFE ne sera pas supprimé après suppression du groupe, il sera supprimé par l'appel à super(PFEDeleteView)
        trace_create(self.request.user, self.request.user, "Suppression du sujet de PFE : "+str(pfe_))
        return super(PFEDeleteView, self).delete(*args, **kwargs)

@login_required
def pfe_demande_suppression_confirmation(request, pk):
    pfe_=get_object_or_404(PFE, id=pk)
    acces=False
    if request.user.is_enseignant() or request.user.is_etudiant() or request.user.is_partenaire() :
        if request.user.is_enseignant() :
            if request.user.enseignant in pfe_.coencadrants.all() :
                if ((pfe_.statut_validation in ['C', 'S', 'RR', 'N', 'V']) and (not pfe_.groupe)) :
                    acces=True 
        if request.user.is_etudiant():
            etudiant_list=[]
            for inscription_ in pfe_.reserve_pour.all():
                etudiant_list.append(inscription_.etudiant.matricule)
            if request.user.etudiant.matricule in etudiant_list and pfe_.statut_validation in ['C', 'S', 'RR', 'N']:
                acces=True
        if request.user.is_partenaire() and request.user.email and pfe_.email_promoteur :
            if (request.user.email.upper()==pfe_.email_promoteur.upper()) and (pfe_.statut_validation in ['C', 'S', 'RR', 'N', 'V']) and (not pfe_.groupe):
                acces=True
    if not acces :
        messages.error(request,"Vous n'avez pas les permissions d'accès à cette opération")
        return redirect('/accounts/login/?next=%s' % request.path)

    context={}
    context['info']="La demande de suppression de ce sujet sera transmise au responsable des stages afin d'être traitée. (Sujet : "+str(pfe_)+")"
    context['lien']=reverse('pfe_demande_suppression', kwargs={'pk': pk}) 
    return render(request, 'scolar/confirmation.html', context)

@login_required
def pfe_demande_suppression(request, pk):
    pfe_=get_object_or_404(PFE, id=pk)
    acces=False
    if request.user.is_enseignant() or request.user.is_etudiant() or request.user.is_partenaire() :
        if request.user.is_enseignant() :
            if request.user.enseignant in pfe_.coencadrants.all() :
                if ((pfe_.statut_validation in ['C', 'S', 'RR', 'N', 'V']) and (not pfe_.groupe)) :
                    acces=True 
        if request.user.is_etudiant():
            etudiant_list=[]
            for inscription_ in pfe_.reserve_pour.all():
                etudiant_list.append(inscription_.etudiant.matricule)
            if request.user.etudiant.matricule in etudiant_list and pfe_.statut_validation in ['C', 'S', 'RR', 'N']:
                acces=True
        if request.user.is_partenaire() and request.user.email and pfe_.email_promoteur :
            if (request.user.email.upper()==pfe_.email_promoteur.upper()) and (pfe_.statut_validation in ['C', 'S', 'RR', 'N', 'V']) and (not pfe_.groupe):
                acces=True
    if not acces :
        messages.error(request,"Vous n'avez pas les permissions d'accès à cette opération")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    for user_ in users_stage_institution() :
        trace_create(request.user, user_, "[Notification] Demande de suppression d'un sujet de PFE.\n"+
                                                "Sujet : "+str(pfe_)+"\n"+
                                                "Demande de suppression par : "+str(request.user)+" - "+request.user.nom()+" "+request.user.prenom()+"\n"+
                                                "Statut actuel : "+dict(STATUT_VALIDATION)[pfe_.statut_validation]+"\n"+
                                                "Lien de visualisation : "+settings.PROTOCOLE_HOST+reverse('pfe_detail', kwargs={'pk':pfe_.id}))
        if activation_emails() :
            email = EmailMessage("[Talents] Demande de suppression d'un sujet de PFE", 
                                "Sujet : "+str(pfe_)+"\n"+
                                "Demande de suppression par : "+str(request.user)+" - "+request.user.nom()+" "+request.user.prenom()+"\n"+
                                "Statut actuel : "+dict(STATUT_VALIDATION)[pfe_.statut_validation]+"\n"+
                                "Lien de visualisation : "+settings.PROTOCOLE_HOST+reverse('pfe_detail', kwargs={'pk':pfe_.id}), to=email_stage(), cc=[pfe_.email_promoteur]+[coencadrant_.get_email() for coencadrant_ in pfe_.coencadrants.all()]+
                                                    [inscription_.etudiant.get_email() for inscription_ in pfe_.reserve_pour.all()])
            email.send(fail_silently=True)
            
    messages.success(request, "Votre demande a bien été transmise, nous la traîterons dans les plus brefs délais.")

    if request.user.has_perm('scolar.fonctionnalitenav_stages_validation'):
        success_url = reverse('service_pfe_list')
    elif request.user.is_enseignant():
        success_url = reverse('enseignant_pfe_list')
    elif request.user.is_etudiant():
        success_url = reverse('etudiant_pfe_list')
    elif request.user.is_partenaire():
        success_url = reverse('partenaire_pfe_list')    
    else:
        success_url = reverse('home')
    return HttpResponseRedirect(success_url)

class PFEListView(TemplateView):
    template_name = 'scolar/filter_list.html'
 
    def get_context_data(self, **kwargs):
        context = super(PFEListView, self).get_context_data(**kwargs)

        #filter_ = PFEFilter(self.request.GET, queryset=PFE.objects.filter(groupe__isnull=True).order_by('id'))
        filter_ = PFEFilter(self.request.GET, queryset=PFE.objects.filter(Q(type='P')|Q(type='M')).exclude(statut_validation='C').order_by('-id'))
        filter_.form.helper = FormHelper()
        exclude_columns_=[]
        if not self.request.user.is_authenticated:
            exclude_columns_.append('expert')
            exclude_columns_.append('edit')
            exclude_columns_.append('admin')
        else :
            if not self.request.user.has_perm('scolar.fonctionnalitenav_stages_validation'):
                exclude_columns_.append('expert')
                exclude_columns_.append('edit')
                exclude_columns_.append('admin')
        table = PFETable(filter_.qs, exclude=exclude_columns_)
        RequestConfig(self.request).configure(table)
            
        context['filter'] = filter_
        context['table'] = table
        context['titre'] = "Liste des sujets de stages de fin d'études"
        if self.request.user.is_authenticated:
            btn_list={}
            if self.request.user.has_perm('scolar.fonctionnalitenav_stages_soumission'):
                btn_list.update({'Nouveau Sujet':reverse('organisme_select_for_pfe_create')})
            if self.request.user.has_perm('scolar.fonctionnalite_stages_importation') :
                btn_list.update({'Import PFE':reverse('import_affectation_pfe')})
                btn_list.update({'Confirmer Attribution PFE':reverse('import_affectation_pfe_valide')})
            context['btn_list']=btn_list
        return context

class ServicePFEListView(LoginRequiredMixin, PermissionRequiredMixin ,TemplateView):
    template_name = 'scolar/service_pfe_list.html'
    permission_required = 'scolar.fonctionnalitenav_stages_validation'
    
    def get_context_data(self, **kwargs):
        context = super(ServicePFEListView, self).get_context_data(**kwargs)

        pfe_controle_table = PFETable(PFE.objects.filter(Q(type='P')|Q(type='M'), Q(groupe__isnull=True)|Q(groupe__section__formation__annee_univ__encours=True), statut_validation='C').exclude(groupe__section__formation__programme__matiere_equipe__isnull=False).order_by('id'))
        pfe_controle_nb = PFE.objects.filter(Q(type='P')|Q(type='M'), Q(groupe__isnull=True)|Q(groupe__section__formation__annee_univ__encours=True), statut_validation='C').exclude(groupe__section__formation__programme__matiere_equipe__isnull=False).count()

        pfe_soumis_table = PFETable(PFE.objects.filter(Q(type='P')|Q(type='M'), Q(groupe__isnull=True)|Q(groupe__section__formation__annee_univ__encours=True), statut_validation='S').exclude(groupe__section__formation__programme__matiere_equipe__isnull=False).order_by('id'))
        pfe_soumis_nb = PFE.objects.filter(Q(type='P')|Q(type='M'), Q(groupe__isnull=True)|Q(groupe__section__formation__annee_univ__encours=True), statut_validation='S').exclude(groupe__section__formation__programme__matiere_equipe__isnull=False).count()

        pfe_attente_validation_table = PFETable(PFE.objects.filter(Q(type='P')|Q(type='M'), Q(groupe__isnull=True)|Q(groupe__section__formation__annee_univ__encours=True), statut_validation='W').exclude(groupe__section__formation__programme__matiere_equipe__isnull=False).order_by('id'))
        pfe_attente_validation_nb = PFE.objects.filter(Q(type='P')|Q(type='M'), Q(groupe__isnull=True)|Q(groupe__section__formation__annee_univ__encours=True), statut_validation='W').exclude(groupe__section__formation__programme__matiere_equipe__isnull=False).count()

        pfe_revision_requise_table = PFETable(PFE.objects.filter(Q(type='P')|Q(type='M'), Q(groupe__isnull=True)|Q(groupe__section__formation__annee_univ__encours=True), statut_validation='RR').exclude(groupe__section__formation__programme__matiere_equipe__isnull=False).order_by('id'))
        pfe_revision_requise_nb = PFE.objects.filter(Q(type='P')|Q(type='M'), Q(groupe__isnull=True)|Q(groupe__section__formation__annee_univ__encours=True), statut_validation='RR').exclude(groupe__section__formation__programme__matiere_equipe__isnull=False).count()
        
        pfe_revision_terminee_table = PFETable(PFE.objects.filter(Q(type='P')|Q(type='M'), Q(groupe__isnull=True)|Q(groupe__section__formation__annee_univ__encours=True), statut_validation='RT').exclude(groupe__section__formation__programme__matiere_equipe__isnull=False).order_by('id'))
        pfe_revision_terminee_nb = PFE.objects.filter(Q(type='P')|Q(type='M'), Q(groupe__isnull=True)|Q(groupe__section__formation__annee_univ__encours=True), statut_validation='RT').exclude(groupe__section__formation__programme__matiere_equipe__isnull=False).count()

        pfe_levee_reserve_table = PFETable(PFE.objects.filter(Q(type='P')|Q(type='M'), Q(groupe__isnull=True)|Q(groupe__section__formation__annee_univ__encours=True), statut_validation='LR').exclude(groupe__section__formation__programme__matiere_equipe__isnull=False).order_by('id'))
        pfe_levee_reserve_nb = PFE.objects.filter(Q(type='P')|Q(type='M'), Q(groupe__isnull=True)|Q(groupe__section__formation__annee_univ__encours=True), statut_validation='LR').exclude(groupe__section__formation__programme__matiere_equipe__isnull=False).count()

        pfe_valide_attribue_table = PFETable(PFE.objects.filter(Q(type='P')|Q(type='M'), Q(groupe__isnull=True)|Q(groupe__section__formation__annee_univ__encours=True), statut_validation='V', reserve_pour__isnull=False).exclude(groupe__section__formation__programme__matiere_equipe__isnull=False).distinct().order_by('id'))
        pfe_valide_attribue_nb = PFE.objects.filter(Q(type='P')|Q(type='M'), Q(groupe__isnull=True)|Q(groupe__section__formation__annee_univ__encours=True), statut_validation='V', reserve_pour__isnull=False).exclude(groupe__section__formation__programme__matiere_equipe__isnull=False).distinct().count()
        
        pfe_valide_non_attribue_table = PFETable(PFE.objects.filter(Q(type='P')|Q(type='M'), Q(groupe__isnull=True)|Q(groupe__section__formation__annee_univ__encours=True), statut_validation='V', reserve_pour__isnull=True).exclude(groupe__section__formation__programme__matiere_equipe__isnull=False).distinct().order_by('id'))
        pfe_valide_non_attribue_nb = PFE.objects.filter(Q(type='P')|Q(type='M'), Q(groupe__isnull=True)|Q(groupe__section__formation__annee_univ__encours=True), statut_validation='V', reserve_pour__isnull=True).exclude(groupe__section__formation__programme__matiere_equipe__isnull=False).distinct().count()

        pfe_non_valide_table = PFETable(PFE.objects.filter(Q(type='P')|Q(type='M'), Q(groupe__isnull=True)|Q(groupe__section__formation__annee_univ__encours=True), statut_validation='N').exclude(groupe__section__formation__programme__matiere_equipe__isnull=False).order_by('id'))
        pfe_non_valide_nb = PFE.objects.filter(Q(type='P')|Q(type='M'), Q(groupe__isnull=True)|Q(groupe__section__formation__annee_univ__encours=True), statut_validation='N').exclude(groupe__section__formation__programme__matiere_equipe__isnull=False).count()
        
        RequestConfig(self.request).configure(pfe_soumis_table)
            
        context['pfe_controle_table'] = pfe_controle_table
        context['pfe_controle_nb'] = pfe_controle_nb

        context['pfe_soumis_table'] = pfe_soumis_table
        context['pfe_soumis_nb'] = pfe_soumis_nb

        context['pfe_attente_validation_table'] = pfe_attente_validation_table
        context['pfe_attente_validation_nb'] = pfe_attente_validation_nb
        
        context['pfe_revision_requise_table'] = pfe_revision_requise_table
        context['pfe_revision_requise_nb'] = pfe_revision_requise_nb

        context['pfe_revision_terminee_table'] = pfe_revision_terminee_table
        context['pfe_revision_terminee_nb'] = pfe_revision_terminee_nb

        context['pfe_levee_reserve_table'] = pfe_levee_reserve_table
        context['pfe_levee_reserve_nb'] = pfe_levee_reserve_nb

        context['pfe_valide_attribue_table'] = pfe_valide_attribue_table
        context['pfe_valide_attribue_nb'] = pfe_valide_attribue_nb

        context['pfe_valide_non_attribue_table'] = pfe_valide_non_attribue_table
        context['pfe_valide_non_attribue_nb'] = pfe_valide_non_attribue_nb

        context['pfe_non_valide_table'] = pfe_non_valide_table
        context['pfe_non_valide_nb'] = pfe_non_valide_nb
        
        context['titre'] = 'Validation des sujets de stages'
        return context

class EnseignantPFEListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name = 'scolar/list.html'
    
    def test_func(self):
        return self.request.user.is_enseignant()
    
    def get_context_data(self, **kwargs):
        context = super(EnseignantPFEListView, self).get_context_data(**kwargs)
        
        pfe_table = PFETable(PFE.objects.filter(Q(type='P')|Q(type='M'), Q(groupe__isnull=True)|Q(groupe__section__formation__annee_univ__encours=True), coencadrants__in=[self.request.user.enseignant]).order_by('id'), exclude=exclude_columns_enseignant(self.request.user))
        context['table'] = pfe_table
        context['titre'] = "Mes sujets de stages"
        context['btn_list'] = {
                'Nouveau Sujet':reverse('organisme_select_for_pfe_create')
            }
        return context

class PartenairePFEListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name = 'scolar/list.html'
    
    def test_func(self):
        return self.request.user.is_partenaire()
    
    def get_context_data(self, **kwargs):
        context = super(PartenairePFEListView, self).get_context_data(**kwargs)
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalitenav_stages_validation') :
            exclude_.append('edit')
            exclude_.append('admin')        
        pfe_table = PFETable(PFE.objects.filter(Q(type='P')|Q(type='M'), Q(groupe__isnull=True)|Q(groupe__section__formation__annee_univ__encours=True), email_promoteur__iexact=self.request.user.email).order_by('id'), exclude=exclude_)
        context['table'] = pfe_table
        context['titre'] = "Mes sujets de stages"
        context['btn_list'] = {
                'Nouveau Sujet':reverse('organisme_select_for_pfe_create')
            }
        return context

class EtudiantPFEListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name = 'scolar/list.html'
    
    def test_func(self):
        return self.request.user.is_etudiant()
    
    def get_context_data(self, **kwargs):
        context = super(EtudiantPFEListView, self).get_context_data(**kwargs)
        
        pfe_table = PFETable(PFE.objects.filter(Q(type='P')|Q(type='M'), Q(groupe__isnull=True)|Q(groupe__section__formation__annee_univ__encours=True), reserve_pour__etudiant__in=[self.request.user.etudiant]).order_by('id'), exclude=exclude_columns_etudiant(self.request.user))
        context['table'] = pfe_table
        context['titre'] = "Mes sujets de stages"
        context['btn_list'] = {
                'Nouveau Sujet':reverse('organisme_select_for_pfe_create')
            }
        return context

class EnseignantExpertisePFEListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name = 'scolar/list.html'

    def test_func(self):
        return self.request.user.is_enseignant()
    
    def get_context_data(self, **kwargs):
        context = super(EnseignantExpertisePFEListView, self).get_context_data(**kwargs)
        exclude_columns_=exclude_columns_enseignant(self.request.user)
#         if (not self.request.user.is_staff_only()):
#             exclude_columns_.append('expert')

        validation_table = ValidationTable(Validation.objects.filter(pfe__groupe__isnull=True, expert=self.request.user.enseignant), exclude=exclude_columns_)
        context['table'] = validation_table
        context['titre'] = "Sujets de stages à expertiser"
        return context


@login_required
def commission_validation_create_view(request, pfe_pk):
    
    these_qs=These.objects.filter(sujet__id=pfe_pk)
    if these_qs.exists() :
        if not request.user.has_perm('scolar.fonctionnalitenav_postgraduation_gestionsujets') :
            messages.error(request,"Vous n'avez pas les permissions pour executer cette opération.")
            return redirect('/accounts/login/?next=%s' % request.path)
    else :    
        if not request.user.has_perm('scolar.fonctionnalitenav_stages_validation'):
            messages.error(request,"Vous n'avez pas les permissions pour executer cette opération.")
            return redirect('/accounts/login/?next=%s' % request.path)
    these_=None
    if these_qs.exists() :
        these_=these_qs.first()
    
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = CommissionValidationCreateForm(pfe_pk, request.POST)
        # check whether it's valid:
        if form.is_valid():
            data=form.cleaned_data
            try:
                pfe_=get_object_or_404(PFE, id=pfe_pk)
                experts_list=[]
                for expert_id_ in data['experts']:
                    expert_=get_object_or_404(Enseignant, id=expert_id_)
                    experts_list.append(expert_)
                for expert_ in experts_list:
                    validation_, created=Validation.objects.get_or_create(pfe=pfe_, expert=expert_.id, defaults={
                            'pfe':pfe_,
                            'expert':expert_,
                            'debut':datetime.date.today(),
                            'fin':data['fin']
                        })
                pfe_.statut_validation='W'
                pfe_.save(update_fields=['statut_validation'])
                
                if request.is_secure():
                    action_url="https"
                else:
                    action_url="http"
                action_url+="://"+request.get_host()+reverse('enseignant_expertise_list')            
                id_stage=pfe_pk if not these_ else these_.id
                if activation_emails():
                    email = EmailMessage("[Talents] Validation du sujet de stage N° "+str(id_stage),
                                         'Bonjour,\n'+
                                         "Un nouveau sujet de stage a été soumis.\n\n"+
                                         
                                         "Intitulé: "+pfe_.intitule+"\n\n"+
                                         
                                         "Nous vous invitons à donner votre avis sur ce sujet au plus tard le: "+data['fin'].strftime("%d/%m/%Y")+"\n"
                                         "Vous trouverez ce sujet dans votre compte Talents/Stages/Mes Validations, ou vous pouvez procéder à sa validation en cliquant ici:\n"+
                                         action_url+' ,\n'+ 
                                         'Cordialement',
                                         to=[expert_.get_email() for expert_ in experts_list], cc=email_stage() if not these_ else email_theses())
                    email.send(fail_silently=True)
            except Exception:
                if settings.DEBUG:
                    raise Exception("Création commission validation.")
                else:
                    messages.error(request,"Une erreur s'est produite pendant la création de la commission de Validation. Si le problème persiste, merci de le signaler à l'administrateur.")
                    render(request, 'scolar/import.html', {'form': form, 'titre':"Création d'une commission de validation"})
            messages.success(request, "La commission de validation a été créée avec succès. Une notification a été envoyée aux membres de la commission.")
            # redirect to a new URL:
            if these_ :
                return HttpResponseRedirect(reverse('these_update', kwargs={'these_pk': these_.id})) 
            else :
                return HttpResponseRedirect(reverse('pfe_update', kwargs={'pk': pfe_.id})) 
        else:
            return render(request, 'scolar/import.html', {'form': form, 'titre':"Création d'une commission de validation"})
    # if a GET (or any other method) we'll create a blank form
    else:
        form = CommissionValidationCreateForm(pfe_pk)
        messages.info(request, "Merci d'utiliser ce formulaire pour créer une commission de validation")
        return render(request, 'scolar/import.html', {'form': form, 'titre':"Création d'une commission de validation"})


   
class ValidationCreateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, CreateView):
    permission_required = 'scolar.fonctionnalitenav_stages_validation'
    model = Validation
    fields = ['pfe', 'expert', 'debut']
    template_name = 'scolar/create.html'
    success_message = "Un(e) membre de la commission de validation a été ajouté(e) avec succès."
        
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.fields['pfe']=forms.ModelChoiceField(disabled=True, queryset=PFE.objects.all(), initial=self.kwargs.get("pfe_pk"))
        form.fields['debut']=forms.DateField(disabled=True, input_formats = settings.DATE_INPUT_FORMATS, widget=DatePickerInput(format='%d/%m/%Y'), initial=datetime.date.today())    
        form.helper.add_input(Submit('submit','Ajouter', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('pfe_update', kwargs={'pk':self.kwargs.get("pfe_pk")})
        return form
    
    def get_context_data(self, **kwargs):
        context = super(ValidationCreateView, self).get_context_data(**kwargs)
        titre='Ajouter un(e) membre à la commission de validation'        
        context['titre'] = titre
        return context

    
class ValidationUpdateView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, UpdateView):
    model = Validation
    fields = [ 'avis', 'commentaire', 'fin']
    template_name = 'scolar/validation_update.html'
    success_message = "Une évaluation d'un stage a été introduite avec succès."
    
    def test_func(self):
        validation_=get_object_or_404(Validation, id=self.kwargs.get("pk"))
        if not self.request.user.is_enseignant() :
            return  False
        elif (validation_.expert==self.request.user.enseignant) :
            return True
        else :
            return False
            
        pfe_=get_object_or_404(PFE, id=self.kwargs.get("pfe_pk"))
        if not pfe_.statut_validation in ['V', 'N'] and validation_.avis=='X':
            return True
        else:
            messages.warning(self.request, "Le nouveau statut du sujet N° "+str(pfe_.id)+" est : "+
                             str(dict(STATUT_VALIDATION)[pfe_.statut_validation])+
                             ". Vous ne pouvez pas introduire votre avis. Merci.")
            return False
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        
        form.fields['commentaire'].label="Si réserves ou avis défavorable, alors expliquez ici"
            
        form.fields['fin']=forms.DateField(label="Fait le", input_formats = settings.DATE_INPUT_FORMATS, widget=DatePickerInput(format='%d/%m/%Y'), initial=datetime.date.today())

        form.helper.add_input(Submit('submit','Enregistrer', css_class='btn-warning'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.location.href='"+reverse('enseignant_expertise_list')+"'"))
        self.success_url = reverse('enseignant_expertise_list')
        return form

    def get_context_data(self, **kwargs):
        context = super(ValidationUpdateView, self).get_context_data(**kwargs)
        pfe_=get_object_or_404(PFE, id=self.kwargs.get("pfe_pk"))
        these_qs=These.objects.filter(sujet__id=self.kwargs.get("pfe_pk"))
        these_=None
        if these_qs.exists() :
            these_=these_qs.first()
            
        if these_ :   
            context['pfe_form'] = TheseDetailForm(these_pk=these_.id)
            titre='Validation du sujet de thèse N°: '+ str(these_.id)
            context['id_stage']=these_.id
        else :       
            context['pfe_form'] = PFEDetailForm(instance=pfe_)
            titre='Validation du sujet N°: '+ self.kwargs.get("pfe_pk")
            context['id_stage']=self.kwargs.get("pfe_pk")
            
        context['titre'] = titre
        exclude_columns_=[]
        if not self.request.user.has_perm('scolar.fonctionnalitenav_stages_validation') :
            exclude_columns_.append('edit')
            exclude_columns_.append('admin')
        exclude_columns_.append('action')
        validation_table = ValidationTable(Validation.objects.filter(pfe=pfe_.id, expert=self.request.user.enseignant).exclude(avis='X'), exclude=exclude_columns_)
        context['validation_table'] = validation_table
        
        return context
    
    def form_valid(self, form):
        pfe_=get_object_or_404(PFE, id=self.kwargs.get("pfe_pk"))
        validation_=self.object
        response= super().form_valid(form)
        try :
            if not pfe_.get_these() :
                for user_ in users_stage_institution() :
                    trace_create(self.request.user, user_, "[Notification] Renseignement d'un avis d'un expert pour un sujet de PFE.\n"+
                                                            "Sujet : "+str(pfe_)+"\n"+
                                                            "Avis par : "+str(self.request.user)+" - "+self.request.user.nom()+" "+self.request.user.prenom()+"\n"+
                                                            "Avis : "+dict(OPTIONS_VALIDATION)[validation_.avis]+"\n"+
                                                            "Commentaire : "+validation_.commentaire+"\n"+
                                                            "Statut actuel : "+dict(STATUT_VALIDATION)[pfe_.statut_validation]+"\n"+
                                                            "Avis actuels pour le sujet :"+" Favorable : "+str(pfe_.nb_avis_favorables())+" | Réserves mineures : "+str(pfe_.nb_avis_favorables_avec_reserves_mineures())+" | Réserves majeures : "+str(pfe_.nb_avis_favorables_avec_reserves_majeures())+" | Défavorable : "+str(pfe_.nb_avis_defavorables())+" | Non renseigné : "+str(pfe_.nb_avis_non_renseignes())+"\n"+
                                                            "Lien de visualisation : "+settings.PROTOCOLE_HOST+reverse('pfe_detail', kwargs={'pk':pfe_.id})+"\n"+
                                                            "Lien de modification : "+settings.PROTOCOLE_HOST+reverse('pfe_update', kwargs={'pk':pfe_.id}))

            else :
                for user_ in users_theses_institution() :
                    trace_create(self.request.user, user_, "[Notification] Renseignement d'un avis d'un expert pour un sujet de thèse.\n"+
                                                            "Sujet : "+str(pfe_.get_these())+"\n"+
                                                            "Avis par : "+str(self.request.user)+" - "+self.request.user.nom()+" "+self.request.user.prenom()+"\n"+
                                                            "Avis : "+dict(OPTIONS_VALIDATION)[validation_.avis]+"\n"+
                                                            "Commentaire : "+validation_.commentaire+"\n"+
                                                            "Statut actuel pour le sujet : "+dict(STATUT_VALIDATION)[pfe_.statut_validation]+"\n"+
                                                            "Avis actuels :"+" Favorable : "+str(pfe_.nb_avis_favorables())+" | Réserves mineures : "+str(pfe_.nb_avis_favorables_avec_reserves_mineures())+" | Réserves majeures : "+str(pfe_.nb_avis_favorables_avec_reserves_majeures())+" | Défavorable : "+str(pfe_.nb_avis_defavorables())+" | Non renseigné : "+str(pfe_.nb_avis_non_renseignes()))          
            
        except Exception :
            pass
        return response

@receiver(post_save, sender=Validation)
def notifier_validation(sender, update_fields, instance, created, **kwargs):
    
    if activation_emails() and instance.pfe and not created:
        these_qs=These.objects.filter(sujet__id=instance.pfe.id)
        these_=None
        if these_qs.exists() :
            these_=these_qs.first()
            email = EmailMessage("[Talents] Un nouvel enregistrement d'avis sur le sujet de thèse "+str(instance.pfe.these.id),
                             'Bonjour,\n'+
                             "Le sujet de thèse N° "+str(instance.pfe.these.id)+" a reçu un nouvel enregistrement d'avis : "+dict(OPTIONS_VALIDATION).get(instance.avis)+"\n"+
                             "Commentaire : \n"+instance.commentaire+"\n\n"+
                             "Vous pouvez statuer manuellement sur la validation du sujet.\n\n"+
                             settings.PROTOCOLE_HOST+reverse('these_update', kwargs={'these_pk':instance.pfe.these.id})+'\n\n'+
                             'Cordialement', to=email_theses() )
            email.send(fail_silently=True)
   
        elif instance.pfe.statut_validation=='W' and instance.pfe.nb_avis() == 3:
            email = EmailMessage("[Talents] 3 Avis collectés sur le sujet N° "+str(instance.pfe.id),
                             'Bonjour,\n'+
                             "Le sujet de stage N° "+str(instance.pfe.id)+" a reçu au moins 3 avis.\n"+
                             "Vous pouvez statuer sur sa validation.\n\n"+
                             settings.PROTOCOLE_HOST+reverse('pfe_update', kwargs={'pk':instance.pfe.id})+'\n\n'+
                             'Cordialement', to=email_stage() )
            email.send(fail_silently=True)
        elif instance.pfe.statut_validation=='LR' and instance.avis=='V':
            email = EmailMessage("[Talents] Une levée de réserve sur le sujet N° "+str(instance.pfe.id),
                             'Bonjour,\n'+
                             "Le sujet de stage N° "+str(instance.pfe.id)+" a reçu une levée de réserve.\n"+
                             "Vous pouvez statuer sur sa validation.\n\n"+
                             settings.PROTOCOLE_HOST+reverse('pfe_update', kwargs={'pk':instance.pfe.id})+'\n\n'+
                             'Cordialement', to=email_stage() )
            email.send(fail_silently=True)
        elif instance.pfe.statut_validation=='LR' and (instance.avis=='SR' or instance.avis=='MR'):
            email = EmailMessage("[Talents] Une nouvelle réserve sur le sujet N° "+str(instance.pfe.id),
                             'Bonjour,\n'+
                             "Le sujet de stage N° "+str(instance.pfe.id)+" a reçu une nouvelle réserve.\n"+
                             "Vous pouvez statuer sur sa validation.\n\n"+
                             settings.PROTOCOLE_HOST+reverse('pfe_update', kwargs={'pk':instance.pfe.id})+'\n\n'+
                             'Cordialement', to=email_stage() )
            email.send(fail_silently=True)
            

class ValidationDeleteView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, DeleteView):
    model = Validation
    template_name = 'scolar/delete.html'
    success_message = "L'expertise du stage a bien été supprimée"
    
    def test_func(self):
        validation_=get_object_or_404(Validation, id=self.kwargs.get("pk"))
        pfe_=validation_.pfe
        these_qs=These.objects.filter(sujet__id=pfe_.id)
        these_=None
        if these_qs.exists() :
            these_=these_qs.first()
            
        if these_ :
            return self.request.user.has_perm('scolar.fonctionnalitenav_postgraduation_gestionsujets')
        else :
            return self.request.user.has_perm('scolar.fonctionnalitenav_stages_validation')

    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression de la validation : "+str(object_))
        return super(ValidationDeleteView, self).delete(*args, **kwargs)
            
    def get_success_url(self):
        validation_=get_object_or_404(Validation, id=self.kwargs.get("pk"))
        pfe_=validation_.pfe
        these_qs=These.objects.filter(sujet__id=pfe_.id)
        these_=None
        if these_qs.exists() :
            these_=these_qs.first()
            
        if these_ :
            return reverse('these_update', kwargs={'these_pk':these_.id})
        else :
            return reverse('pfe_update', kwargs={'pk':self.kwargs.get('pfe_pk')})


@login_required
def note_pfe_update(request, module_pk, groupe_pk):
    # Il faudra refaire le traitement des données du formuliare pour n'enregistrer
    # que les données ayant changé et pas toutes (form.changed_data) pour éviter des
    # problèmes de performance
    module_=get_object_or_404(Module, id = module_pk)
    groupe_=get_object_or_404(Groupe, id = groupe_pk)
    module_suivi_=get_object_or_404(ModulesSuivis, groupe=groupe_, module=module_)
    
    if (request.user.has_perm('scolar.fonctionnalite_stages_modificationsoutenances') and module_.matiere.pfe) or (module_.formation.programme.matiere_equipe==module_.matiere and (request.user.is_coordinateur(module_) or request.user.has_perm('scolar.fonctionnalite_stages_modificationsoutenancesequipes'))):
        pass
    elif request.user.is_enseignant():
        if not assure_module_groupe(request.user.enseignant, module_, groupe_):
            messages.error(request,"Vous n'avez pas les permissions d'accès à cette opération")
            return redirect('/accounts/login/?next=%s' % request.path)
        elif module_suivi_.saisie_notes=='T' :
            messages.error(request,"La version finale de l'évaluation avait été établie. Il n'est plus possible de modifier cette évaluation")
            return HttpResponseRedirect(reverse('note_list', kwargs={'groupe_pk': groupe_pk, 'matiere_pk': module_.matiere.id}))
    else :
        messages.error(request,"Pour effectuer cette opération, vous devez être membre du jury ou bien l'enseignant coordinateur de la matière.")
        return redirect('/accounts/login/?next=%s' % request.path)
    # if this is a POST request we need to process the form data
    #liste_inscrits=Inscription.objects.filter(groupe=groupe_pk)
    
    if groupe_.is_equipe() :
        ids_inscriptions_equipe=[]
        for inscription_ in groupe_.pfe.equipe.inscriptions.all():
            ids_inscriptions_equipe.append(inscription_.id)    
        liste_inscrits=Inscription.objects.filter(id__in=ids_inscriptions_equipe).order_by('etudiant__nom', 'etudiant__prenom')
    else : #pfe    
        liste_inscrits=Inscription.objects.filter(inscription_periodes__groupe=groupe_.id, inscription_periodes__periodepgm__periode=module_.periode.periode).order_by('etudiant__nom', 'etudiant__prenom')
    liste_evaluations=Evaluation.objects.filter(module=module_pk)

    
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = NotesPFEUpdateForm(groupe_pk , module_pk, request, request.POST)
        # check whether it's valid:
        if form.is_valid():

            if module_.formation.archive:
                messages.error(request, "La saisie des notes est clôturée pour cette formation.")
            else:
                try:
                    # process the data in form.cleaned_data as required
                    data=form.cleaned_data
                    etat_saisie_=data[str(groupe_.id)+'_'+str(module_.id)]
                    for inscrit_ in liste_inscrits:
                        resultat_=get_object_or_404(Resultat, inscription=inscrit_, module__matiere = module_.matiere)
                        with transaction.atomic(): 
                            resultat_.acquis=True #pour ne pas déclencher le receiver de Note qui met à jour Resultat, on la remet à False plus loin dans le bloc de transaction atomique
                            resultat_.save()
                            for eval_ in liste_evaluations :
                                note_=get_object_or_404(Note, resultat=resultat_, evaluation=eval_)
                                key_=str(inscrit_.etudiant.matricule)+"_"+str(eval_.id)
                                note_.note= data[key_]
                                note_.save()
                                for competence_ in eval_.competence_elements.all():
                                    if competence_.commune_au_groupe:
                                        key_=str(groupe_.code)+"_"+str(eval_.id)+'_'+competence_.competence_element.code
                                    else:
                                        key_=str(inscrit_.etudiant.matricule)+"_"+str(eval_.id)+'_'+competence_.competence_element.code
                                    NoteCompetenceElement.objects.update_or_create(evaluation_competence_element=competence_, note_globale=note_, defaults={
                                            'evaluation_competence_element': competence_,
                                            'note_globale': note_,
                                            'valeur':data[key_]
                                            })
                            resultat_.acquis=False
                            resultat_.save()
                        if etat_saisie_==True:                     
                            if not groupe_.is_equipe() :
                                key_=str(inscrit_.etudiant.matricule)+"_mention"
                                inscrit_.mention=data[key_]
                            
                            key_=str(inscrit_.etudiant.matricule)+"_moy"
                            ancienne_moy=resultat_.moy
                            resultat_.moy=data[key_]
                            if not groupe_.is_equipe() :
                                resultat_.moy_post_delib=data[key_]
                                resultat_.save(update_fields=['moy', 'moy_post_delib'])
                                
                                # réinitialiser d'abord inscrit_.moy à 0 sinon moyenne retournera l'ancienne moyenne
                                inscrit_.reset_moy()
                                inscrit_.moy=inscrit_.moyenne()
                                if inscrit_.moy >= 10:
                                    inscrit_.decision_jury = 'A'
                                else : 
                                    inscrit_.decision_jury = 'N'
                                inscrit_.save(update_fields=['mention', 'moy', 'decision_jury'])
                            else :
                                resultat_.moy_post_delib=data[key_]
                                resultat_.save(update_fields=['moy', 'moy_post_delib'])
                            if ancienne_moy != resultat_.moy :
                                trace_create(request.user, inscrit_.etudiant, "Modification de la moyenne de "+str(resultat_.module)+" de "+str(ancienne_moy)+" vers "+str(resultat_.moy))
                            
                    soutenance_=get_object_or_404(Soutenance, id=groupe_.soutenance.id)
                    pfe_=get_object_or_404(PFE, id=groupe_.pfe.id)                         
                    if etat_saisie_==True:
                        if not groupe_.is_equipe() :
                            soutenance_.depot_biblio = data[str(soutenance_.id)+'_depot_biblio']
                            soutenance_.save()
                        
                        if soutenance_.date==datetime.date.today():
                            #Envoyer une notification au service des stages
                            if request.is_secure():
                                action_url="https"
                            else:
                                action_url="http"
                            action_url+="://"+request.get_host()+reverse('pv_pfe_pdf', kwargs={'groupe_pk':groupe_pk, 'module_pk':module_pk}) 
                            if not groupe_.is_equipe() : 
                                if activation_emails() :              
                                    email = EmailMessage('[Talents] Délibérations Terminées '+groupe_.code,
                                                         'Bonjour,\n'+ 
                                                         'Les délibérations de la soutenance du stage N° '+groupe_.code+' sont terminées\n'+
                                                         'Vous pouvez imprimer le PV pour la signature en cliquant sur ce lien: \n\n'+
                                                         action_url+' \n'
                                                         'Bien cordialement.\n'
                                                         , to=email_stage() )
                                    email.send(fail_silently=True)
                            else :
                                if activation_emails() :  
                                    liste_emails=[]
                                    if module_.coordinateur :
                                        liste_emails.append(module_.get_email_coordinateur())
                                    if groupe_.section.formation.programme.assistant :
                                        liste_emails.append(groupe_.section.formation.programme.get_email_assistant())
                                    email = EmailMessage('[Talents] Délibérations Terminées '+groupe_.code,
                                                         'Bonjour,\n'+ 
                                                         'Les délibérations de la soutenance de '+groupe_.section.formation.programme.matiere_equipe.code+' N° '+groupe_.code+' sont terminées\n'+
                                                         'Vous pouvez imprimer le PV pour la signature en cliquant sur ce lien: \n\n'+
                                                         action_url+' \n'
                                                         'Bien cordialement.\n'
                                                         , to=liste_emails )
                                    email.send(fail_silently=True)
                    
                                                        
                    if (request.user.has_perm('scolar.fonctionnalite_stages_modificationsoutenances') and module_.matiere.pfe) or ((request.user.is_coordinateur(module_) or request.user.has_perm('scolar.fonctionnalite_stages_modificationsoutenancesequipes')) and groupe_.section.formation.programme.matiere_equipe==module_.matiere) :
                        if groupe_.is_equipe():
                            pfe_.organisme=data[str(pfe_.id)+'_organisme']
                            pfe_.tel_promoteur=data[str(pfe_.id)+'_tel_promoteur']
                            pfe_.email_promoteur=data[str(pfe_.id)+'_email_promoteur']
                            pfe_.save()
                            
                        else :    
                            
                            pfe_.coencadrants.clear()
                            for enseignant_ in data[str(pfe_.id)+'_coencadrants']:
                                pfe_.coencadrants.add(enseignant_)

                            soutenance_.president = data[str(soutenance_.id)+'_president']
                            soutenance_.rapporteur = data[str(soutenance_.id)+'_rapporteur']
                            soutenance_.examinateur = data[str(soutenance_.id)+'_examinateur']
                            soutenance_.coencadrant = data[str(soutenance_.id)+'_coencadrant']
                            soutenance_.invite1 = data[str(soutenance_.id)+'_invite1']
                            soutenance_.invite2 = data[str(soutenance_.id)+'_invite2']
                            soutenance_.depot_biblio = data[str(soutenance_.id)+'_depot_biblio']
                        
                        pfe_.promoteur = data[str(pfe_.id)+'_promoteur']
                        pfe_.intitule = data[str(pfe_.id)+'_intitule']
                        pfe_.save()                         
                        soutenance_.assesseur1 = data[str(soutenance_.id)+'_assesseur1']
                        soutenance_.assesseur2 = data[str(soutenance_.id)+'_assesseur2']                        
                        soutenance_.date = data[str(soutenance_.id)+'_date']
                        soutenance_.save()
                        
                        
                        #TODO il faut modifier ce qui suit. Il faut déterminer le type de l'activité directement à partir de l'activité (FK vers une table des type de charges
                        if module_.formation.programme.ordre == 5:
                            type_='PFE_Enc'
                            charge_=ActiviteChargeConfig.objects.get(type=type_).vh_eq_td
                        else:
                            type_='Mem_Enc'
                            charge_=ActiviteChargeConfig.objects.get(type=type_).vh_eq_td
                            
                        if not module_.formation.programme.matiere_equipe :
                            # Mettre à jour les charges en fonction de la saisie du jury
                            activite_encadrement, created=Activite.objects.get_or_create(module=module_pk, cible__in=[groupe_pk,], type=type_, defaults={
                                'type':type_,
                                'module':module_,
                                'vh':charge_,                     #TODO mettre les type de charge et VH associé dans une table
                                'repeter_chaque_semaine':False,
                                'repartir_entre_intervenants':True,
                                })
                            activite_encadrement.cible.clear()
                            activite_encadrement.cible.add(groupe_)
                            for enseignant_ in activite_encadrement.assuree_par.all():
                                activite_encadrement.assuree_par.remove(enseignant_)
                            for enseignant in pfe_.coencadrants.all():
                                activite_encadrement.assuree_par.add(enseignant)
                            activite_encadrement.save()

                        #TODO il faut modifier ce qui suit. Il faut déterminer le type de l'activité directement à partir de l'activité (FK vers une table des type de charges
                        if module_.formation.programme.ordre == 5:
                            type_='PFE_Sout'
                            charge_=ActiviteChargeConfig.objects.get(type=type_).vh_eq_td
                        elif module_.formation.programme.matiere_equipe :
                            type_='EQP_Sout'
                            charge_=ActiviteChargeConfig.objects.get(type=type_).vh_eq_td                             
                        else :  
                            type_='Mem_Sout'
                            charge_=ActiviteChargeConfig.objects.get(type=type_).vh_eq_td                            
                         
                        activite_soutenance, created=Activite.objects.get_or_create(module=module_pk, cible__in=[groupe_pk,], type=type_, defaults={
                            'type':type_,
                            'module':module_,
                            'vh':charge_,                     #TODO mettre les type de charge et VH associé dans une table
                            'repeter_chaque_semaine':False
                            })
                        
                        activite_soutenance.cible.clear()
                        activite_soutenance.cible.add(groupe_)
                        for enseignant in activite_soutenance.assuree_par.all(): 
                            activite_soutenance.assuree_par.remove(enseignant)
                        if soutenance_.president:
                            activite_soutenance.assuree_par.add(soutenance_.president)
                        if soutenance_.examinateur:
                            activite_soutenance.assuree_par.add(soutenance_.examinateur)
                        if soutenance_.rapporteur:
                            activite_soutenance.assuree_par.add(soutenance_.rapporteur)
                        if soutenance_.coencadrant:
                            activite_soutenance.assuree_par.add(soutenance_.coencadrant)
                        if soutenance_.assesseur1:
                            activite_soutenance.assuree_par.add(soutenance_.assesseur1)
                        if soutenance_.assesseur2:
                            activite_soutenance.assuree_par.add(soutenance_.assesseur2)
                            
                        activite_soutenance.save()
                    
                    if etat_saisie_==True:
                        module_suivi_.saisie_notes='T'
                    else:
                        module_suivi_.saisie_notes='C'
                    module_suivi_.save()                    

                except Exception:
                    if settings.DEBUG:
                        raise Exception
                    else:
                        messages.error(request, "ERREUR: lors de l'enregistrement de l'évaluation. Merci de le signaler à l'administrateur.")
                        return render(request, 'scolar/note_pfe_update.html', {'form': form, 'liste_inscrits':liste_inscrits,'liste_evaluations':liste_evaluations, 'module':module_,'groupe':groupe_})
                if module_.formation.programme.matiere_equipe :
                    messages.success(request, "L'évaluation de "+module_.matiere.code+" a bien été enregistrée.")
                else :
                    messages.success(request, "L'évaluation du PFE a bien été enregistrée. Vous pouvez passer signer le PV de délibération.")
                # redirect to a new URL:
            if etat_saisie_==True:
                return HttpResponseRedirect(reverse('note_list', kwargs={'groupe_pk': groupe_pk, 'matiere_pk': module_.matiere.id}))
            else:
                return HttpResponseRedirect(reverse('note_pfe_update', kwargs={'groupe_pk': groupe_pk, 'module_pk': module_pk}))
    # if a GET (or any other method) we'll create a blank form
    else:
        form = NotesPFEUpdateForm(groupe_pk, module_pk, request)
        
        if module_.formation.programme.matiere_equipe :
            messages.success(request, "Utilisez ce formulaire pour introduire l'évaluation des différentes compétences attendues de "+module_.matiere.code+".")
        else :
            messages.info(request, "Utilisez ce formulaire pour introduire l'évaluation des différentes compétences attendues du PFE.")
    return render(request, 'scolar/note_pfe_update.html', {'form': form, 'liste_inscrits':liste_inscrits,'liste_evaluations':liste_evaluations, 'module':module_,'groupe':groupe_})


@login_required
def note_pfe_lock(request, module_pk, groupe_pk):
    module_=get_object_or_404(Module, id = module_pk)
    groupe_=get_object_or_404(Groupe, id = groupe_pk)
    module_suivi_=get_object_or_404(ModulesSuivis, groupe=groupe_, module=module_)
    
    if (request.user.has_perm('scolar.fonctionnalite_stages_modificationsoutenances') and module_.matiere.pfe) or (groupe_.is_equipe() and (request.user.is_coordinateur(module_) or request.user.has_perm('scolar.fonctionnalite_stages_modificationsoutenancesequipes'))):
        pass
    else :
        messages.error(request,"Vous n'avez pas les permissions d'accès à cette opération")
        return redirect('/accounts/login/?next=%s' % request.path)
    try:
        if module_suivi_.saisie_notes=='T':
            module_suivi_.saisie_notes='C'
        else:
            module_suivi_.saisie_notes='T'
        module_suivi_.save()
    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            messages.error(request, "ERREUR: lors du verrouillage / déverrouillage de saisie des notes.")
    else:
        messages.success(request, "Le verrouillage / déverrouillage a été réalisé avec succès!")
        # redirect to a new URL:
    if (request.user.is_coordinateur(module_) and module_.matiere.equipe):
        return HttpResponseRedirect(reverse('notes_formation_coordinateur_detail', kwargs={'formation_pk': module_.formation.id, 'periode_pk': module_.periode.id, 'module_pk' : module_.id})) 
    else :    
        return HttpResponseRedirect(reverse('notes_formation_detail', kwargs={'formation_pk': module_.formation.id, 'periode_pk': module_.periode.id})) 

class SeanceDetailView(LoginRequiredMixin, UserPassesTestMixin, DetailView):
    model = Seance
    
    def test_func(self):
        if self.request.user.has_perm('scolar.fonctionnalite_planification_visualisationseances') :
            return True
        elif self.request.user.is_enseignant() :
            seance_=get_object_or_404(Seance, id=self.kwargs.get("seance_pk"))
            if self.request.user.enseignant in seance_.activite.assuree_par.all() :
                return True
            else :
                return False
        else :
            return False
                                
class TraceListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name='scolar/filter_list.html'

    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalite_tracabilite_visualisation')
    
    def get_queryset(self,**kwargs):
        return Trace.objects.all().order_by('-date_time')
    
    def get_context_data(self, **kwargs):
        context = super(TraceListView, self).get_context_data(**kwargs)
        filter_ = TraceFilter(self.request.GET, queryset=self.get_queryset(**kwargs))
        filter_.form.helper = FormHelper()
        exclude_columns_=[]
        if (not self.request.user.has_perm('scolar.fonctionnalite_tracabilite_suppression')):
            exclude_columns_.append('edit')
        table = TraceTable(filter_.qs, exclude=exclude_columns_)
        RequestConfig(self.request, paginate={"per_page": 150}).configure(table)
        context['filter'] = filter_
        context['table'] = table
        context['titre'] = "Liste des traces"
        context['back'] = reverse('home')
        btn_list={}
        if self.request.user.has_perm('scolar.fonctionnalite_tracabilite_suppression') :
            btn_list['Suppression des traces pour un intervalle de temps']=reverse('trace_clear')
        if self.request.user.has_perm('scolar.fonctionnalite_tracabilite_visualisation') :
            btn_list['Enregistrement des traces pour un intervalle de temps']=reverse('trace_save')           
        context['btn_list']=btn_list
        return context
    
def trace_save_view(request):
    if not request.user.has_perm('scolar.fonctionnalite_tracabilite_visualisation'):
        messages.error(request, "Vous n'êtes pas autorisés à accéder à cette fonction.")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    # if this is a POST request we need to process the form data
    if request.method == 'POST':         
        # create a form instance and populate it with data from the request:
        form = IntervalleDateSelectForm(request.POST)        
        # check whether it's valid:
        if form.is_valid():
            try:
                form_data=form.cleaned_data
                date_debut=form_data['date_debut']
                date_fin=form_data['date_fin']   
                if (not date_debut) or (not date_fin) :
                    messages.error(request, "ERREUR: Vous devez spécifier les deux dates début et fin" )
                    return render(request, 'scolar/import.html', {'form': form, 'titre':'Enregistrement des traces'})
                else :
                    if date_debut > date_fin :
                        messages.error(request, "ERREUR: La date début doit être inférieure ou égale à la date fin" )
                        return render(request, 'scolar/import.html', {'form': form, 'titre':'Enregistrement des traces'})
                    t = threading.Thread(target=task_trace_save,args=[date_debut, date_fin, request.user])
                    t.setDaemon(True)
                    t.start()
            except Exception:
                raise Exception
            
            #messages.success(request, "L'enregistrement des traces entre "+str(date_debut)+ " et "+str(date_fin)+" a été effectuée avec succès.")
            if activation_emails() : 
                messages.success(request,"Votre demande d'enregistrement est prise en compte, un fichier excel vous sera transmis par mail.")                
            else :
                messages.error(request, "Notifications par e-mail désactivées dans les paramètres de l'institution, vous ne pouvez pas recevoir le fichier des traces par e-mail.")
            return HttpResponseRedirect(reverse('trace_list'))            
            # redirect to a new URL:             
    # if a GET (or any other method) we'll create a blank form
    else:
        form = IntervalleDateSelectForm()
        messages.info(request, "Merci d'indiquer l'intervalle de l'enregistrement des traces.")
        
    return render(request,'scolar/import.html', {'form': form, 'titre':'Indiquer l intervalle de l enregistrement des traces'})


def task_trace_save(date_debut, date_fin, user):
    try :     
        trace_list=Trace.objects.filter(date_time__date__gte=date_debut, date_time__date__lte=date_fin).order_by('-id')
        header=['Date-Heure','Nom-Source','Utilisateur-Source', 'Action', 'Nom-Cible', 'Utilisateur-Cible']
        sheet=Dataset()
        sheet.headers = header
        for trace_ in trace_list:                                
            row_=[]
            if settings.USE_TZ :
                timezoneLocal = pytz.timezone(settings.TIME_ZONE)
                row_.append(str(trace_.date_time.astimezone(timezoneLocal).strftime('%d/%m/%Y-%H:%M')))
            else :
                row_.append(str(trace_.date_time.strftime('%d/%m/%Y-%H:%M')))
            row_.append(trace_.source_text)
            row_.append(str(trace_.source))
            row_.append(trace_.action)
            row_.append(trace_.cible_text)
            row_.append(str(trace_.cible) if trace_.cible else '')                                
            sheet.append(row_)
        filename='Traçabilité du '+str(date_debut)+ " - "+str(date_fin)+'.xlsx'                        
        filename=filename.replace(' ','_')     
        if activation_emails() :       
            email = EmailMessage('[Talents] Enregistrement des traces du '+str(date_debut)+' au '+str(date_fin),
                         'Bonjour,\n'+
                         'Veuillez trouver ci-joint l\'enregistrement des traces entre '+str(date_debut)+' et '+ str(date_fin)+' au format Excel\n'+
                         'Bien cordialement.\n'+
                         signature_emails(), to=[user.get_email()])
            email.attach(filename, sheet.xlsx, 'application/vnd.ms-excel' )
            email.send(fail_silently=True) 
            trace_create(user, user, "Enregistrement des traces entre : "+str(date_debut)+" et "+str(date_fin))
        
    except Exception:
        if not settings.DEBUG :
            if activation_emails() :
                email = EmailMessage('[Talents] Erreur lors de l\'enregistrement des traces.',
                             'Bonjour,\n'+ 
                             'Une erreur s\'est produite lors de l\'enregistrement des traces entre: '+str(date_debut)+' et '+str(date_fin)+'\n'+
                             'Bien cordialement.\n'+
                             signature_emails(), to=[user.get_email()] )
                email.send(fail_silently=True)  
        else :
            raise Exception

def trace_clear_view(request):
    if not request.user.has_perm('scolar.fonctionnalite_tracabilite_suppression'):
        messages.error(request, "Vous n'êtes pas autorisés à accéder à cette fonction.")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    # if this is a POST request we need to process the form data
    if request.method == 'POST':
         
        # create a form instance and populate it with data from the request:
        form = IntervalleDateSelectForm(request.POST)
        
        # check whether it's valid:
        if form.is_valid():
            try:
                form_data=form.cleaned_data
                date_debut=form_data['date_debut']
                date_fin=form_data['date_fin']   
                if (not date_debut) or (not date_fin) :
                    messages.error(request, "ERREUR: Vous devez spécifier les deux dates début et fin" )
                    return render(request, 'scolar/import.html', {'form': form, 'titre':'Suppression des traces'})
                else :
                    if date_debut > date_fin :
                        messages.error(request, "ERREUR: La date début doit être inférieure ou égale à la date fin" )
                        return render(request, 'scolar/import.html', {'form': form, 'titre':'Suppression des traces'})
                    
                    trace_list=Trace.objects.filter(date_time__date__gte=date_debut, date_time__date__lte=date_fin)                    
                    trace_list.delete()                    
                    trace_create(request.user, request.user, "Suppression des traces entre: "+str(date_debut)+" et "+str(date_fin))                                     

            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: La liste des traces n'a pas été supprimée correctement." )
            messages.success(request, "La suppression des traces entre "+str(date_debut)+ " et "+str(date_fin)+" a été effectuée avec succès.")                
            return HttpResponseRedirect(reverse('trace_list'))            
            # redirect to a new URL:
             
    # if a GET (or any other method) we'll create a blank form
    else:
        form = IntervalleDateSelectForm()
        messages.info(request, "Merci d'indiquer l'intervalle de suppression des traces.")
        
    return render(request,'scolar/import.html', {'form': form, 'titre':'Suppression des traces'})

class TraceDeleteView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, DeleteView):
    model = Trace
    template_name = 'scolar/delete.html'
    success_message = "La trace a bien été supprimée."
    permission_required='scolar.fonctionnalite_tracabilite_suppression'
    
    def get_success_url(self):
        return reverse('trace_list')     
        

class NotificationsView(LoginRequiredMixin, TemplateView):
    template_name='scolar/list.html'
    
    def get_queryset(self,**kwargs):
        return Trace.objects.filter(cible=self.request.user).order_by('-date_time')
    
    def get_context_data(self, **kwargs):
        context = super(NotificationsView, self).get_context_data(**kwargs)
        table = NotificationsTable(self.get_queryset(**kwargs))
        RequestConfig(self.request).configure(table)
        context['table'] = table
        context['titre'] = "Mes notifications"
        return context
    
class DoctorantListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name = 'scolar/filter_list.html'

    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalitenav_postgraduation_visualisationdoctorants')
    
    def get_queryset(self, **kwargs):
        doctorants=Doctorant.objects.filter(Q(enseignant__isnull=False) | Q(etudiant__isnull=False)).annotate(nom=Case(
        When(enseignant__nom__isnull=False, then=F('enseignant__nom')),
        When(etudiant__nom__isnull=False, then=F('etudiant__nom')),
        default=None,
        output_field=CharField()), prenom=Case(
        When(enseignant__prenom__isnull=False, then=F('enseignant__prenom')),
        When(etudiant__prenom__isnull=False, then=F('etudiant__prenom')),
        default=None,
        output_field=CharField()), organisme__sigle=F('organisme__sigle')).order_by('nom', 'prenom')
        return doctorants

    def get_context_data(self ,**kwargs):
        context = super(DoctorantListView, self).get_context_data(**kwargs)
        filter_ = DoctorantFilter(self.request.GET, queryset=self.get_queryset(**kwargs))
        filter_.form.helper = FormHelper()
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalite_postgraduation_gestiondoctorants') :
            exclude_.append('edit')
        table = DoctorantTable(filter_.qs, exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['filter'] = filter_
        context['table'] = table
        context['back'] = reverse('home')
        if self.request.user.has_perm('scolar.fonctionnalite_postgraduation_gestiondoctorants') :
            btn_list={}
            btn_list['Import Doctorants']=reverse('doctorants_import')
            btn_list['Ajouter Doctorant']=reverse('doctorant_create')
            btn_list['Import Inscriptions']=reverse('doctorants_inscriptions_import')
            context['btn_list']=btn_list
        context['titre'] = 'Liste des Doctorants'
        return context

   
def doctorants_import_view (request):
    if not request.user.has_perm('scolar.fonctionnalite_postgraduation_gestiondoctorants'):
        messages.error(request, "Vous n'êtes pas autorisés à accéder à cette fonction.")
        return redirect('/accounts/login/?next=%s' % request.path)

    # if this is a POST request we need to process the form data
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = ImportFileForm(request.POST, request.FILES)
        
        # check whether it's valid:
        if form.is_valid():
            try:
                doctorant_file = request.FILES['file']
                dataset = Dataset(headers=['Email', 'Etudiant', 'Enseignant', 'MatriculeEtud','Nom', 'Prenoms', 'Genre', 'Ddn', 
                                           'LieuNaissance', 'WilayaNaissance', 'NomA', 'PrenomsA', 'LieuNaissanceA', 
                                           'Telephone', 'AdressePrincipale', 'WilayaResidence', 'CommuneResidence',
                                           'Interne', 'ResidenceU','Organisme'])
                imported_data = dataset.load(doctorant_file.read(), format ='xlsx')
                # insert imported_data in Etudiant table
                lignes_pb=''
                for row in imported_data.dict :
                    try:
                        if not row['Email'] :
                            raise Exception('Adresse e-mail manquante')
                        
                        is_etudiant=False
                        is_enseignant=False
                        if row['Etudiant'].lower()=="oui" :
                            is_etudiant = True
                        if row['Enseignant'].lower()=="oui" :
                            is_enseignant = True
                            
                        organisme_ = Organisme.objects.none()
                        organisme_qs= Organisme.objects.filter(sigle__iexact=row['Organisme'], interne=True)   
                        if organisme_qs.exists() :
                            organisme_ = organisme_qs.first()
                            
                            
                        wilaya_naissance_=None
                        
                        #if row['WilayaNaissance'] and Wilaya.objects.filter(code=row['WilayaNaissance']).exists():
                        if row['WilayaNaissance'] and Wilaya.objects.filter(code=str(row['WilayaNaissance'])).exists():
                            wilaya_naissance_=Wilaya.objects.filter(code=str(row['WilayaNaissance']))[0]
                        elif row['WilayaNaissance'] and Wilaya.objects.filter(nom__icontains=str(row['WilayaNaissance'])).exists():
                            wilaya_naissance_=Wilaya.objects.filter(nom__icontains=str(row['WilayaNaissance']))[0]if row['WilayaNaissance'] else None
                        
                                               
                        wilaya_residence_=None
                        if row['WilayaResidence'] and Wilaya.objects.filter(code=str(row['WilayaResidence'])).exists():
                            wilaya_residence_=Wilaya.objects.filter(code=str(row['WilayaResidence']))[0]
                        elif row['WilayaResidence'] and Wilaya.objects.filter(nom__icontains=str(row['WilayaResidence'])).exists():
                            wilaya_residence_=Wilaya.objects.filter(nom__icontains=str(row['WilayaResidence']))[0]
                        else:
                            wilaya_residence_= None  

                        nom_commun_=None
                        nom_a_commun_=None
                        prenom_commun=None
                        prenom_a_commun=None
                        date_naissance_commun=None
                        sexe_commun=None
                        tel_commun=None
                                               
                        etudiant_object=None
                        etudiant_objects = Etudiant.objects.filter(user__email=str(row['Email']))
                        if etudiant_objects.exists() :
                            is_etudiant=True
                            etudiant_object = etudiant_objects.first()
                            nom_commun_=etudiant_object.nom
                            nom_a_commun_=etudiant_object.nom_a
                            prenom_commun=etudiant_object.prenom
                            prenom_a_commun=etudiant_object.prenom_a
                            date_naissance_commun=etudiant_object.date_naissance
                            sexe_commun=etudiant_object.sexe
                            tel_commun=etudiant_object.tel 
                        
                        enseignant_object=None
                        enseignant_objects = Enseignant.objects.filter(user__email=str(row['Email']))
                        if enseignant_objects.exists() :
                            is_enseignant=True
                            enseignant_object = enseignant_objects.first()
                            nom_commun_=enseignant_object.nom
                            nom_a_commun_=enseignant_object.nom_a
                            prenom_commun=enseignant_object.prenom
                            prenom_a_commun=enseignant_object.prenom_a
                            date_naissance_commun=enseignant_object.date_naissance
                            sexe_commun=enseignant_object.sexe
                            tel_commun=enseignant_object.tel 

                        if row['Interne'] :
                            interne_= True if row['Interne'].lower()=="oui" else False
                        elif etudiant_objects.exists() :
                            interne_=etudiant_object.interne
                        else :
                            interne_=None
                        if is_etudiant :
                            if etudiant_objects.exists() :
                                etudiant_object.nom_a=row['NomA'] if row['NomA'] else etudiant_object.nom_a
                                etudiant_object.prenom_a=row['PrenomsA']  if row['PrenomsA'] else etudiant_object.prenom_a
                                etudiant_object.date_naissance= row['Ddn'] if row['Ddn'] else etudiant_object.date_naissance
                                etudiant_object.sexe= row['Genre'] if row['Genre'] else etudiant_object.sexe
                                etudiant_object.lieu_naissance=row['LieuNaissance'].upper()  if row['LieuNaissance'] else etudiant_object.lieu_naissance
                                etudiant_object.lieu_naissance_a=row['LieuNaissanceA'] if row['LieuNaissanceA']  else etudiant_object.lieu_naissance_a
                                etudiant_object.wilaya_naissance=wilaya_naissance_ if wilaya_naissance_ else etudiant_object.wilaya_naissance
                                etudiant_object.tel=str(row['Telephone']) if row['Telephone'] else etudiant_object.tel
                                etudiant_object.addresse_principale=row['AdressePrincipale'].upper() if row['AdressePrincipale'] else etudiant_object.addresse_principale
                                etudiant_object.wilaya_residence=wilaya_residence_ if wilaya_residence_ else etudiant_object.wilaya_residence
                                etudiant_object.commune_residence=Commune.objects.get(code_postal=row['CommuneResidence'].split().pop()) if row['CommuneResidence'] else etudiant_object.commune_residence
                                etudiant_object.interne= interne_
                                etudiant_object.residence_univ=row['ResidenceU'].upper() if row['ResidenceU'] else etudiant_object.residence_univ
                                etudiant_object.save()
                            else :
                                etudiant_object = Etudiant.objects.create(
                                matricule = str(row['MatriculeEtud']),
                                nom=row['Nom'].upper() if row['Nom'] else nom_commun_ ,
                                nom_a=row['NomA'] if row['NomA'] else nom_a_commun_,
                                prenom=row['Prenoms'].upper() if row['Prenoms'] else prenom_commun,
                                prenom_a=row['PrenomsA']  if row['PrenomsA']  else prenom_a_commun,
                                sexe=row['Genre'] if row['Genre'] else sexe_commun,
                                date_naissance= row['Ddn'] if row['Ddn'] else date_naissance_commun,
                                lieu_naissance=row['LieuNaissance'].upper()  if row['LieuNaissance']  else None,
                                lieu_naissance_a=row['LieuNaissanceA'] if row['LieuNaissanceA']  else None,
                                wilaya_naissance=Wilaya.objects.get(code=str(row['WilayaNaissance']).split()[0]) if row['WilayaNaissance'] else None,
                                tel=str(row['Telephone']) if row['Telephone'] else None,
                                addresse_principale=row['AdressePrincipale'].upper() if row['AdressePrincipale'] else None,
                                wilaya_residence=Wilaya.objects.get(code=row['WilayaResidence'].split()[0]) if row['WilayaResidence'] else None,
                                commune_residence=Commune.objects.get(code_postal=row['CommuneResidence'].split().pop()) if row['CommuneResidence'] else None,
                                interne= interne_,
                                residence_univ=row['ResidenceU'].upper() if row['ResidenceU'] else None
                                
                                    )
                        if is_enseignant :
                            if enseignant_objects.exists() :
                                enseignant_object.nom_a=row['NomA'] if row['NomA'] else enseignant_object.nom_a
                                enseignant_object.prenom_a=row['PrenomsA']  if row['PrenomsA'] else enseignant_object.prenom_a
                                enseignant_object.date_naissance= row['Ddn'] if row['Ddn'] else enseignant_object.date_naissance
                                enseignant_object.sexe= row['Genre'] if row['Genre'] else enseignant_object.sexe
                                enseignant_object.organisme=organisme_ if organisme_ else enseignant_object.organisme
                                enseignant_object.tel= str(row['Telephone']) if row['Telephone'] else enseignant_object.tel
                                enseignant_object.save()
                            else :
                                enseignant_object = Enseignant.objects.create(
                                nom=row['Nom'].upper() if row['Nom'] else nom_commun_ ,
                                nom_a=row['NomA'] if row['NomA'] else nom_a_commun_,
                                prenom=row['Prenoms'].upper() if row['Prenoms'] else prenom_commun,
                                prenom_a=row['PrenomsA']  if row['PrenomsA']  else prenom_a_commun,
                                sexe=row['Genre'] if row['Genre'] else sexe_commun,
                                date_naissance= row['Ddn'] if row['Ddn'] else date_naissance_commun,
                                statut= 'D',
                                tel = str(row['Telephone']) if row['Telephone'] else None,
                                organisme = organisme_ if organisme_ else None,
                                    )
                        
                        qs = User.objects.filter(username__iexact=row['Email'].strip())
                        if qs.exists() :
                            user=qs.first()
                        else :
                            user, created = User.objects.update_or_create(
                                    email=row['Email'],
                                    defaults={
                                        'username':row['Email'],
                                        'first_name': row['Prenoms'],
                                        'last_name': row['Nom'],
                                        'is_active': True,
                                        'is_superuser': False,
                                        'is_staff': False,
                                        'email': row['Email'],
                                    }
                                )
                            if created :
                                psw=User.objects.make_random_password()
                                user.set_password(psw)
                                
                        user.groups.add(Group.objects.get(name="doctorant"))
                        if is_enseignant :
                            user.groups.add(Group.objects.get(name="enseignant"))
                        if is_etudiant :
                            user.groups.add(Group.objects.get(name="etudiant"))
                        user.save()
                        
                        if is_etudiant :                        
                            etudiant_object.user=user
                            if not etudiant_object.photo :
                                imagefilename=etudiant_object.photo.field.upload_to
                                if default_storage.exists(settings.MEDIA_ROOT+'/'+etudiant_object.photo.field.upload_to+'/'+etudiant_object.matricule.replace('/','-')+'.jpg'):
                                    imagefilename+='/'+etudiant_object.matricule.replace('/','-')+'.jpg'
                                else:
                                    imagefilename+='/'+'anonymous-user.jpg'
                        
                                etudiant_object.photo.name=imagefilename
                                etudiant_object.save()
                        
                        if is_enseignant :
                            enseignant_object.user=user
                            enseignant_object.save()
                          
                        
                        doctorant_=None
                        doctorant_qs=Doctorant.objects.filter(Q(etudiant__user__email__iexact=row['Email'])|Q(enseignant__user__email__iexact=row['Email']))
                        if doctorant_qs.exists() :
                            doctorant_=doctorant_qs.first()
                        
                        if not doctorant_ :
                            Doctorant.objects.create(
                             etudiant = etudiant_object if is_etudiant else None,
                             enseignant = enseignant_object if is_enseignant else None,
                             organisme = organisme_ if organisme_ else None
                             )
                        else :
                            doctorant_.etudiant=etudiant_object if is_etudiant else doctorant_.etudiant
                            doctorant_.enseignant=enseignant_object if is_enseignant else doctorant_.enseignant
                            doctorant_.organisme= organisme_ if organisme_ else None
                            doctorant_.save()                 
                        
                        
                    except Exception:
                        lignes_pb+=str(row['Email'])+'\n'
                        if settings.DEBUG:
                            raise Exception
                        continue
                    
            except Exception:
                if settings.DEBUG:
                    raise Exception
                   
                else:
                    messages.error(request, "L'importation du fichier des doctorants n'a pas réussi. Il doit y avoir un problème de format du fichier.")
                    messages.info(request, mark_safe("La première ligne du fichier .xlsx doit comprendre au moins les colonnes: 'Email', 'Enseignant', Etudiant', MatriculeEtud','Genre','Nom', 'NomA', 'Prenoms', 'PrenomsA','Ddn',"+ 
                                                             "'WilayaNaissance','LieuNaissanceA','LieuNaissance' ,"+
                                                             "'Telephone', 'AdressePrincipale', 'WilayaResidence', 'CommuneResidence',"+
                                                             "'Interne', 'ResidenceU', 'Organisme'.<br><br>MatriculeEtud : Texte ou nombre, peu importe il sera converti en texte <br>Ddn : Colonne date sur excel, peu importe le format <br>Interne : 'Oui' ou 'Non' <br>Etudiant : 'Oui' ou 'Non' <br>Enseignant : 'Oui' ou 'Non' <br>Interne : 'Oui' ou 'Non' <br>Genre : 'M' ou 'F' <br> Tel : Colonne texte de préférence (nombre accepté) <br>WilayaNaissance et WilayaResidence : Code Wilaya en nombre ou texte sans zéros à gauche, ou bien nom de la wilaya peu importe la casse <br> CommuneResidence : Code ONS ou postal ou autre selon votre configuration (laissez vide en cas d'incertitude)<br> ResidenceU : Texte"))
                    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer des doctorants'})
            # redirect to a new URL:
            messages.success(request, "L'importation du fichier des doctorants s'est faite avec succès!")
            if lignes_pb != '':
                messages.warning(request, "Les lignes suivantes n'ont pas été insérées à cause d'erreurs:\n"+
                    lignes_pb)
            return HttpResponseRedirect(reverse('doctorant_list')) 
    # if a GET (or any other method) we'll create a blank form
    else:
        form = ImportFileForm()
        messages.info(request,"Indiquer un fichier .xlsx des doctorants à importer dans la base de Talents.")
        messages.info(request, mark_safe("La première ligne du fichier .xlsx doit comprendre au moins les colonnes:  'Email', 'Enseignant', Etudiant', MatriculeEtud','Genre','Nom', 'NomA', 'Prenoms', 'PrenomsA','Ddn',"+ 
                                                             "'WilayaNaissance','LieuNaissanceA','LieuNaissance' ,"+
                                                             "'Telephone', 'AdressePrincipale', 'WilayaResidence', 'CommuneResidence',"+
                                                             "'Interne', 'ResidenceU', 'Organisme'.<br><br>MatriculeEtud : Texte ou nombre, peu importe il sera converti en texte <br>Ddn : Colonne date sur excel, peu importe le format <br>Interne : 'Oui' ou 'Non'<br>Etudiant: 'Oui' ou 'Non'  <br>Enseignant : 'Oui' ou 'Non' <br>Interne : 'Oui' ou 'Non' <br>Genre : 'M' ou 'F' <br> Tel : Colonne texte de préférence (nombre accepté) <br>WilayaNaissance et WilayaResidence : Code Wilaya en nombre ou texte sans zéros à gauche, ou bien nom de la wilaya peu importe la casse <br> CommuneResidence : Code ONS ou postal ou autre selon votre configuration (laissez vide en cas d'incertitude)<br> ResidenceU : Texte"))
    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer des doctorants'}) 

def doctorants_inscriptions_import_view(request):
    if not request.user.has_perm('scolar.fonctionnalite_postgraduation_gestiondoctorants'):
        messages.error(request, "Vous n'êtes pas autorisés à accéder à cette fonction.")
        return redirect('/accounts/login/?next=%s' % request.path)
    # if this is a POST request we need to process the form data
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = ImportFileForm(request.POST, request.FILES)
        
        # check whether it's valid:
        if form.is_valid():
            try:
                non_importes=[]
                inscription_file = request.FILES['file']
                dataset = Dataset(headers=['Matricule','NomEtud', 'Prenoms', 'AnScol', 'Promo', 'Situation'])
                imported_data = dataset.load(inscription_file.read(), format ='xlsx')
                # insert imported_data in Etudiant table
                group=Group.objects.get(name='etudiant')
                for row in imported_data.dict :
                    programme_=get_object_or_404(Programme, code=row['Promo'])
                    if programme_.doctorat :
                        etudiant_, created=Etudiant.objects.get_or_create(matricule=str(row['Matricule']).strip(), defaults={
                                'matricule':str(row['Matricule']).strip(),
                                'nom':row['NomEtud'],
                                'prenom':row['Prenoms'],
                            }
                        )
                        # Inscription de l'étudiant
                        annee_univ_, created=AnneeUniv.objects.get_or_create(annee_univ=row['AnScol'], defaults={
                                'annee_univ':str(row['AnScol'])
                            })
                        formation_, created=Formation.objects.get_or_create(programme=programme_, annee_univ=annee_univ_, defaults={
                                'programme':programme_,
                                'annee_univ':annee_univ_
                            })
                        inscription_, created=Inscription.objects.update_or_create(etudiant=etudiant_, formation=formation_, defaults={
                            'etudiant':etudiant_,
                            'formation':formation_,
                            'decision_jury':row['Situation'] if row['Situation'] else 'X'
                            })
                        # créer inscription_periodes selon le programme
                        for periode_ in formation_.programme.periodes.all():
                            InscriptionPeriode.objects.update_or_create(inscription=inscription_, periodepgm=periode_, defaults={
                                    'inscription':inscription_,
                                    'periodepgm':periode_,
                                })
                    else :
                        non_importes.append(row['Matricule'])
                        
                    
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: Echec de l'importation des inscriptions des doctorants.")
                    messages.info(request, "La première ligne du fichier .xlsx doit comprendre au moins les colonnes: 'Matricule','NomEtud', 'Prenoms', 'AnScol', 'Promo', 'Situation'")
                    messages.info(request, "La colonne AnScol indique l'année universitaire, par ex. 2019")
                    messages.info(request, mark_safe("La colonne Promo doit correspondre au code d'un programme de post-graduation, par ex : 1D-SI, 1D-SQ, 2D-SI, 2D-SQ, 3D-SI, 3D-SQ, 4D-SI, 4D-SQ, 5D-SI, 5D-SQ, >5D-SI, >5D-SQ, ... etc.<br><br>"+
                                                     "La colonne Situation doit avoir une des valeurs suivantes : X pour Non Inscrit, C pour Inscrit, AJ pour Ajournement, F pour Abandon, FT pour Transfert, M pour Maladie, M1 pour Congé académique (année blanche) pour raisons médicales, M2 pour Congé académique (année blanche) pour raisons personnelles, M3 pour Congé académique (année blanche) pour raisons personnelles (Covid 19), M4 pour Congé académique (année blanche) pour raisons familiales, M5 pour un congé académique, etc "))
                    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer des inscriptions'})
            # redirect to a new URL:
            messages.success(request, "L'importation des inscriptions des doctorants s'est faite avec succès!")
            if non_importes :
                messages.error(request, "Non importés : "+str(non_importes))
            return HttpResponseRedirect(reverse('doctorant_list')) 
    # if a GET (or any other method) we'll create a blank form
    else:
        form = ImportFileForm()
        messages.info(request, "Indiquer un fichier .xlsx des inscriptions à importer dans la base de Talents.")
        messages.info(request, "La première ligne du fichier .xlsx doit comprendre au moins les colonnes: 'Matricule','NomEtud', 'Prenoms', 'AnScol', 'Promo', 'Situation'")
        messages.info(request, "La colonne AnScol indique l'année universitaire, par ex. 2019")
        messages.info(request, mark_safe("La colonne Promo doit correspondre au code d'un programme de post-graduation, par ex : 1D-SI, 1D-SQ, 2D-SI, 2D-SQ, 3D-SI, 3D-SQ, 4D-SI, 4D-SQ, 5D-SI, 5D-SQ, >5D-SI, >5D-SQ, ... etc.<br><br>"+
                                        "La colonne Situation doit avoir une des valeurs suivantes : X pour Non Inscrit, C pour Inscrit, AJ pour Ajournement, F pour Abandon, FT pour Transfert, M pour Maladie, M1 pour Congé académique (année blanche) pour raisons médicales, M2 pour Congé académique (année blanche) pour raisons personnelles, M3 pour Congé académique (année blanche) pour raisons personnelles (Covid 19), M4 pour Congé académique (année blanche) pour raisons familiales, M5 pour un congé académique, etc "))
    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer des inscriptions'})


@login_required
def doctorant_create_view(request):

    if not request.user.has_perm('scolar.fonctionnalite_postgraduation_gestiondoctorants'):
        messages.error(request,"Vous n'avez pas les permissions d'accès à cette opération")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = DoctorantCreateForm(request, request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:
                # process the data in form.cleaned_data as required
                data=form.cleaned_data
                user_=data['User']
                if (user_ and data['Email']) :
                    email_=data['Email']
                elif user_ :
                    email_= user_.email
                elif data['Email'] :
                    email_=data['Email']
                else :
                    raise Exception
                    
                is_enseignant=data['Enseignant']
                is_etudiant=data['Etudiant']
                enseignant_=None               
                etudiant_=None
                nom_commun_=None
                nom_a_commun_=None
                prenom_commun=None
                prenom_a_commun=None
                date_naissance_commun=None
                sexe_commun=None
                tel_commun=None 
          
                user, created = User.objects.get_or_create(
                        email=user_.email if user_ else data['Email'],
                        defaults={
                            'username':data['Email'],
                            'first_name': data['Prenoms'],
                            'last_name': data['Nom'],
                            'is_active': True,
                            'is_superuser': False,
                            'is_staff': False,
                            'email': data['Email'],
                        }  
                    )
   
                user_=user
                user_.save()
                
                enseignant_qs=Enseignant.objects.filter(user=user_)
                if enseignant_qs.exists() :
                    enseignant_=enseignant_qs.first()
                    nom_commun_=enseignant_.nom
                    nom_a_commun_=enseignant_.nom_a
                    prenom_commun=enseignant_.prenom
                    prenom_a_commun=enseignant_.prenom_a
                    date_naissance_commun=enseignant_.date_naissance
                    sexe_commun=enseignant_.sexe
                    tel_commun=enseignant_.tel 
                etudiant_qs=Etudiant.objects.filter(user=user_)
                if etudiant_qs.exists() :
                    etudiant_=etudiant_qs.first()
                    nom_commun_=etudiant_.nom
                    nom_a_commun_=etudiant_.nom_a
                    prenom_commun=etudiant_.prenom
                    prenom_a_commun=etudiant_.prenom_a
                    date_naissance_commun=etudiant_.date_naissance
                    sexe_commun=etudiant_.sexe
                    tel_commun=etudiant_.tel 
                
                if is_enseignant : #l'utilisateur a coché "Enseignant"
                    if enseignant_ :
                        enseignant_.nom_a=data['NomA'] if data['NomA'] else enseignant_.nom_a
                        enseignant_.prenom_a=data['PrenomsA']  if data['PrenomsA'] else enseignant_.prenom_a
                        enseignant_.date_naissance= data['Ddn'] if data['Ddn'] else enseignant_.date_naissance
                        enseignant_.sexe= data['Genre'] if data['Genre'] else enseignant_.sexe
                        enseignant_.organisme=data['Organisme'] if data['Organisme'] else enseignant_.organisme
                        enseignant_.tel= data['Telephone'] if data['Telephone'] else enseignant_.tel
                        enseignant_.save()

                    else :
                        enseignant_ = Enseignant.objects.create(
                            user=user_,
                            nom=data['Nom'].upper() if data['Nom'] else nom_commun_,
                            nom_a=data['NomA'] if data['NomA'] else nom_a_commun_,
                            prenom=data['Prenoms'].upper() if data['Prenoms'] else prenom_commun,
                            prenom_a=data['PrenomsA']  if data['PrenomsA']  else prenom_a_commun,
                            date_naissance= data['Ddn'] if data['Ddn'] else date_naissance_commun,
                            sexe = data['Genre'] if data['Genre'] else sexe_commun,
                            statut= 'D',
                            tel = data['Telephone'] if data['Telephone'] else None,
                            organisme = data['Organisme'] if data['Organisme'] else None,
                            )
                        
                        enseignant_.save()
                    
                if is_etudiant :
                    if etudiant_ :
                        etudiant_.nom_a=data['NomA'] if data['NomA'] else etudiant_.nom_a
                        etudiant_.prenom_a=data['PrenomsA']  if data['PrenomsA'] else etudiant_.prenom_a
                        etudiant_.date_naissance= data['Ddn'] if data['Ddn'] else etudiant_.date_naissance
                        etudiant_.sexe= data['Genre'] if data['Genre'] else etudiant_.sexe
                        etudiant_.lieu_naissance=data['LieuNaissance'].upper()  if data['LieuNaissance'] else etudiant_.lieu_naissance
                        etudiant_.lieu_naissance_a=data['LieuNaissanceA'] if data['LieuNaissanceA']  else etudiant_.lieu_naissance_a
                        etudiant_.wilaya_naissance=data['WilayaNaissance'] if data['WilayaNaissance'] else etudiant_.wilaya_naissance
                        etudiant_.tel=str(data['Telephone']) if data['Telephone'] else etudiant_.tel
                        etudiant_.addresse_principale=data['AdressePrincipale'].upper() if data['AdressePrincipale'] else etudiant_.addresse_principale
                        etudiant_.wilaya_residence=data['WilayaResidence'] if data['WilayaResidence'] else etudiant_.wilaya_residence
                        etudiant_.commune_residence= data['CommuneResidence'] if data['CommuneResidence'] else etudiant_.commune_residence
                        etudiant_.interne= data['Interne'] if data['Interne'] else etudiant_.interne
                        etudiant_.residence_univ=data['ResidenceU'].upper() if data['ResidenceU'] else etudiant_.residence_univ
                        etudiant_.save()
                    else :
                        etudiant_ = Etudiant.objects.create(
                            user= user_,
                            matricule = data['MatriculeEtud'],
                            nom=data['Nom'].upper() if data['Nom'] else nom_commun_,
                            nom_a=data['NomA'] if data['NomA'] else nom_a_commun_,
                            prenom=data['Prenoms'].upper() if data['Prenoms'] else prenom_commun,
                            prenom_a=data['PrenomsA']  if data['PrenomsA']  else prenom_commun,
                            sexe=data['Genre'] if data['Genre'] else sexe_commun,
                            date_naissance= data['Ddn'] if data['Ddn'] else date_naissance_commun,
                            lieu_naissance=data['LieuNaissance'].upper()  if data['LieuNaissance']  else None,
                            lieu_naissance_a=data['LieuNaissanceA'] if data['LieuNaissanceA'] else None,
                            wilaya_naissance=data['WilayaNaissance'] if data['WilayaNaissance'] else None,
                            tel=data['Telephone'] if data['Telephone'] else tel_commun,
                            addresse_principale=data['AdressePrincipale'].upper() if data['AdressePrincipale'] else None,
                            wilaya_residence=data['WilayaResidence'] if data['WilayaResidence'] else None,
                            commune_residence=data['CommuneResidence'] if data['CommuneResidence'] else None,
                            interne= data['Interne'],
                            residence_univ=data['ResidenceU'] if data['ResidenceU'] else None,
                            )
                        etudiant_.save()
                                

                doctorant_=None
                doctorant_qs=Doctorant.objects.filter(Q(etudiant__user__email__iexact=email_)|Q(enseignant__user__email__iexact=email_))
                if doctorant_qs.exists() :
                    doctorant_=doctorant_qs.first()
                
                if not doctorant_ :
                    doctorant_=Doctorant.objects.create(
                     etudiant = etudiant_,
                     enseignant = enseignant_,
                     organisme = data['Organisme'] if data['Organisme'] else None
                     )
                else :
                    doctorant_.etudiant=etudiant_ 
                    doctorant_.enseignant=enseignant_ 
                    doctorant_.organisme= data['Organisme']
                    doctorant_.save()        
                    
                if (not data['User']) and data['Email'] :
                    psw=User.objects.make_random_password()
                    user_.set_password(psw)
                
                if enseignant_ :
                    user_.groups.add(Group.objects.get(name="enseignant"))
                if etudiant_:
                    user_.groups.add(Group.objects.get(name="etudiant"))
                if doctorant_ :
                    user_.groups.add(Group.objects.get(name="doctorant"))
                user_.save()
                
                if (not data['User']) and data['Etudiant'] :                        
                    etudiant_.user=user
                    imagefilename=etudiant_.photo.field.upload_to
                    if default_storage.exists(settings.MEDIA_ROOT+'/'+etudiant_.photo.field.upload_to+'/'+etudiant_.matricule.replace('/','-')+'.jpg'):
                        imagefilename+='/'+etudiant_.matricule.replace('/','-')+'.jpg'
                    else:
                        imagefilename+='/'+'anonymous-user.jpg'
                
                    etudiant_.photo.name=imagefilename
                    etudiant_.save()
                                            
                
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: lors de la création du doctorant. Veuillez le signaler à l'administrateur.")
                    return render(request, 'scolar/doctorant_create.html', {'form': form })
                
            return HttpResponseRedirect(reverse('doctorant_list'))
    # if a GET (or any other method) we'll create a blank form
    else:
        form = DoctorantCreateForm(request)
        messages.info(request, "Utilisez ce formulaire pour créer un nouveau doctorant")
    
    context={}  
    context['form']=form
    return render(request, 'scolar/create.html', context)


@login_required
def doctorant_update_view(request, doctorant_pk):

    if not request.user.has_perm('scolar.fonctionnalite_postgraduation_gestiondoctorants'):
        messages.error(request,"Vous n'avez pas les permissions d'accès à cette opération")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = DoctorantUpdateForm(doctorant_pk, request, request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:
                # process the data in form.cleaned_data as required
                data=form.cleaned_data
                organisme_=data['Organisme']
                doctorant_= get_object_or_404(Doctorant, id=doctorant_pk)                
                doctorant_.organisme=organisme_
                enseignant_=doctorant_.enseignant
                if enseignant_ :
                    enseignant_.organisme=organisme_
                    enseignant_.save()
                doctorant_.save()
                       
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: lors de la modification du doctorant. Veuillez le signaler à l'administrateur.")
                    return render(request, 'scolar/update.html', {'form': form })
                
            return HttpResponseRedirect(reverse('doctorant_list'))
    # if a GET (or any other method) we'll create a blank form
    else:
        form = DoctorantUpdateForm(doctorant_pk, request)
        messages.info(request, "Utilisez ce formulaire pour modifier quelques informations du doctorant. Pour les informations liées à son profil d'étudiant ou à son profil d'enseignant, veuillez contacter une personne ayant les permissons de modifier les informations des enseignants et étudiants.")
    
    context={}  
    context['form']=form
    return render(request, 'scolar/create.html', context)

class DoctorantDeleteView(LoginRequiredMixin, PermissionRequiredMixin, DeleteView):
    model = Doctorant
    template_name = 'scolar/delete.html'
    permission_required = 'scolar.fonctionnalite_postgraduation_gestiondoctorants'

    def delete(self, *args, **kwargs):
        doctorant_=self.get_object()
        trace_create(self.request.user, None, "Suppression du doctorant "+str(doctorant_))
        return super(DoctorantDeleteView, self).delete(*args, **kwargs)
            
    def get_success_url(self):
        messages.success(self.request, "Le doctorant a bien été supprimé!")
        return reverse('doctorant_list')

class SujetsDoctoratListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name = 'scolar/filter_list.html'
    
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalitenav_postgraduation_visualisationsujets')
    
    def get_context_data(self, **kwargs):
        context = super(SujetsDoctoratListView, self).get_context_data(**kwargs)

        #filter_ = PFEFilter(self.request.GET, queryset=PFE.objects.filter(groupe__isnull=True).order_by('id'))
        #todo
        filter_ = TheseFilter(self.request.GET, queryset=These.objects.filter(sujet__isnull=False).exclude(sujet__statut_validation='C').order_by('id'))
        filter_.form.helper = FormHelper()
        exclude_columns_=[]
        if not self.request.user.is_authenticated:
            exclude_columns_.append('expert')
            exclude_columns_.append('edit')
            exclude_columns_.append('admin')
        else :
            if not self.request.user.has_perm('scolar.fonctionnalitenav_postgraduation_gestionsujets'):
                exclude_columns_.append('expert')
                exclude_columns_.append('edit')
                exclude_columns_.append('admin')
        table = TheseTable(filter_.qs, exclude=exclude_columns_)
        RequestConfig(self.request).configure(table)
            
        context['filter'] = filter_
        context['table'] = table
        context['titre'] = 'Liste des sujets de thèse proposés'
        if self.request.user.is_authenticated:
            btn_list={}
            if self.request.user.has_perm('scolar.fonctionnalitenav_postgraduation_gestionsujets'):
                btn_list.update({'Nouveau Sujet':reverse('these_create')})
            
            #todo plus tard, l'importation des anciens sujets de thèse
            '''
            if self.request.user.has_perm('scolar.fonctionnalitenav_postgraduation_gestionsujets') :
                btn_list.update({'Import des sujets de thèse':reverse('import_affectation_pfe')})
            '''
            context['btn_list']=btn_list
        return context
    
    
     
@login_required
def these_create_view(request):

    if request.user.has_perm('scolar.fonctionnalitenav_postgraduation_gestionsujets'):
        pass
    elif request.user.is_enseignant() :
        if request.user.enseignant.is_grade_magistral() :
            pass
        else :
            messages.error(request,"Vous n'avez pas les permissions d'accès à cette opération")
            return redirect('/accounts/login/?next=%s' % request.path)
    else :
        messages.error(request,"Vous n'avez pas les permissions d'accès à cette opération")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = TheseCreateForm(request, request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:
                # process the data in form.cleaned_data as required
                data=form.cleaned_data
                
                sujet_=PFE.objects.create(
                    type='D',
                    intitule=data['intitule'],
                    resume=data['resume'],
                    objectifs=data['objectifs'],
                    resultats_attendus=data['resultats_attendus'],
                    antecedents=data['antecedents'],
                    echeancier=data['echeancier'],
                    bibliographie=data['bibliographie'],
                    statut_validation=data['statut_validation']
                    )
                these_=These.objects.create(
                    sujet=sujet_,
                    directeur=data['directeur'],
                    directeur_externe=data['directeur_externe'],
                    codirecteur=data['codirecteur'],
                    codirecteur_externe=data['codirecteur_externe'],
                    doctorant=data['doctorant'],
                    annee_univ=data['annee_univ'],
                    projet=data['projet']
                    )                            
                
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: lors de la création du sujet de thèse. Veuillez le signaler à l'administrateur.")
                    return render(request, 'scolar/create.html', {'form': form })
            if request.user.has_perm('scolar.fonctionnalitenav_postgraduation_visualisationsujets'):
                return HttpResponseRedirect(reverse('sujets_doctorat_list'))
            elif request.user.is_enseignant() :
                if request.user.enseignant.is_grade_magistral() :
                    return HttpResponseRedirect(reverse('enseignant_sujets_theses_list'))
            return HttpResponseRedirect(reverse('sujets_doctorat_list'))
                    

    # if a GET (or any other method) we'll create a blank form
    else:
        form = TheseCreateForm(request)
        messages.info(request, "Utilisez ce formulaire pour déposer un nouveau sujet de thèse")
    
    context={}  
    context['form']=form
    return render(request, 'scolar/create.html', context)


class TheseDeleteView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, DeleteView):
    model = These
    template_name = 'scolar/delete.html'
    success_message = "La thèse a bien été supprimée."

    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalitenav_postgraduation_gestionsujets')
    
    def get_success_url(self):
        return reverse('sujets_doctorat_list')

    def delete(self, *args, **kwargs):
        these_=self.get_object()
        with transaction.atomic() :
            trace_create(self.request.user, None, "Suppression du sujet de thèse : "+str(these_))
            sujet=PFE.objects.filter(id=these_.sujet.id).delete()
        return super(TheseDeleteView, self).delete(*args, **kwargs)


@login_required
def these_update_view(request, these_pk):
    these_=get_object_or_404(These, id=these_pk)
    pfe_=these_.sujet    
    if request.user.has_perm('scolar.fonctionnalitenav_postgraduation_gestionsujets'):
        pass
    elif pfe_ and (pfe_.statut_validation in ['C', 'S', 'RR', 'N']) and request.user.is_enseignant() :
        if These.objects.filter(id=these_pk).filter(Q(directeur=request.user.enseignant)|Q(codirecteur=request.user.enseignant)).exists() :
            pass
        else :
            messages.error(request,"Vous n'avez pas les permissions d'accès à cette opération")
            return redirect('/accounts/login/?next=%s' % request.path)        
    else :
        messages.error(request,"Vous n'avez pas les permissions d'accès à cette opération")
        return redirect('/accounts/login/?next=%s' % request.path)   
    context={} 
    context['these']=these_
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = TheseUpdateForm(these_pk, request, request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:
                # process the data in form.cleaned_data as required
                data=form.cleaned_data

                pfe_.intitule=data['intitule']
                pfe_.resume=data['resume']
                pfe_.objectifs=data['objectifs']
                pfe_.resultats_attendus=data['resultats_attendus']
                pfe_.antecedents=data['antecedents']
                pfe_.echeancier=data['echeancier']
                pfe_.bibliographie=data['bibliographie']
                pfe_.reponse_aux_experts=data['reponse_aux_experts']
                pfe_.statut_validation=data['statut_validation']       
                pfe_.save()
                    
                these_.directeur=data['directeur']
                these_.directeur_externe=data['directeur_externe']
                these_.codirecteur=data['codirecteur']
                these_.codirecteur_externe=data['codirecteur_externe']
                these_.doctorant=data['doctorant']
                these_.annee_univ=data['annee_univ']  
                these_.projet=data['projet']
                these_.save()
                       
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: lors de la modification du sujet de thèse. Veuillez le signaler à l'administrateur.")
                    return render(request, 'scolar/update.html', {'form': form })
            if request.user.has_perm('scolar.fonctionnalitenav_postgraduation_gestionsujets'):
                return HttpResponseRedirect(reverse('validation_theses_list'))
            elif request.user.has_perm('scolar.fonctionnalitenav_postgraduation_visualisationsujets'):             
                return HttpResponseRedirect(reverse('sujets_doctorat_list'))
            elif request.user.is_enseignant() :
                return HttpResponseRedirect(reverse('enseignant_sujets_theses_list'))
            else :
                return HttpResponseRedirect(reverse('sujets_doctorat_list'))
    # if a GET (or any other method) we'll create a blank form
    else:
        form = TheseUpdateForm(these_pk, request)
        messages.info(request, "Utilisez ce formulaire pour modifier le sujet de thèse")
        
        exclude_columns_=[]
        if (not request.user.has_perm('scolar.fonctionnalitenav_postgraduation_gestionsujets')):
            exclude_columns_.append('expert')
            exclude_columns_.append('edit')
            exclude_columns_.append('admin')
        if request.user.is_etudiant():
            exclude_columns_.append('action')
        if request.user.is_partenaire():
            exclude_columns_.append('action')
    
        
        table = ValidationTable(Validation.objects.filter(pfe=pfe_), exclude=exclude_columns_)
        RequestConfig(request).configure(table)
        context['these_validation_table'] = table
      
    context['form']=form

    return render(request, 'scolar/these_update.html', context)



class TheseDetailView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name = 'scolar/these_detail.html'

    def test_func(self): 
        these_=get_object_or_404(These, id=self.kwargs.get("pk"))   
        permission_=False
        if self.request.user.has_perm('scolar.fonctionnalitenav_postgraduation_visualisationsujets') and these_.sujet.type!='C' :
            permission_ = permission_ | True
        if self.request.user.is_enseignant() :
            permission_= permission_ | These.objects.filter(id=these_.id).filter(Q(directeur=self.request.user.enseignant)|Q(codirecteur=self.request.user.enseignant)|Q(doctorant__enseignant=self.request.user.enseignant)).exists()
        if self.request.user.is_etudiant() and these_.sujet.type!='C' :
            permission_ = permission_ | These.objects.filter(id=these_.id, doctorant__etudiant=self.request.user.etudiant).exists()
        return permission_
        
    def get_context_data(self, **kwargs):
        context = super(TheseDetailView, self).get_context_data(**kwargs)
        titre='Sujet de Thèse N°: '+ self.kwargs.get("pk")
        context['titre'] = titre

        these_=get_object_or_404(These, id=self.kwargs.get("pk"))
        pfe_=these_.sujet
        context['these_form'] = TheseDetailForm(these_pk=these_.id)
        
        exclude_columns_=[]
        if not self.request.user.is_authenticated:
            exclude_columns_.append('expert')
            exclude_columns_.append('action')
            exclude_columns_.append('edit')
            exclude_columns_.append('admin')
        else :
            if (not self.request.user.has_perm('scolar.fonctionnalitenav_postgraduation_gestionsujets')):
                exclude_columns_.append('edit')
                exclude_columns_.append('admin')
                exclude_columns_.append('expert')
            if self.request.user.is_etudiant():
                exclude_columns_.append('action')
            if self.request.user.is_partenaire():
                exclude_columns_.append('action')

        table = ValidationTable(Validation.objects.filter(pfe=pfe_), exclude=exclude_columns_)
        RequestConfig(self.request).configure(table)
        context['these_validation_table'] = table
        
        return context
    
class ValidationThesesListView(LoginRequiredMixin, PermissionRequiredMixin ,TemplateView):
    template_name = 'scolar/validation_theses_list.html'
    permission_required = 'scolar.fonctionnalitenav_postgraduation_gestionsujets'
    
    def get_context_data(self, **kwargs):
        context = super(ValidationThesesListView, self).get_context_data(**kwargs)

        these_controle_table = TheseTable(These.objects.filter(sujet__statut_validation='C').order_by('id'))
        these_controle_nb = These.objects.filter(sujet__statut_validation='C').count()

        these_soumis_table = TheseTable(These.objects.filter(sujet__statut_validation='S').order_by('id'))
        these_soumis_nb = These.objects.filter(sujet__statut_validation='S').count()

        these_attente_validation_table = TheseTable(These.objects.filter(sujet__statut_validation='W').order_by('id'))
        these_attente_validation_nb = These.objects.filter(sujet__statut_validation='W').order_by('id').count()

        these_revision_requise_table = TheseTable(These.objects.filter(sujet__statut_validation='RR').order_by('id'))
        these_revision_requise_nb = These.objects.filter(sujet__statut_validation='RR').order_by('id').count()
        
        these_revision_terminee_table = TheseTable(These.objects.filter(sujet__statut_validation='RT').order_by('id'))
        these_revision_terminee_nb = These.objects.filter(sujet__statut_validation='RT').count()

        these_levee_reserve_table = TheseTable(These.objects.filter(sujet__statut_validation='LR').order_by('id'))
        these_levee_reserve_nb = These.objects.filter(sujet__statut_validation='LR').count()

        these_valide_attribue_table = TheseTable(These.objects.filter(sujet__statut_validation='V', doctorant__isnull=False).distinct().order_by('id'))
        these_valide_attribue_nb = These.objects.filter(sujet__statut_validation='V', doctorant__isnull=False).distinct().count()
        
        these_valide_non_attribue_table = TheseTable(These.objects.filter(sujet__statut_validation='V', doctorant__isnull=True).distinct().order_by('id'))
        these_valide_non_attribue_nb = These.objects.filter(sujet__statut_validation='V', doctorant__isnull=True).distinct().count()

        these_non_valide_table = TheseTable(These.objects.filter(sujet__statut_validation='N').order_by('id'))
        these_non_valide_nb = These.objects.filter(sujet__statut_validation='N').count()
 
        RequestConfig(self.request).configure(these_soumis_table)    
        context['these_controle_table'] = these_controle_table
        context['these_controle_nb'] = these_controle_nb


        context['these_soumis_table'] = these_soumis_table
        context['these_soumis_nb'] = these_soumis_nb

        context['these_attente_validation_table'] = these_attente_validation_table
        context['these_attente_validation_nb'] = these_attente_validation_nb
        
        context['these_revision_requise_table'] = these_revision_requise_table
        context['these_revision_requise_nb'] = these_revision_requise_nb

        context['these_revision_terminee_table'] = these_revision_terminee_table
        context['these_revision_terminee_nb'] = these_revision_terminee_nb

        context['these_levee_reserve_table'] = these_levee_reserve_table
        context['these_levee_reserve_nb'] = these_levee_reserve_nb

        context['these_valide_attribue_table'] = these_valide_attribue_table
        context['these_valide_attribue_nb'] = these_valide_attribue_nb

        context['these_valide_non_attribue_table'] = these_valide_non_attribue_table
        context['these_valide_non_attribue_nb'] = these_valide_non_attribue_nb

        context['these_non_valide_table'] = these_non_valide_table
        context['these_non_valide_nb'] = these_non_valide_nb

        context['titre'] = 'Validation des sujets de thèses'
        return context
    


class EnseignantSujetsThesesListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name = 'scolar/list.html'
    
    def test_func(self):
        return self.request.user.is_enseignant()
    
    def get_context_data(self, **kwargs):
        context = super(EnseignantSujetsThesesListView, self).get_context_data(**kwargs)
        these_table = TheseTable(These.objects.filter(Q(directeur=self.request.user.enseignant)|Q(codirecteur=self.request.user.enseignant)|Q(doctorant__enseignant=self.request.user.enseignant)).order_by('id'), exclude=exclude_columns_enseignant(self.request.user))
        context['table'] = these_table
        context['titre'] = "Mes sujets de Thèses"
        context['btn_list'] = {}
        if self.request.user.enseignant.is_grade_magistral() :
            context['btn_list'] = {
                "Ajouter une proposition de thèse " : reverse("these_create")
                }
        return context
    
class ThesePDFView(LoginRequiredMixin, UserPassesTestMixin, PDFTemplateView):
    template_name = 'scolar/these_fiche_pdf.html'
    cmd_options={
        'orientation':'Portrait',
        'page-size':'A4',
        }
    def test_func(self):
        these_=get_object_or_404(These, id=self.kwargs.get("these_pk"))  
        permission_=False
        if self.request.user.has_perm('scolar.fonctionnalitenav_postgraduation_gestionsujets') :
            permission_ = permission_ | True
        if self.request.user.has_perm('scolar.fonctionnalitenav_postgraduation_visualisationsujets') and these_.sujet.statut_validation!='C' :
            permission_ = permission_ | True
        if self.request.user.is_enseignant() :
            permission_ = permission_ | These.objects.filter(id=these_.id).filter(Q(directeur=self.request.user.enseignant)|Q(codirecteur=self.request.user.enseignant)|Q(doctorant__enseignant=self.request.user.enseignant)).exists()
        if self.request.user.is_etudiant() :
            permission_ = permission_ | These.objects.filter(id=these_.id).filter(doctorant__etudiant=self.request.user.etudiant).exists()
        return True
    
    def get_context_data(self, **kwargs):
        context = super(ThesePDFView, self).get_context_data(**kwargs)
        these_=get_object_or_404(These, id=self.kwargs.get('these_pk'))
        self.filename='FICHE_THESE_'+str(these_.id)+'.pdf'
        
        context['these'] = these_
        context['pfe']=these_.sujet
        context['LISTE_GRADES']=dict(GRADE)
        context['moyens_informatiques']=dict(OPTION_MOYENS)
        context['avis_expert']=dict(OPTIONS_VALIDATION)
        return context
    
class DoctorantSujetTheseListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name = 'scolar/list.html'
    
    def test_func(self):
        return self.request.user.has_object("Doctorant")
    
    def get_context_data(self, **kwargs):
        context = super(DoctorantSujetTheseListView, self).get_context_data(**kwargs)
        doctorant_qs=Doctorant.objects.filter(Q(etudiant__user=self.request.user)|Q(enseignant__user=self.request.user))
        doctorant_=doctorant_qs.first()
        exclude_=[]
        exclude_.append('edit')
        these_table = TheseTable(These.objects.filter(doctorant=doctorant_), exclude=exclude_)
        context['table'] = these_table
        context['titre'] = "Mon sujet de thèse"
        context['btn_list'] = {}
        return context
    

class ProjetCreateView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, CreateView):
    model = Projet
    fields = '__all__'
    template_name = 'scolar/create.html'
    success_message = "Le projet a été créé avec succès"
    
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalite_postgraduation_gestionprojetsrecherche')
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        try:
            form.fields['chef']=forms.ModelChoiceField(
                queryset = Enseignant.objects.all().order_by('nom'),
                widget=ModelSelect2Widget(
                    model=Enseignant,
                    search_fields=['nom__icontains','prenom__icontains'],
                ),
                required=False,
                help_text = "Sélection multiple possible. Tapez le nom ou prénom de l'enseignant ou deux espaces pour avoir la liste complète.",    
            )
            form.fields['membres']=forms.ModelMultipleChoiceField(
                queryset = Enseignant.objects.all().order_by('nom'),
                widget=ModelSelect2MultipleWidget(
                    model=Enseignant,
                    search_fields=['nom__icontains','prenom__icontains'],
                ),
                required=False,
                help_text = "Sélection multiple possible. Tapez le nom ou prénom de l'enseignant ou deux espaces pour avoir la liste complète.",    
            ) 
            form.fields['membres_doctorants']=forms.ModelMultipleChoiceField(
                queryset = Doctorant.objects.all(),
                widget=ModelSelect2MultipleWidget(
                    model=Doctorant,
                    search_fields=['enseignant__nom__icontains', 'etudiant__nom__icontains','enseignant__prenom__icontains', 'etudiant__prenom__icontains'],
                ),
                required=False,
                help_text = "Sélection multiple possible. Tapez le nom ou prénom d'un doctorant ou deux espaces pour avoir la liste complète.",
            )
            form.fields['membres_externes'].widget=forms.Textarea(attrs={'rows':3})
            form.fields['membres_externes'].help_text="Saisissez chaque membre dans une nouvelle ligne"
            form.fields['organisme']=forms.ModelChoiceField(
                queryset = Organisme.objects.filter(interne=True),
                required=False,
            ) 
                     
            form.helper.add_input(Submit('submit','Enregistrer', css_class='btn-primary'))
            form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
            self.success_url = reverse('projet_list')
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors de la création d'un projet.")
    
        return form
    
class ProjetListView(UserPassesTestMixin, TemplateView):
    template_name = 'scolar/filter_list.html'
 
    def test_func(self): 
        return get_institution().activation_public_projets or (self.request.user.is_authenticated and self.request.user.has_perm('scolar.fonctionnalitenav_postgraduation_visualisationprojetsrecherche'))
        
    def get_context_data(self, **kwargs):
        context = super(ProjetListView, self).get_context_data(**kwargs)

        filter_ = ProjetFilter(self.request.GET, queryset=Projet.objects.all().order_by('-annee_debut__annee_univ'))
        
        filter_.form.helper = FormHelper()
        exclude_=[]
        if not (self.request.user.is_authenticated and self.request.user.has_perm('scolar.fonctionnalite_postgraduation_gestionprojetsrecherche')):
            exclude_.append('edit')
            exclude_.append('admin')
        table = ProjetTable(filter_.qs, exclude=exclude_)
        RequestConfig(self.request).configure(table)
            
        context['filter'] = filter_
        context['table'] = table
        context['titre'] = 'Liste des projets de recherche'
        if self.request.user.is_authenticated and self.request.user.has_perm('scolar.fonctionnalite_postgraduation_gestionprojetsrecherche'):
            context['btn_list']={
                    'Ajouter un projet de recherche':reverse('projet_create'),
                }
        return context
      
class ProjetUpdateView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, UpdateView):
    model = Projet
    template_name = 'scolar/update.html'
    success_message = "Le projet a été modifié avec succès!"
    fields='__all__'
    
    def test_func(self):
        projet_ = get_object_or_404(Projet, id=self.kwargs.get('pk'))
        if self.request.user.has_perm('scolar.fonctionnalite_postgraduation_gestionprojetsrecherche') :
            return True
        else :
            return (self.request.user.is_enseignant() and self.request.user.enseignant == projet_.chef)
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        projet_ = get_object_or_404(Projet, id=self.kwargs.get('pk'))
        edit_restreint=False
        if not self.request.user.has_perm('scolar.fonctionnalite_postgraduation_gestionprojetsrecherche') :
            edit_restreint=True
        
        form.fields['chef']=forms.ModelChoiceField(
            queryset = Enseignant.objects.all().order_by('nom'),
            widget=ModelSelect2Widget(
                model=Enseignant,
                search_fields=['nom__icontains','prenom__icontains'],
            ),
            required=False,
            initial = projet_.chef,
            help_text = "Sélection multiple possible. Tapez le nom ou prénom de l'enseignant ou deux espaces pour avoir la liste complète.",
        ) 
        form.fields['membres']=forms.ModelMultipleChoiceField(
            queryset = Enseignant.objects.all().order_by('nom'),
            widget=ModelSelect2MultipleWidget(
                model=Enseignant,
                search_fields=['nom__icontains','prenom__icontains'],
            ),
            required=False,
            initial = projet_.membres.all(),
            help_text = "Sélection multiple possible. Tapez le nom ou prénom de l'enseignant ou deux espaces pour avoir la liste complète.",    
        )
        form.fields['membres_doctorants']=forms.ModelMultipleChoiceField(
            queryset = Doctorant.objects.all(),
            widget=ModelSelect2MultipleWidget(
                model=Doctorant,
                search_fields=['enseignant__nom__icontains', 'etudiant__nom__icontains','enseignant__prenom__icontains', 'etudiant__prenom__icontains'],
            ),
            required=False,
            initial = projet_.membres_doctorants.all(),
            help_text = "Sélection multiple possible. Tapez le nom ou prénom d'un doctorant ou deux espaces pour avoir la liste complète.",
        )
        form.fields['membres_externes'].widget=forms.Textarea(attrs={'rows':3})
        form.fields['membres_externes'].help_text="Saisissez chaque membre dans une nouvelle ligne"
        form.fields['organisme']=forms.ModelChoiceField(
            queryset = Organisme.objects.filter(interne=True),
            required=False,
            initial = projet_.organisme,
        ) 
        form.fields['description'].widget = forms.Textarea(attrs={'rows':20})
   
        if edit_restreint :
            for key_ in form.fields.keys():
                if key_!="description" :
                    form.fields[key_].disabled=True
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        
        if self.request.user.has_perm('scolar.fonctionnalitenav_postgraduation_visualisationprojetsrecherche') :
            self.success_url = reverse('projet_list')
        else :
            self.success_url = reverse('home')
            
        return form

  
class ProjetDeleteView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, DeleteView):
    permission_required = 'scolar.fonctionnalite_postgraduation_gestionprojetsrecherche'
    model = Projet
    template_name = 'scolar/delete.html'
    success_message = "Le projet a bien été supprimé."

    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression du projet : "+str(object_))
        return super(ProjetDeleteView, self).delete(*args, **kwargs)
        
    def get_success_url(self):
        return reverse('projet_list')


class ProjetDetailView(UserPassesTestMixin, TemplateView):
    template_name = 'scolar/form.html'

    def test_func(self): 
        projet_=get_object_or_404(Projet, id=self.kwargs.get("pk"))   
        permission_=False
        if get_institution().activation_public_projets :
            return True
        else :
            if self.request.user.has_perm('scolar.fonctionnalitenav_postgraduation_visualisationprojetsrecherche') :
                permission_ = permission_ | True
            if self.request.user.is_enseignant() :
                permission_= permission_ | Projet.objects.filter(id=projet_.id).filter(Q(chef=self.request.user.enseignant)|Q(membres__in=[self.request.user.enseignant])).exists()
            
        return permission_
        
    def get_context_data(self, **kwargs):
        context = super(ProjetDetailView, self).get_context_data(**kwargs)
        projet_=get_object_or_404(Projet, id=self.kwargs.get("pk"))
        context['form'] = ProjetDetailForm(instance=projet_)
        
        return context


class PreinscriptionDoctoratListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name='scolar/list.html'

    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalitenav_postgraduation_preinscriptions')
    
    def get_queryset(self,**kwargs):
        # Ici il y a eu un retour arrière, l'assistant aura désormais toutes les préinscriptions mais il verra les siennes en premier (pour ne pas avoir à créer plusieurs droits d'accès ou un espace pour l'assistant)
        preinscriptions=Preinscription.objects.none()
        if self.request.user.has_perm('scolar.fonctionnalitenav_postgraduation_preinscriptions') :
            q1=Q(inscription__formation__programme__assistant__user=self.request.user)
            q2=Q(~Q(inscription__formation__programme__assistant__user=self.request.user))
            preinscriptions = Preinscription.objects.filter(q1 | q2).filter(inscription__formation__programme__doctorat=True).annotate(search_type_ordering=Case(When(q1, then=Value(1)),When(q2, then=Value(0)),default=Value(-1),output_field=models.IntegerField())).order_by('-search_type_ordering', '-id')
            #q2=( q1 | Preinscription.objects.filter(~Q(inscription__formation__programme__assistant__user=self.request.user)).order_by('-id')).distinct()
        return preinscriptions
            
    
    def get_context_data(self, **kwargs):
        context = super(PreinscriptionDoctoratListView, self).get_context_data(**kwargs)
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalitenav_postgraduation_preinscriptions'):
            exclude_.append('edit')
            exclude_.append('admin')
        table = PreinscriptionTable(self.get_queryset(**kwargs), exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['table'] = table
        context['titre'] = "Liste des demandes d'inscription en post-graduation"
        context['back'] = reverse('home')
        return context
    
class CritereCreateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, CreateView):
    model = Critere
    fields = '__all__'
    template_name = 'scolar/create.html'
    permission_required = 'scolar.fonctionnalite_postgraduation_gestioncriteres'
    success_message = "Le critère a été créé avec succès"
    
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        try:
            form.fields['programmes']=forms.ModelMultipleChoiceField(
                queryset = Programme.objects.filter(doctorat=True),
                required=False,
            ) 
            form.fields['options'].help_text="Maintenir la touche CTRL enfoncée pour sélectionner plusieurs options"
            form.helper.add_input(Submit('submit','Enregistrer', css_class='btn-primary'))
            form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
            self.success_url = reverse('critere_list')
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors de la création d'un critère.")
    
        return form
    
class CritereUpdateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, UpdateView):
    model = Critere
    template_name = 'scolar/update.html'
    permission_required = 'scolar.fonctionnalite_postgraduation_gestioncriteres'
    success_message = "Le critère a été modifié avec succès!"
    fields='__all__'
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.fields['options'].help_text="Maintenir la touche CTRL enfoncée pour sélectionner plusieurs options"
        form.fields['programmes']=forms.ModelMultipleChoiceField(
            queryset = Programme.objects.filter(doctorat=True),
            required=False,
        ) 
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('critere_list')
        return form

  
class CritereDeleteView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, DeleteView):
    permission_required = 'scolar.fonctionnalite_postgraduation_gestioncriteres'
    model = Critere
    template_name = 'scolar/delete.html'
    success_message = "Le critère a bien été supprimé."

    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression du critère : "+str(object_))
        return super(CritereDeleteView, self).delete(*args, **kwargs)
        
    def get_success_url(self):
        return reverse('critere_list')
    
class CritereListView(LoginRequiredMixin, PermissionRequiredMixin, TemplateView):
    template_name='scolar/list.html'
    permission_required = 'scolar.fonctionnalite_postgraduation_gestioncriteres'
    
    def get_queryset(self,**kwargs):
        return Critere.objects.all().order_by('ordre')
    
    def get_context_data(self, **kwargs):
        context = super(CritereListView, self).get_context_data(**kwargs)
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalite_postgraduation_gestioncriteres'):
            exclude_.append('edit')
        table = CritereTable(self.get_queryset(**kwargs), exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['titre'] = "Liste des critères"
        context['table'] = table
        context['back'] = reverse('formation_doctorat_list')
        btn_list={}
        btn_list['Créer Critère']=reverse('critere_create')
        btn_list['Gérer les options des critères']=reverse('option_critere_list')
        context['btn_list']=btn_list
        
        return context

class OptionCritereCreateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, CreateView):
    model = OptionCritere
    fields = '__all__'
    template_name = 'scolar/create.html'
    permission_required = 'scolar.fonctionnalite_postgraduation_gestioncriteres'
    success_message = "L'option du critère a été créée avec succès"
    
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        try:
            form.helper.add_input(Submit('submit','Enregistrer', css_class='btn-primary'))
            form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
            self.success_url = reverse('option_critere_list')
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors de la création d'une option de critère.")
    
        return form
    
class OptionCritereUpdateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, UpdateView):
    model = OptionCritere
    template_name = 'scolar/update.html'
    permission_required = 'scolar.fonctionnalite_postgraduation_gestioncriteres'
    success_message = "L'option du critère a été modifiée avec succès!"
    fields='__all__'
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()

        form.helper.add_input(Submit('submit','Modifier', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('option_critere_list')
        return form

  
class OptionCritereDeleteView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, DeleteView):
    permission_required = 'scolar.fonctionnalite_postgraduation_gestioncriteres'
    model = OptionCritere
    template_name = 'scolar/delete.html'
    success_message = "L'option a bien été supprimée."

    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression Option Critère : "+str(object_))
        return super(OptionCritereDeleteView, self).delete(*args, **kwargs)
        
    def get_success_url(self):
        return reverse('option_critere_list')
    
class OptionCritereListView(LoginRequiredMixin, PermissionRequiredMixin, TemplateView):
    template_name='scolar/list.html'
    permission_required = 'scolar.fonctionnalite_postgraduation_gestioncriteres'
    
    def get_queryset(self,**kwargs):
        return OptionCritere.objects.all().order_by('ordre')
    
    def get_context_data(self, **kwargs):
        context = super(OptionCritereListView, self).get_context_data(**kwargs)
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalite_postgraduation_gestioncriteres'):
            exclude_.append('edit')
        table = OptionCritereTable(self.get_queryset(**kwargs), exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['titre'] = "Liste des options des critères"
        context['table'] = table
        context['back'] = reverse('critere_list')
        btn_list={}
        btn_list['Créer Option Critère']=reverse('option_critere_create')
        context['btn_list']=btn_list
        
        return context
    
class FormationDoctoratListView(LoginRequiredMixin, PermissionRequiredMixin, TemplateView):
    template_name='scolar/list.html'
    permission_required = 'scolar.fonctionnalitenav_postgraduation_visualisationavancementdoctorants'
    
    def get_queryset(self,**kwargs):
        return Formation.objects.filter(programme__doctorat=True).order_by('-annee_univ__annee_univ')
    
    def get_context_data(self, **kwargs):
        context = super(FormationDoctoratListView, self).get_context_data(**kwargs)
        exclude_=[]
        table = FormationDoctoratTable(self.get_queryset(**kwargs), exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['titre'] = 'Liste des formations de doctorat'
        context['table'] = table
        context['back'] = reverse('home')
        btn_list={}
        if self.request.user.has_perm('scolar.fonctionnalite_postgraduation_gestioncriteres'):
            btn_list['Gestion des critères d\'évaluation des états d\'avancement']=reverse('critere_list')
        context['btn_list']=btn_list
        return context

class EtatAvancementListView(LoginRequiredMixin, PermissionRequiredMixin, TemplateView):
    template_name='scolar/list.html'
    permission_required = 'scolar.fonctionnalitenav_postgraduation_visualisationavancementdoctorants'
    
    def get_queryset(self,**kwargs):
        formation_=get_object_or_404(Formation, id=self.kwargs.get('formation_pk'))
        return Inscription.objects.filter(Q(decision_jury='C')|Q(decision_jury='AJ')|Q(decision_jury='A'), formation__id=self.kwargs.get('formation_pk'), formation__programme__doctorat=True, etudiant__doctorant__isnull=False, etudiant__doctorant__these__isnull=False).order_by('formation__programme__ordre')
    
    def get_context_data(self, **kwargs):
        context = super(EtatAvancementListView, self).get_context_data(**kwargs)
        formation_=get_object_or_404(Formation, id=self.kwargs.get('formation_pk'))
        exclude_=[]
        table = InscriptionDoctoratAvancementTable(self.get_queryset(**kwargs), exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['titre'] = 'Liste des états d\'avancement '+str(formation_)
        context['table'] = table
        context['back'] = reverse('home')
        return context
    
class DoctorantEtatAvancementListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name='scolar/list.html'
    
    def test_func(self):
        return self.request.user.is_etudiant() and self.request.user.etudiant.is_doctorant()
    
    def get_queryset(self,**kwargs):
        return Inscription.objects.filter(Q(decision_jury='C')|Q(decision_jury='AJ')|Q(decision_jury='A'), formation__programme__doctorat=True, etudiant__doctorant__isnull=False, etudiant__doctorant__these__isnull=False, etudiant=self.request.user.etudiant).distinct().order_by('-formation__annee_univ__annee_univ')
    
    def get_context_data(self, **kwargs):
        context = super(DoctorantEtatAvancementListView, self).get_context_data(**kwargs)
        exclude_=[]
        table = InscriptionDoctoratAvancementTable(self.get_queryset(**kwargs), exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['titre'] = 'Liste de mes états d\'avancement '
        context['table'] = table
        context['back'] = reverse('home')
        return context
    
class EnseignantEtatAvancementListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name='scolar/list.html'
    
    def test_func(self):
        return self.request.user.is_enseignant()
    
    def get_queryset(self,**kwargs):
        return Inscription.objects.filter(Q(decision_jury='C')|Q(decision_jury='AJ')|Q(decision_jury='A'), formation__programme__doctorat=True, etudiant__doctorant__isnull=False, etudiant__doctorant__these__isnull=False).filter(Q(etat_avancement__jury__in=[self.request.user.enseignant])|Q(etudiant__doctorant__these__directeur=self.request.user.enseignant)|Q(etudiant__doctorant__these__codirecteur=self.request.user.enseignant)).distinct().order_by('-formation__annee_univ__annee_univ')
    
    def get_context_data(self, **kwargs):
        context = super(EnseignantEtatAvancementListView, self).get_context_data(**kwargs)
        exclude_=[]
        table = InscriptionDoctoratAvancementTable(self.get_queryset(**kwargs), exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['titre'] = 'Liste des états d\'avancement de post-graduation'
        context['table'] = table
        context['back'] = reverse('home')
        return context

@login_required
def etat_avancement_create_view(request, inscription_pk):

    if not request.user.has_perm('scolar.fonctionnalite_postgraduation_gestionavancementdoctorants'):
        messages.error(request,"Vous n'avez pas les permissions d'accès à cette opération")
        return redirect('/accounts/login/?next=%s' % request.path)
    inscription_=get_object_or_404(Inscription, id=inscription_pk)
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = EtatAvancementCreateForm(inscription_.id, request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:
                # process the data in form.cleaned_data as required
                data=form.cleaned_data            
                
                etat_avancement_=EtatAvancement.objects.create(
                    inscription=inscription_)
                if data['jury'] :
                    for membre_jury in data['jury'] :
                        etat_avancement_.jury.add(membre_jury)
                etat_avancement_.save()
                
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: lors de la création de l'évaluation d'état d'avancement. Veuillez le signaler à l'administrateur.")
                    return render(request, 'scolar/create.html', {'form': form })

            return HttpResponseRedirect(reverse('etat_avancement_list', kwargs={'formation_pk':inscription_.formation.id,}))
                    

    # if a GET (or any other method) we'll create a blank form
    else:
        form = EtatAvancementCreateForm(inscription_.id)
        messages.info(request, "Utilisez ce formulaire pour créer une nouvelle évaluation d'état d'avancement")
    
    context={}  
    context['form']=form
    return render(request, 'scolar/create.html', context)

@login_required
def etat_avancement_update_jury_view(request, inscription_pk):

    if not request.user.has_perm('scolar.fonctionnalite_postgraduation_gestionavancementdoctorants'):
        messages.error(request,"Vous n'avez pas les permissions d'accès à cette opération")
        return redirect('/accounts/login/?next=%s' % request.path)
    inscription_=get_object_or_404(Inscription, id=inscription_pk)
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = EtatAvancementUpdateJuryForm(inscription_.id, request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:
                # process the data in form.cleaned_data as required
                data=form.cleaned_data
                etat_avancement_=get_object_or_404(EtatAvancement, inscription=inscription_.id)
                etat_avancement_.jury.clear()
                if data['jury'] :
                    for membre_jury in data['jury'] :
                        etat_avancement_.jury.add(membre_jury)
                etat_avancement_.save()
                
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: lors de la création de l'évaluation d'état d'avancement. Veuillez le signaler à l'administrateur.")
                    return render(request, 'scolar/create.html', {'form': form })

            return HttpResponseRedirect(reverse('etat_avancement_list', kwargs={'formation_pk':inscription_.formation.id,}))
                    

    # if a GET (or any other method) we'll create a blank form
    else:
        form = EtatAvancementUpdateJuryForm(inscription_.id)
        messages.info(request, "Utilisez ce formulaire pour créer une nouvelle évaluation d'état d'avancement")
    
    context={}  
    context['form']=form
    return render(request, 'scolar/create.html', context)

@login_required
def evaluation_etat_avancement_view(request, pk):
    
    generation_pv=False
    
    etat_avancement_=get_object_or_404(EtatAvancement, id=pk)
    
    if request.user.has_perm('scolar.fonctionnalite_postgraduation_gestionavancementdoctorants'):
        pass
    elif (request.user.is_enseignant() and (request.user.enseignant in etat_avancement_.jury.all())) or (request.user.is_enseignant() and request.user.enseignant == etat_avancement_.these().directeur) :
        if etat_avancement_.inscription.formation.archive :
            messages.error(request,"Cette formation est archivée. Pour modifier ses états d'avancement, vous devez avoir des permissions supplémentaires.")
            return HttpResponseRedirect(reverse('enseignant_etat_avancement_list'))
        elif etat_avancement_.final :
            messages.error(request,"Un PV final a déjà été établi.")
            return HttpResponseRedirect(reverse('enseignant_etat_avancement_list'))
    else :
        messages.error(request,"Vous n'avez pas les permissions d'accès à cette opération")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    doctorant_=get_object_or_404(Doctorant, id=etat_avancement_.inscription.etudiant.doctorant.id)
    criteres=Critere.objects.filter(programmes__in=[etat_avancement_.inscription.formation.programme]).order_by('ordre')
    critere_list={}
        
    for critere_ in criteres :
        critere_list[critere_]=[]
        for critere_option_ in critere_.options.all().order_by('ordre') :
            critere_list[critere_].append(critere_option_)
    
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        
        form = EvaluationEtatAvancementForm(pk, generation_pv, request, request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:
                # process the data in form.cleaned_data as required
                data=form.cleaned_data
                
                for critere_, options in critere_list.items() :
                    key_="commentaire_"+str(critere_.id)   
                    
                    evaluation_critere_, created=EvaluationCritere.objects.get_or_create(
                        etat_avancement=etat_avancement_,
                        critere=critere_,
                        )
                    if critere_.commentaire :
                        evaluation_critere_.commentaire=data[key_]
                        
                    for option_critere_ in options :
                        key_="option_"+str(critere_.id)+'_'+str(option_critere_.id)
                        if data[key_] :
                            evaluation_critere_.options.add(option_critere_)
                        else :
                            evaluation_critere_.options.remove(option_critere_)
                    
                    evaluation_critere_.save()      
                    etat_avancement_.avis_directeur=data['avis_directeur']
                    etat_avancement_.final=data['final']
                    etat_avancement_.save()
                
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: lors de l'affichage du formulaire de l'évaluation d'état d'avancement. Veuillez le signaler à l'administrateur.")
                    return render(request, 'scolar/evaluation_etat_avancement.html', {'form': form })
            if request.user.has_perm('scolar.fonctionnalite_postgraduation_gestionavancementdoctorants'):
                return HttpResponseRedirect(reverse('etat_avancement_list', kwargs={'formation_pk':etat_avancement_.inscription.formation.id,}))
            else :
                messages.success(request, "Votre évaluation a été enregistrée")
                return HttpResponseRedirect(reverse('enseignant_etat_avancement_list'))
                    

    # if a GET (or any other method) we'll create a blank form
    else:
        form = EvaluationEtatAvancementForm(pk, generation_pv, request)
        messages.info(request, "Utilisez ce formulaire pour introduire l'évaluation d'état d'avancement")
    
    context={}  
    context['form']=form
    context['critere_list']=critere_list
    return render(request, 'scolar/evaluation_etat_avancement.html', context)


class EvaluationEtatAvancementPDFView(LoginRequiredMixin, UserPassesTestMixin, PDFTemplateView):
    template_name = 'scolar/evaluation_etat_avancement_pdf.html'
    cmd_options={
        'orientation':'Portrait',
        'page-size':'A4',
        }
    def test_func(self):
        etat_avancement_=get_object_or_404(EtatAvancement, id=self.kwargs.get('pk'))
        if not etat_avancement_.final :
            return False
        if self.request.user.has_perm('scolar.fonctionnalitenav_postgraduation_visualisationavancementdoctorants'):
            return True
        if (self.request.user.is_enseignant() and (self.request.user.enseignant in etat_avancement_.jury.all())) or (self.request.user.is_enseignant() and (self.request.user.enseignant == etat_avancement_.these().directeur or self.request.user.enseignant == etat_avancement_.these().codirecteur)) :
            return True
        if (self.request.user.is_etudiant() and self.request.user.is_doctorant()) and (self.request.user.etudiant.doctorant==etat_avancement_.these().doctorant) :
            return True 
        return False
    
    def get_context_data(self, **kwargs):
        context = super(EvaluationEtatAvancementPDFView, self).get_context_data(**kwargs)
        etat_avancement_=get_object_or_404(EtatAvancement, id=self.kwargs.get('pk'))
        generation_pv=True
        
        doctorant_=get_object_or_404(Doctorant, id=etat_avancement_.inscription.etudiant.doctorant.id)
        criteres=Critere.objects.filter(programmes__in=[etat_avancement_.inscription.formation.programme]).order_by('ordre')
        critere_list={}
            
        for critere_ in criteres :
            critere_list[critere_]=[]
            for critere_option_ in critere_.options.all().order_by('ordre') :
                critere_list[critere_].append(critere_option_)       
        
        self.filename=str(etat_avancement_.these().doctorant)+'.pdf'

        form = EvaluationEtatAvancementForm(etat_avancement_.id, generation_pv, self.request)
        context['form']=form
        context['critere_list']=critere_list

        return context
    

class EtatAvancementDecision1UpdateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, UpdateView):

    model = EtatAvancement
    fields = ['decision_1']
    template_name = 'scolar/update.html'
    permission_required = 'scolar.fonctionnalite_postgraduation_decision1'    
    success_message = "La modification de la décision 1 a été effectuée avec succès."
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        etat_avancement_=get_object_or_404(EtatAvancement, id=self.kwargs.get('pk'))
        
        form.helper.add_input(Submit('submit','Enregistrer', css_class='btn-warning'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('etat_avancement_list', kwargs={'formation_pk':etat_avancement_.inscription.formation.id,})
        return form
    

class EtatAvancementDecisionFinaleUpdateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, UpdateView):

    model = EtatAvancement
    fields = ['decision_finale']
    template_name = 'scolar/update.html'
    permission_required = 'scolar.fonctionnalite_postgraduation_decisionsfinales'    
    success_message = "La modification de la décision finale a été effectuée avec succès."
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        etat_avancement_=get_object_or_404(EtatAvancement, id=self.kwargs.get('pk'))
        
        form.helper.add_input(Submit('submit','Enregistrer', css_class='btn-warning'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('etat_avancement_list', kwargs={'formation_pk':etat_avancement_.inscription.formation.id,})
        return form
    
class SeminairesListView(LoginRequiredMixin, PermissionRequiredMixin, TemplateView):
    template_name='scolar/filter_list.html'
    permission_required = 'scolar.fonctionnalitenav_postgraduation_visualisationseminaires'
    
    def get_queryset(self,**kwargs):
        return SeminaireSuivi.objects.all().order_by('-annee_univ__annee_univ')
    
    def get_context_data(self, **kwargs):
        context = super(SeminairesListView, self).get_context_data(**kwargs)
        filter_ = SeminairesFilter(self.request.GET, queryset=self.get_queryset(**kwargs))
        filter_.form.helper = FormHelper()
        exclude_=[]
        table = SeminairesTable(filter_.qs, exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['titre'] = 'Liste des séminaires suivis '
        context['table'] = table
        context['filter'] = filter_
        context['back'] = reverse('home')
        btn_list={}
        if self.request.user.has_perm('scolar.fonctionnalite_postgraduation_gestionseminaires'):
            btn_list['Ajouter un séminaire suivi']=reverse('seminaire_create')
        context['btn_list']=btn_list
        return context   
    
def seminaire_create_view(request):
    if not request.user.has_perm('scolar.fonctionnalite_postgraduation_gestionseminaires'):
        messages.error(request,"Vous n'avez pas les permissions d'accès à cette opération")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    if request.method == 'POST':
        form = SeminaireCreateForm(request.POST)
        if form.is_valid():
            try:
                data=form.cleaned_data  
                if data['matiere'] :
                    matiere_=data['matiere']
                else :
                    matiere_=Matiere.objects.create(
                        code=data['code'],
                        titre=data['titre'],
                        objectifs=data['objectifs'],
                        credit=data['credit'] if data['credit'] else 0,
                        seminaire=True,
                        edition=None,
                        )
                seminaire_=SeminaireSuivi.objects.create(
                   matiere=matiere_,
                   animateur_interne=data['animateur_interne'],
                   animateur_externe=data['animateur_externe'],
                   date=data['date'],
                   annee_univ=data['annee_univ']
                    )
                for doctorant_ in data['doctorants']:
                    if not doctorant_ in seminaire_.inscriptions.all():
                        seminaire_.inscriptions.add(doctorant_)
                seminaire_.save()
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: lors de la création du séminaire suivi. Veuillez le signaler à l'administrateur.")
                    return render(request, 'scolar/create.html', {'form': form })
            return HttpResponseRedirect(reverse('seminaires_list'))
    else:
        form = SeminaireCreateForm()
        messages.info(request, "Utilisez ce formulaire pour créer un nouveau seminaire")
    
    context={}  
    context['form']=form
    return render(request, 'scolar/create.html', context)

class SeminaireDeleteView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, DeleteView):
    permission_required = 'scolar.fonctionnalite_postgraduation_gestionseminaires'
    model = SeminaireSuivi
    template_name = 'scolar/delete.html'
    success_message = "Le séminaire suivi a bien été supprimé."

    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression séminaire suivi : "+str(object_))
        return super(SeminaireDeleteView, self).delete(*args, **kwargs)
        
    def get_success_url(self):
        return reverse('seminaires_list')
 

@login_required
def seminaire_update_view(request, seminaire_pk):
    seminaire_=get_object_or_404(SeminaireSuivi, id=seminaire_pk)
    if not request.user.has_perm('scolar.fonctionnalite_postgraduation_gestionseminaires'):
        messages.error(request,"Vous n'avez pas les permissions d'accès à cette opération")
        return redirect('/accounts/login/?next=%s' % request.path)

    context={} 
    context['seminaire']=seminaire_
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = SeminaireUpdateForm(seminaire_pk, request, request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:
                # process the data in form.cleaned_data as required
                data=form.cleaned_data
                with transaction.atomic() :
                    for doctorant_ in seminaire_.inscriptions.all():
                        seminaire_.inscriptions.remove(doctorant_)
                    for doctorant_ in data['doctorants']:
                        if not doctorant_ in seminaire_.inscriptions.all():
                            seminaire_.inscriptions.add(doctorant_)
                    seminaire_.matiere=data['matiere']
                    seminaire_.animateur_interne=data['animateur_interne']
                    seminaire_.animateur_externe=data['animateur_externe']
                    seminaire_.annee_univ=data['annee_univ']  
                    seminaire_.date=data['date']
                    seminaire_.save()
                       
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: lors de la modification du séminaire suivi. Veuillez le signaler à l'administrateur.")
                    return render(request, 'scolar/update.html', {'form': form })
            
            return HttpResponseRedirect(reverse('seminaires_list'))
    # if a GET (or any other method) we'll create a blank form
    else:
        form = SeminaireUpdateForm(seminaire_pk, request)
        messages.info(request, "Utilisez ce formulaire pour modifier le séminaire suivi")
        
        exclude_columns_=[]
        if (not request.user.has_perm('scolar.fonctionnalitenav_postgraduation_gestionseminaires')):
            exclude_columns_.append('expert')
            exclude_columns_.append('edit')
            exclude_columns_.append('admin')
          
    context['form']=form
    context['object']=seminaire_
    return render(request, 'scolar/update.html', context)


class SeminairesDetailView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name = 'scolar/seminaire_detail.html'

    def test_func(self): 
        seminaire_=get_object_or_404(SeminaireSuivi, id=self.kwargs.get("pk"))   
        permission_=False
        if self.request.user.has_perm('scolar.fonctionnalitenav_postgraduation_visualisationseminaires') :
            permission_ = permission_ | True
        if self.request.user.is_etudiant() :
            permission_ = permission_ | SeminaireSuivi.objects.filter(id=seminaire_.id, inscriptions__etudiant__in=[self.request.user.etudiant]).exists()
            
        return permission_
        
    def get_context_data(self, **kwargs):
        context = super(SeminairesDetailView, self).get_context_data(**kwargs)
        titre='Séminaire suivi N°: '+ self.kwargs.get("pk")
        context['titre'] = titre

        seminaire_=get_object_or_404(SeminaireSuivi, id=self.kwargs.get("pk"))
        
        context['seminaire_form'] = SeminaireDetailForm(seminaire_pk=seminaire_.id)
        
        exclude_columns_=[]
        if not self.request.user.is_authenticated:
            exclude_columns_.append('expert')
            exclude_columns_.append('action')
            exclude_columns_.append('edit')
            exclude_columns_.append('admin')
        else :
            if (not self.request.user.has_perm('scolar.fonctionnalitenav_postgraduation_gestionseminaires')):
                exclude_columns_.append('edit')
                exclude_columns_.append('admin')
                exclude_columns_.append('expert')
                  
        return context
    
class DoctorantSeminairesListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name = 'scolar/list.html'
    
    def test_func(self):
        return self.request.user.is_doctorant()
    
    def get_context_data(self, **kwargs):
        context = super(DoctorantSeminairesListView, self).get_context_data(**kwargs)
        
        if self.request.user.is_etudiant():
            s_table = SeminairesTable(SeminaireSuivi.objects.filter(Q(inscriptions__etudiant__in=[self.request.user.etudiant])).distinct())
        else :
            s_table = SeminairesTable(SeminaireSuivi.objects.none())
        context['table'] = s_table
        context['titre'] = "Mes séminaires suivis"
               
        return context 

class ReleveSeminairesView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name = 'scolar/releve_seminaires.html'
    
    def test_func(self):
        inscription_=Inscription.objects.get(id=self.kwargs.get('inscription_pk'))
        return self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_postgraduation_visualisationdocumentsdoctorants', inscription_.etudiant.matricule) or self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_etudiants_visualisationnotesprofil', inscription_.etudiant.matricule)
    
    def get_context_data(self, **kwargs):
        context = super(ReleveSeminairesView, self).get_context_data(**kwargs)
        inscription_=Inscription.objects.get(id=self.kwargs.get('inscription_pk'))
        seminaires= SeminaireSuivi.objects.filter(inscriptions__in=[inscription_]).distinct()
        context['inscription'] = inscription_
        context['seminaires'] = seminaires
        context['decision_jury'] = dict(DECISIONS_JURY)
        context['date'] = datetime.date.today()
      
        return context

class ReleveSeminairesPDFView(LoginRequiredMixin, UserPassesTestMixin, PDFTemplateView):
    template_name = 'scolar/releve_seminaires_pdf.html'
    cmd_options={
        'orientation':'Landscape',
        'page-size':'A4',

        }
    def test_func(self):
        inscription_=Inscription.objects.get(id=self.kwargs.get('inscription_pk'))
        return self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_postgraduation_visualisationdocumentsdoctorants', inscription_.etudiant.matricule) or self.request.user.has_perm_or_student_himself('scolar.fonctionnalite_postgraduation_visualisationdocumentsnonsignesdoctorants', inscription_.etudiant.matricule)
    
    def get_context_data(self, **kwargs):
        context = super(ReleveSeminairesPDFView, self).get_context_data(**kwargs)
        inscription_=Inscription.objects.get(id=self.kwargs.get('inscription_pk'))
        self.filename=str(inscription_)+'.pdf'
        seminaires= SeminaireSuivi.objects.filter(inscriptions__in=[inscription_]).distinct()
        context['inscription'] = inscription_
        context['seminaires'] = seminaires
        context['decision_jury'] = dict(DECISIONS_JURY)
        context['date'] = datetime.date.today()
        context['pdf']=1
        return context
       
@login_required
def documents_config_update_view(request):

    if not request.user.has_perm('scolar.fonctionnalite_configurationetablissement_modification'):
        messages.error(request,"Vous n'avez pas les permissions d'accès à cette opération")
        return redirect('/accounts/login/?next=%s' % request.path)

    documents_config_table={}
    programme_list=Programme.objects.filter(matiere_equipe__isnull=True).order_by('ordre')
    diplome_list=Diplome.objects.all()
    
    for document in DOCUMENTS :
        if not (document[1][1] in documents_config_table.keys()):
            documents_config_table[document[1][1]]=[]
            
        if (document[1][1]=="Programme") :
            for programme_ in programme_list : 
                if not ((document[0] == "RELEVE_SEMINAIRES") and not programme_.doctorat):
                    document_config, created=DocumentConfig.objects.get_or_create(code=document[0], programme=programme_, defaults={
                        'code':document[0],
                        'programme':programme_
                        })
                    documents_config_table[document[1][1]].append(document_config)
                    
        elif (document[1][1]=="Diplome") :
            for diplome_ in diplome_list :     
                document_config, created=DocumentConfig.objects.get_or_create(code=document[0], diplome=diplome_, defaults={
                    'code':document[0],
                    'diplome':diplome_
                    })
                documents_config_table[document[1][1]].append(document_config)
                
        elif (document[1][1]=="Enseignant") :
            document_config, created=DocumentConfig.objects.get_or_create(code=document[0], defaults={
                'code':document[0],
                })
            documents_config_table[document[1][1]].append(document_config)
    
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = DocumentsConfigUpdateForm(documents_config_table, request, request.POST)
        # check whether it's valid:
        
        if form.is_valid():
            try:
                # process the data in form.cleaned_data as required
                data=form.cleaned_data
                for type, documents_config in documents_config_table.items() :
                    for document_config in documents_config :
                        key_=str(document_config.id)
                        actif=data[key_+'_actif']
                        autorite=data[key_+'_autorite']
                        autorite_entete=data[key_+'_autorite_entete']
                        changed=False
                        if document_config.actif != data[key_+'_actif'] :
                            document_config.actif=data[key_+'_actif']
                            changed=True
                        if document_config.autorite != data[key_+'_autorite'] :
                            document_config.autorite=data[key_+'_autorite']
                            changed = True
                        if document_config.autorite_entete != data[key_+'_autorite_entete'] :
                            document_config.autorite_entete=data[key_+'_autorite_entete']
                            changed = True
                            
                        if changed :
                            document_config.save()
                            
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: lors de l'enregistrement de la configuration des documents. Merci de le signaler à l'administrateur.")
                    return render(request, 'scolar/documents_config_update.html', {'form': form, 'documents_config_table':documents_config_table })
                
            return HttpResponseRedirect(reverse('settings'))
    # if a GET (or any other method) we'll create a blank form
    else:
        form = DocumentsConfigUpdateForm(documents_config_table, request)
        messages.info(request, "Utilisez cette page pour configurer les documents")
            
    context={}
    context['form']=form
    context['documents_config_table']=documents_config_table
    return render(request, 'scolar/documents_config_update.html', context)
 
class PosteCreateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, CreateView):
    model = Poste
    fields = '__all__'
    template_name = 'scolar/create.html'
    permission_required = 'scolar.fonctionnalite_postes_gestion'
    success_message = "Le poste a été créé avec succès"
    
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        try:
            form.fields['organisme']= forms.ModelChoiceField(
                queryset=Organisme.objects.all().order_by('sigle', 'nom'),
                label="Organisme",
                widget=ModelSelect2Widget(
                        model=Organisme,
                        search_fields=['sigle__icontains', 'nom__icontains']
                    ),
                help_text = "Tapez le sigle ou nom de l'organisme.",
                required = True
            )
            
            form.fields['inscription'] = forms.ModelChoiceField(
                    queryset=Inscription.objects.order_by('etudiant__nom', 'etudiant__prenom'),
                    label=u"Etudiant",
                    widget=ModelSelect2Widget(
                            model=Inscription,
                            search_fields=['etudiant__nom__icontains', 'etudiant__prenom__icontains',],
                        ),
                    help_text = "Tapez le nom ou le prénom de l'étudiant.",
                    required = True
                )
            form.helper.add_input(Submit('submit','Enregistrer', css_class='btn-primary'))
            form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
            self.success_url = reverse('poste_list')
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors de la création d'un poste.")
    
        return form
    
class PosteUpdateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, UpdateView):
    model = Poste
    template_name = 'scolar/update.html'
    permission_required = 'scolar.fonctionnalite_postes_gestion'
    success_message = "Le poste a été modifié avec succès!"
    fields='__all__'
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.fields['organisme']= forms.ModelChoiceField(
            queryset=Organisme.objects.all().order_by('sigle', 'nom'),
            label="Organisme",
            widget=ModelSelect2Widget(
                    model=Organisme,
                    search_fields=['sigle__icontains', 'nom__icontains']
                ),
            help_text = "Tapez le sigle ou nom de l'organisme.",
            required = True
        )
        
        form.fields['inscription'] = forms.ModelChoiceField(
                queryset=Inscription.objects.order_by('etudiant__nom', 'etudiant__prenom'),
                label=u"Etudiant",
                widget=ModelSelect2Widget(
                        model=Inscription,
                        search_fields=['etudiant__nom__icontains', 'etudiant__prenom__icontains',],
                    ),
                help_text = "Tapez le nom ou le prénom de l'étudiant.",
                required = True
            )
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('poste_list')
        return form

  
class PosteDeleteView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, DeleteView):
    permission_required = 'scolar.fonctionnalite_postes_gestion'
    model = Poste
    template_name = 'scolar/delete.html'
    success_message = "Le poste a bien été supprimé."
    
    def get_success_url(self):
        return reverse('poste_list')
    
class PosteListView(LoginRequiredMixin, PermissionRequiredMixin, TemplateView):
    template_name='scolar/filter_list.html'
    permission_required = 'scolar.fonctionnalitenav_postes_visualisation'
    
    def get_queryset(self,**kwargs):
        return Poste.objects.all().order_by('-id')
    
    def get_context_data(self, **kwargs):
        context = super(PosteListView, self).get_context_data(**kwargs)
        filter_ = PosteFilter(self.request.GET, queryset=self.get_queryset(**kwargs))
        filter_.form.helper = FormHelper()
        
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalite_postes_gestion'):
            exclude_.append('edit')
        table = PosteTable(filter_.qs, exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['titre'] = "Liste des postes"
        context['table'] = table
        context['back'] = reverse('poste_list')
        context['filter']=filter_
        btn_list={}
        if self.request.user.has_perm('scolar.fonctionnalite_postes_gestion'):        
            btn_list['Créer Poste']=reverse('poste_create')
            btn_list['Importer Postes']=reverse('poste_import')
        context['btn_list']=btn_list
        return context
    
@login_required
def postes_import_view(request):
    if not request.user.has_perm('scolar.fonctionnalite_postes_gestion'):
        return redirect('/accounts/login/?next=%s' % request.path)
    erreurs=""

    # if this is a POST request we need to process the form data
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = ImportAffectationForm(request.POST, request.FILES)
        
        # check whether it's valid:
        if form.is_valid():
            try:
                form_data=form.cleaned_data
                formation_=form_data['formation']
                poste_file = request.FILES['file']
                headers=['Matricule', 'Specialite', 'Organisme', 'NomResponsable', 'PrenomResponsable']
                dataset = Dataset(headers)
                imported_data = dataset.load(poste_file.read(), format ='xlsx')
                # insert imported_data in Enseignant table
                for row in imported_data.dict :
                    try :
                        organisme_=None
                        if row['Organisme'] :
                            organismes_qs=Organisme.objects.filter(interne=True, sigle__iexact=row['Organisme'])
                            if organismes_qs.exists() :
                                organisme_=organismes_qs.first()
                        inscription_=None
                        if row['Matricule'] :
                            etudiant_=Etudiant.objects.get(matricule=str(row['Matricule']).strip())
                            inscription_=Inscription.objects.get(etudiant=etudiant_, formation=formation_)
                        else :
                            erreurs+="Vous devez renseigner le matricule"+'\n'
                        specialite_=None
                        if row['Specialite'] :
                            specialite_=Specialite.objects.get(code=row['Specialite'])
                            
                        responsable_=None
                        responsable_ext_=None
                        if row['NomResponsable'] and row['PrenomResponsable'] :
                            enseignant_qs=Enseignant.objects.filter(nom__iexact=row['NomResponsable'], prenom__iexact=row['PrenomResponsable'])
                            if enseignant_qs.exists() :
                                responsable_=enseignant_qs.first()
                            else :
                                responsable_ext_=row['NomResponsable']+' '+row['PrenomResponsable']
                                
                        poste_=None
                        poste_qs=Poste.objects.filter(inscription=inscription_)
                        if poste_qs.exists() :
                            poste_=poste_qs.first()
                                
                            
                        created=False        
                        if not poste_ :
                            poste_=Poste.objects.create(
                                    inscription=inscription_,
                                    specialite=specialite_ if specialite_ else None,
                                    organisme=organisme_ if organisme_ else None,
                                    responsable=responsable_ if responsable_ else None,
                                    responsable_ext=responsable_ext_ if responsable_ext_ else None
                            )
                            created=True
                        else :
                            poste_.specialite=specialite_ if specialite_ else poste_.specialite
                            poste_.organisme=organisme_ if organisme_ else poste_.organisme
                            poste_.responsable=responsable_ if responsable_ else poste_.responsable
                            poste_.responsable_ext=responsable_ext_ if responsable_ext_ else poste_.responsable_ext
                            poste_.save()
                    except Exception :
                        if row['Matricule'] :
                            erreurs +="Impossible d'insérer le poste du matricule "+str(row['Matricule'])+'\n'
                            
                                       
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: l'importation du fichier des postes s'est arrêtée avec echec.")
                    messages.info(request, mark_safe("La première ligne doit comporter au moins les colonnes suivantes: 'Matricule', 'Specialite', 'Organisme', 'Responsable'"+
                                                    "<br>Matricule : Matricule de l'étudiant<br>"+
                                                    "Organisme : sigle du laboratoire/service/.."+
                                                    "Specialite : Code de la spécialité"+
                                                    "NomResponsable : Nom l'enseignant responsable tel que figuré sur la plateforme s'il est inscrit, sinon un nouveau nom (qui sera enregistré en tant que valeur texte)"+
                                                    "PrenomResponsable : Prénom l'enseignant responsable tel que figuré sur la plateforme s'il est inscrit, sinon un nouveau prénom (qui sera enregistré en tant que valeur texte)"))
                    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer des postes'})
            # redirect to a new URL:
            messages.success(request, "L'importation du fichier des postes'est faite avec succès!")
            if erreurs :
                messages.info(request, erreurs)
            
            return HttpResponseRedirect(reverse('poste_list')) 
    # if a GET (or any other method) we'll create a blank form
    else:
        form = ImportAffectationForm()
        messages.info(request, "Indiquer le fichier .xlsx des postes pour une formation. Le matricule de l'étudiant est obligatoire. Les autres champs peuvent être vides mais les colonnes doivent êtres présentes.")
        messages.info(request, mark_safe("La première ligne doit comporter au moins les colonnes suivantes: 'Matricule', 'Specialite', 'Organisme', 'Responsable'"+
                                               "<br>Matricule : Matricule de l'étudiant<br>"+
                                               "Organisme : sigle du laboratoire/service/.."+
                                               "Specialite : Code de la spécialité"+
                                               "NomResponsable : Nom l'enseignant responsable tel que figuré sur la plateforme s'il est inscrit, sinon un nouveau nom (qui sera enregistré en tant que valeur texte)"+
                                               "PrenomResponsable : Prénom l'enseignant responsable tel que figuré sur la plateforme s'il est inscrit, sinon un nouveau prénom (qui sera enregistré en tant que valeur texte)"))
    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer des postes'})

class ModuleParamsUpdateView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, UpdateView):

    model = Module
    fields = ['activation_max_moy_normale_et_rattrapage', 'ponderation_moy', 'ponderation_moy_rattrapage' ]
    template_name = 'scolar/update.html'
    success_message = "Les paramètres du module ont bien été modifiés."
    def test_func(self):
        module_=get_object_or_404(Module, id=self.kwargs.get('pk'))


        
        if self.request.user.has_perm('scolar.fonctionnalite_pedagogie_gestioncoordination'):
            return True
        elif self.request.user.is_enseignant() :
            #Si la formation est archivée ou si un PV est déjà établit alors ne pas autoriser la modification
            if module_.formation.archive or module_.pv_existe():
                messages.error(self.request, "Il n'est plus possible de modifier les paramètres liés au rattrapage du module car un PV a été établit ou la saisie est clôturée.")
                return False
            else :
                return self.request.user.enseignant == module_.coordinateur
        else:
            return False
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()

        form.helper.add_input(Submit('submit','Modifier', css_class='btn-warning'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('module_detail', kwargs={'pk':self.kwargs.get('pk')})
        return form
    

class ProgrammeDetteListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name='scolar/list.html'

    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalitenav_pedagogie_visualisationdettes')
    
    def get_queryset(self,**kwargs):
        return Programme.objects.filter(cycle__activation_dettes=True).order_by('ordre')
    
    def get_context_data(self, **kwargs):
        context = super(ProgrammeDetteListView, self).get_context_data(**kwargs)
        exclude_=[]
        table = ProgrammeDetteTable(self.get_queryset(**kwargs), exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['titre'] = "Dettes par programmes"
        context['table'] = table
        context['back'] = reverse('home')
        btn_list={}
        context['btn_list']=btn_list
        
        return context

class DetteListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name='scolar/filter_list.html'

    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalitenav_pedagogie_visualisationdettes')
    
    def get_queryset(self,**kwargs):
        return Resultat.objects.filter(dette=True, inscription__formation__programme__id=int(self.kwargs.get('programme_pk'))).order_by('-dette', '-inscription__formation__annee_univ__annee_univ', 'module__matiere__code')
    
    def get_context_data(self, **kwargs):
        context = super(DetteListView, self).get_context_data(**kwargs)
        programme_=get_object_or_404(Programme, id=int(self.kwargs.get('programme_pk')))
        filter_ = DetteFilter(self.request.GET, queryset=self.get_queryset(**kwargs))
        filter_.form.helper = FormHelper()
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalite_pedagogie_gestiondettes'):
            exclude_.append('edit')
        table = DetteTable(filter_.qs, exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['filter'] = filter_
        context['table'] = table
        context['titre'] = "Liste des dettes : "
        context['back'] = reverse('home')
        return context
    
@login_required
def dette_update_view(request, pk):

    if not request.user.has_perm('scolar.fonctionnalite_pedagogie_gestiondettes'):
        messages.error(request,"Vous n'avez pas les permissions d'accès à cette opération")
        return redirect('/accounts/login/?next=%s' % request.path)
    resultat_=get_object_or_404(Resultat, id=int(pk))
    
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = DetteUpdateForm(pk, request, request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:
                # process the data in form.cleaned_data as required
                data=form.cleaned_data
                resultat_.etat_dette=data['etat_dette']
                
                nouveau_resultat_, created=Resultat.objects.get_or_create(inscription=resultat_.inscription, module=data['nouveau_module'], defaults={
                'module':data['nouveau_module'],
                'inscription':resultat_.inscription,
                'ancien_resultat':resultat_
                })
                
                resultat_.resultat_en_cours=nouveau_resultat_
                    
                resultat_.save()
                
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: lors de l'enregistrement des modifications de la dette. Merci de le signaler à l'administrateur.")
                    return render(request, 'scolar/update.html', {'form': form })
                
            return HttpResponseRedirect(reverse('dette_list', kwargs={'programme_pk': resultat_.inscription.formation.programme.id, }))
    # if a GET (or any other method) we'll create a blank form
    else:
        form = DetteUpdateForm(pk, request)
        messages.info(request, "Utilisez ce formulaire pour modifier la dette")
    
    context={}  
    context['object']=resultat_
    context['form']=form
    return render(request, 'scolar/update.html', context)


class ResultatDetteDeleteView(LoginRequiredMixin, UserPassesTestMixin, DeleteView):
    model = Resultat
    template_name = 'scolar/delete.html'
    
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalite_configurationetablissement_modification')
 
    def delete(self, request, *args, **kwargs):
        self.object = self.get_object()
        programme_pk=self.object.module.formation.programme.id
        self.object.delete()
        messages.success(request, "Le résultat a bien été supprimé.")
        return HttpResponseRedirect(reverse('dette_list', kwargs={'programme_pk':programme_pk}))

def get_note_dette_list_context(resultat_list, module_pk):
    context={}
    module_=get_object_or_404(Module, id=module_pk)
    evaluation_list=Evaluation.objects.filter(module=module_)
    note_list={}
    inscription_list=[]
    resultat_list_dict={}
    for resultat_ in resultat_list :
        resultat_list_dict[resultat_.inscription.etudiant.matricule]=resultat_
        if not resultat_.inscription in inscription_list :
            inscription_list.append(resultat_.inscription)
        for eval_ in evaluation_list :
            note_=Note.objects.filter(resultat__inscription=resultat_.inscription, evaluation=eval_)
            if note_.exists() :
                note_=note_.get()
                key_=str(resultat_.inscription)+' '+str(eval_)
                note_list[key_]=note_
    context['module'] = module_
    context['evaluation_list'] = evaluation_list
    context['inscription_list'] = inscription_list
    context['resultat_list']= resultat_list_dict
    context['note_list'] = note_list
    context['decisions_jury'] = dict(DECISIONS_JURY)
    return context

class NoteDetteListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name="scolar/note_list.html"
    
    def test_func(self):
        module_=get_object_or_404(Module, id = self.kwargs.get('module_pk'))
        if self.request.user.has_perm('scolar.fonctionnalitenav_pedagogie_visualisationdettes'):
            return True
        elif self.request.user.is_enseignant():
            return (module_.coordinateur==self.request.user.enseignant)
        else:
            return False
        
    def get_queryset(self, **kwargs):
        module_=get_object_or_404(Module, id = self.kwargs.get('module_pk'))
        return Resultat.objects.filter(module=module_, ancien_resultat__etat_dette='C')


    def get_context_data(self, **kwargs):
        context = super(NoteDetteListView, self).get_context_data(**kwargs)
        try:
            module_=get_object_or_404(Module, id = self.kwargs.get('module_pk'))
            context.update(get_note_dette_list_context(self.get_queryset(**kwargs), module_.id))
            context['decisions_jury']=dict(DECISIONS_JURY)
            messages.info(self.request, "Vous pouvez introduire les notes des étudiants en les saisissant en cliquant sur le bouton Modifier")
            messages.warning(self.request, "Si vous préférez charger les notes à partir d'un fichier Excel, veillez à ce que le fichier ait exactement la structure du fichier téléchargeable ci-après.")
        
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors de la génération du tableau des notes. Merci de le signaler à l'administrateur.")
        return context


@login_required
def note_dette_update(request, module_pk):
    # Il faudra refaire le traitement des données du formuliare pour n'enregistrer
    # que les données ayant changé et pas toutes (form.changed_data) pour éviter des
    # problèmes de performance
    
    module_=get_object_or_404(Module, id = module_pk)
    liste_inscrits=Inscription.objects.filter(resultats__ancien_resultat__isnull=False, resultats__module=module_).order_by('etudiant__nom', 'etudiant__prenom')
    liste_evaluations=Evaluation.objects.filter(module=module_.id)
    resultat_list={}
    for inscrit_ in liste_inscrits :
        resultat_=Resultat.objects.get(ancien_resultat__isnull=False, inscription=inscrit_ ,module=module_)
        resultat_list[inscrit_.etudiant.matricule]=resultat_
    #Si la formation est archivée ou si un PV est déjà établit alors ne pas autoriser la modification
    if request.user.has_perm('scolar.fonctionnalite_pedagogie_gestiondettes'):
            pass
    elif request.user.is_enseignant():
        if module_.coordinateur != request.user.enseignant :
            messages.error(request, "Vous n'êtes pas autorisé à effectuer cette opération")
            return redirect('/accounts/login/?next=%s' % request.path)
    else:
        messages.error(request,"Vous n'avez pas les permissions d'accès à cette page.")
        return redirect('/accounts/login/?next=%s' % request.path)
    # Cette condition permet de tester si on doit utiliser le SMS pour envoie de code secret à usage unique
    sms_=settings.SMS_ENABLED and not request.user.has_perm('scolar.fonctionnalite_pedagogie_gestiondettes')
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = NotesUpdateForm(sms_, 0 , module_.id, request, request.POST)
        # check whether it's valid:
        if form.is_valid():

            if sms_:
                otp_=form.cleaned_data['otp']
            else:
                otp_="-1"
            #Vérifier que l'OTP est correct
            if not sms_ or request.user.enseignant.check_otp(otp_):
                # submit as background task
                t = threading.Thread(target=task_note_dette_update,args=[form, module_, request.user])
                t.setDaemon(True)
                t.start()
                messages.info(request, "Votre demande d'enregistrement des notes de dette a été prise en compte. Une notification vous sera transmise.")
            else:
                messages.error(request, "Le Code Secret saisi est incorrect.")
        # redirect to a new URL:
            return HttpResponseRedirect(reverse('note_dette_list', kwargs={'module_pk': module_.id})) 
    # if a GET (or any other method) we'll create a blank form
    else:
        if sms_ and not request.user.enseignant.tel:
            messages.error(request, "Votre numéro de téléphone n'est pas enregsitré dans la base. Il est nécessaire pour vous envoyer un Mot de passe à Usage Unique.")
            messages.info(request, "Merci de communiquer votre numéro à l'administration afin que vous puissiez saisir les notes.")
            return HttpResponseRedirect(reverse('note_dette_list', kwargs={'module_pk': module_.id}))
        else:
            
            form = NotesUpdateForm(sms_, 0, module_.id, request)
            messages.info(request, "Merci de renseigner les notes des dettes dans le formulaire")
            messages.warning(request, "Si vous ne retrouvez pas les colonnes correspondantes aux évaluations prévues, merci de demander au coordinateur(trice) d'introduire la formule de calcul.")
            return render(request, 'scolar/note_update.html', {'form': form, 'liste_inscrits':liste_inscrits,'liste_evaluations':liste_evaluations,'module_':module_, 'dette':True,
                                                               'sms':sms_,
                                                               'url':settings.SMS_URL,
                                                               'function':'sms_send',
                                                               'apikey':settings.SMS_API_KEY,
                                                               'userkey':settings.SMS_USER_KEY,
                                                               'message':'Talents Code Secret: '+request.user.enseignant.set_otp() if request.user.is_enseignant() else None,
                                                               'message_priority':'Urgent', 
                                                               'to':request.user.enseignant.tel if request.user.is_enseignant() else None,
                                                               'decisions_jury' : dict(DECISIONS_JURY),
                                                               'resultat_list' : resultat_list,
                                                               })


@transaction.atomic
def task_note_dette_update(form, module_, user):
    try:
        # if this is a POST request we need to process the form data
        liste_inscrits=Inscription.objects.filter(resultats__ancien_resultat__isnull=False, resultats__module=module_).order_by('etudiant__nom', 'etudiant__prenom')
        #liste_inscrits=Inscription.objects.filter(groupe=groupe_.id).order_by('etudiant__nom', 'etudiant__prenom')
        liste_evaluations=Evaluation.objects.filter(module=module_.id)
        activation_rattrapage=module_.activation_rattrapage()
        
        # process the data in form.cleaned_data as required
        data=form.cleaned_data
        for inscrit_ in liste_inscrits:
                resultat_=get_object_or_404(Resultat, inscription=inscrit_, module = module_.id)
                if liste_evaluations.exists() and not resultat_.acquis:
                    for eval_ in liste_evaluations :
                        key_=str(inscrit_.etudiant.matricule)+'_'+str(eval_.id)
                        ancienne_note_qs=Note.objects.filter(resultat=resultat_, evaluation=eval_)
                        if ancienne_note_qs.exists() :
                            ancienne_note=ancienne_note_qs.first().note
                        else :
                            ancienne_note=0
                        with transaction.atomic() :
                            note_, created=Note.objects.update_or_create(resultat=resultat_, evaluation=eval_, defaults={
                                    'resultat':resultat_,
                                    'evaluation':eval_,
                                    'note':data[key_]
                                })
                            if ancienne_note != note_.note :
                                trace_create(user, inscrit_.etudiant, "Modification de la note de dette de "+str(eval_)+" de "+str(ancienne_note)+" vers "+str(note_.note))
                else:
                    # ce cas se pose quand on n'a que la moyenne générale du module
                    key_=str(inscrit_.etudiant.matricule)+'_moy'
                    ancienne_moy=resultat_.moy
                    with transaction.atomic() :
                        resultat_.moy=data[key_]
                        resultat_.save(update_fields=['moy'])
                        if ancienne_moy != resultat_.moy :
                            trace_create(user, inscrit_.etudiant, "Modification de la moyenne de dette de "+str(resultat_.module)+" de "+str(ancienne_moy)+" vers "+str(resultat_.moy))    
                    if activation_rattrapage :
                        key_=str(inscrit_.etudiant.matricule)+'_moy_rattrapage'
                        ancienne_moy_rattrapage=resultat_.moy_rattrapage
                        with transaction.atomic() :
                            resultat_.moy_rattrapage=data[key_]
                            resultat_.save(update_fields=['moy_rattrapage'])
                            if ancienne_moy_rattrapage != resultat_.moy_rattrapage :
                                trace_create(user, inscrit_.etudiant, "Modification de la moyenne de rattrapage de dette de "+str(resultat_.module)+" de "+str(ancienne_moy_rattrapage)+" vers "+str(resultat_.moy_rattrapage))
                            
                    if not activation_rattrapage :
                        resultat_.moy_post_delib=resultat_.moy
                    else :
                        if resultat_.module.activation_max_moy_normale_et_rattrapage :
                            resultat_.moy_post_delib=max(resultat_.moy_rattrapage, resultat_.moy)
                        else :
                            resultat_.moy_post_delib=resultat_.module.ponderation_moy_rattrapage*resultat_.moy_rattrapage + resultat_.module.ponderation_moy*resultat_.moy
                    resultat_.save(update_fields=['moy_post_delib'])    
                        
    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            if activation_emails() : 
                email = EmailMessage('[Talents] Erreur lors de l\'enregistrement des notes de dettes'+str(module_),
                                     'Bonjour,\n'+ 
                                     'Une erreur s\'est produite lors de l\'enregistrement des notes de dettes de '+str(module_)+'\n'+
                                     'Demande de modification effectuée via le compte '+user.email+'\n'+
                                     'Veuillez réessayer la saisie et l\'enregistrement \n'+
                                     'Bien cordialement.\n'+
                                     signature_emails(), to=[user.get_email(), module_.formation.programme.get_email_responsable_autorite_cycle()] )
                email.send(fail_silently=True)
    else:
        if activation_emails() : 
            email = EmailMessage('[Talents] Confirmation de l\'enregistrement des notes de dettes de'+str(module_.matiere.code),
                                 'Bonjour,\n'+ 
                                 'L\'enregistrement des notes de dettes de '+str(module_.matiere.code)+' a bien été effectué \n'+
                                 'Modification effectuée via le compte '+user.email+'\n'+
                                 'Nous vous en remercions \n'+
                                 'Bien cordialement.\n'+
                                 signature_emails(), to=[user.get_email(), module_.formation.programme.get_email_responsable_autorite_cycle()] )
            email.send(fail_silently=True)


class UserListView(LoginRequiredMixin, PermissionRequiredMixin, TemplateView):

    template_name = 'scolar/filter_list.html'
    permission_required='scolar.fonctionnalite_configurationetablissement_visualisation'
    
    def get_queryset(self,**kwargs):
        return User.objects.all().order_by('username')
    
    def get_context_data(self, **kwargs):
        context = super(UserListView, self).get_context_data(**kwargs)
        filter_ = UserFilter(self.request.GET, queryset=self.get_queryset(**kwargs))
        filter_.form.helper = FormHelper()
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalite_configurationetablissement_modification'):
            exclude_.append('edit')
        table = UserTable(filter_.qs, exclude=exclude_)
        
        RequestConfig(self.request, paginate={"per_page": 100}).configure(table)
        context['titre'] = 'Liste des utilisateurs'
        context['table'] = table
        context['filter'] = filter_
        btn_list={}
        if self.request.user.has_perm('scolar.fonctionnalite_configurationetablissement_modification'):
            btn_list['+ Créer un utilisateur']=reverse('user_create')
            btn_list['Importer une liste de mots de passes']=reverse('import_passwords')  
            btn_list['Envoi d\'emails à une liste d\'adresses']=reverse('envoi_emails')  
        context['btn_list']=btn_list
        context['back'] = reverse('settings')
        return context
    
class UserCreateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, CreateView):
    permission_required = 'scolar.fonctionnalite_configurationetablissement_modification'
    model = User
    fields = ['username', 'email', 'first_name', 'last_name', 'password']
    template_name = 'scolar/create.html'
    success_message = "L'utilisateur a bien été créé."
     
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.helper.add_input(Submit('submit','Ajouter', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('settings')
        return form

    def get_context_data(self, **kwargs):
        context = super(UserCreateView, self).get_context_data(**kwargs)
        titre='Créer un utilisateur'        
        context['titre']=titre
        return context


@login_required
def user_create_view(request):

    if not request.user.has_perm('scolar.fonctionnalite_configurationetablissement_modification'):
        messages.error(request,"Vous n'avez pas les permissions d'accès à cette opération")
        return redirect('/accounts/login/?next=%s' % request.path)

    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = UserCreateForm(request, request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:
                # process the data in form.cleaned_data as required
                data=form.cleaned_data
                user_= User.objects.create(username=data['username'],
                                    first_name=data['first_name'],
                                    last_name=data['last_name'],
                                    email=data['email'])
                user_.set_password(data['password'])
                user_.save()
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: lors de la création de l'utilisateur. Merci de le signaler à l'administrateur.")
                    return render(request, 'scolar/create.html', {'form': form })
                
            return HttpResponseRedirect(reverse('user_list'))
    # if a GET (or any other method) we'll create a blank form
    else:
        form = UserCreateForm(request)
        messages.info(request, "Utilisez ce formulaire pour créer un utilisateur")
    
    context={}     
    context['form']=form
    return render(request, 'scolar/create.html', context)

@login_required
def user_update_view(request, pk):

    if not request.user.has_perm('scolar.fonctionnalite_configurationetablissement_modification'):
        messages.error(request,"Vous n'avez pas les permissions d'accès à cette opération")
        return redirect('/accounts/login/?next=%s' % request.path)
    user_=get_object_or_404(User, id=pk)
    
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = UserUpdateForm(pk, request, request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:
                # process the data in form.cleaned_data as required
                data=form.cleaned_data   
                user_.username=data['username']
                user_.first_name=data['first_name']
                user_.last_name=data['last_name']
                user_.email=data['email']
                if data['password'] :
                    user_.set_password(data['password'])
                user_.save()
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: lors de la modification de l'utilisateur. Merci de le signaler à l'administrateur.")
                    return render(request, 'scolar/update.html', {'form': form })
                
            return HttpResponseRedirect(reverse('user_list'))
    # if a GET (or any other method) we'll create a blank form
    else:
        form = UserUpdateForm(pk, request)
        messages.info(request, "Utilisez ce formulaire pour modifier l'utilisateur")
    
    context={}  
    context['object']=user_     
    context['form']=form
    return render(request, 'scolar/update.html', context)

    
class UserDeleteView(LoginRequiredMixin, PermissionRequiredMixin, DeleteView):
    model = User
    template_name = 'scolar/delete.html'
    permission_required = 'scolar.fonctionnalite_configurationetablissement_modification'
    def get_context_data(self, **kwargs):
        context = super(UserDeleteView, self).get_context_data(**kwargs)
        context['user']=self.request.user
        return context

    def delete(self, *args, **kwargs):
        user_=self.get_object()
        trace_create(self.request.user, user_, "Suppression de l'utilisateur "+str(user_))
        return super(UserDeleteView, self).delete(*args, **kwargs)
            
    def get_success_url(self):
        messages.success(self.request, "L'utilisateur a bien été supprimé!")
        return reverse('user_list')

@login_required   
def import_passwords(request):
    if request.user.has_perm('scolar.fonctionnalite_configurationetablissement_modification') :
        pass
    else :
        messages.error(request, "Vous n'avez pas la permission d'accéder à cette opération." )
        return redirect('/accounts/login/?next=%s' % request.path)
  
    if request.method == 'POST':
        form = ImportFileForm(request.POST, request.FILES)
        # check whether it's valid:
        if form.is_valid():
            try:    
                passwords_file = request.FILES['file']
                dataset = Dataset()
                imported_data = dataset.load(passwords_file.read(), format ='xlsx')
                form_data=form.cleaned_data
                non_importes=[]
                for row in imported_data.dict :
                    try :
                        user_=User.objects.get(username__iexact=row.get('User'), username__isnull=False)
                        password_= row.get('Password')
                        if password_ :
                            user_.set_password(password_)
                            user_.save()
                        else :
                            non_importes.append(row.get('User')+" (Mot de passe vide)") 
                    except User.DoesNotExist as e :
                        non_importes.append(row.get('User')+" (Inexistant)")            
                
                if non_importes :
                    messages.info(request, "Mots de passes non importés pour : "+str(non_importes))
                
                messages.success(request, "Les mots de passes ont été importés ou mis à jour avec succès.")    
            except Exception as e:
                if settings.DEBUG:
                    raise e
                else:
                    messages.error(request, "ERREUR: L'importation des mots de passes n'a pas réussi. Le fichier est peut être mal formé!" )
                    messages.info(request, "Indiquer le fichier .xlsx des mots de passes associés aux noms d'utilisateurs")
                    messages.info(request, "La première ligne du fichier doit comporter au moins colonnes suivantes: User, Password ")
                    messages.info(request, "La colonne User correspond au nom d'utilisateur. La colonne Password correspond au nouveau mot de passe. Si le mot de passe est un champs vide il ne sera pas pris en considération.")
                    render(request, 'scolar/import.html', {'form': form, 'titre':'Importer les mots de passes'})
            # redirect to a new URL:
            return HttpResponseRedirect(reverse('user_list'))
    # if a GET (or any other method) we'll create a blank form
    else:
        form = ImportFileForm()
        messages.info(request, "Indiquer le fichier .xlsx des mots de passes associés aux noms d'utilisateurs")
        messages.info(request, "La première ligne du fichier doit comporter au moins colonnes suivantes: User, Password ")
        messages.info(request, "La colonne User correspond au nom d'utilisateur. La colonne Password correspond au nouveau mot de passe. Si le mot de passe est un champs vide il ne sera pas pris en considération.")
    
    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer les mots de passes'})

@login_required   
def envoi_emails(request):
    if request.user.has_perm('scolar.fonctionnalite_configurationetablissement_modification') and activation_emails() :
        pass
    else :
        messages.error(request, "Vous n'avez pas la permission d'accéder à cette opération." )
        return redirect('/accounts/login/?next=%s' % request.path)
  
  
    if request.method == 'POST':
        form = ImportFileForm(request.POST, request.FILES)
        # check whether it's valid:
        if form.is_valid():
            try:    
                emails_file = request.FILES['file']
                dataset = Dataset(headers=['Adresse','Objet', 'Contenu',])
                imported_data = dataset.load(emails_file.read(), format ='xlsx')
                t = threading.Thread(target=task_envoi_emails,args=[imported_data, request.user])
                t.setDaemon(True)
                t.start()
                messages.success(request, "Les e-mails sont en cours de transmission.")    
            except Exception as e:
                if settings.DEBUG:
                    raise e
                else:
                    messages.error(request, "ERREUR lors de l'envoi des e-mails. Le fichier est peut être mal formé ou il y a un soucis avec le système de mailing !" )
                    messages.info(request, "Indiquer le fichier .xlsx des mails à envoyer à une liste d'adresses e-mail")
                    messages.info(request, "La première ligne du fichier doit comporter au moins les colonnes suivantes: Adresse, Objet, Contenu ")
                    render(request, 'scolar/import.html', {'form': form, 'titre':'Envoi d\'emails à une liste d\'adresses'})
            # redirect to a new URL:
            return HttpResponseRedirect(reverse('user_list'))
    # if a GET (or any other method) we'll create a blank form
    else:
        form = ImportFileForm()
        messages.info(request, "Indiquer le fichier .xlsx des mails à envoyer à une liste d'adresses e-mail")
        messages.info(request, "La première ligne du fichier doit comporter au moins colonnes suivantes: Adresse, Objet, Contenu ")
    return render(request, 'scolar/import.html', {'form': form, 'titre':'Envoi d\'emails à une liste d\'adresses'})


def task_envoi_emails(imported_data, user):
    try:
        for row in imported_data.dict :
            adresse=row['Adresse']
            objet=row['Objet'] if row['Objet'] else ''
            contenu=row['Contenu'] if row['Contenu'] else ''
            email = EmailMessage(objet, contenu, to=[adresse])
            email.send(fail_silently=True)
            sleep(1)

    except Exception:
        if settings.DEBUG:
            raise Exception
        else:
            if activation_emails():
                email = EmailMessage('[Talents] Erreur lors de l\'envoi des emails',
                                     'Bonjour,\n'+ 
                                     'Une erreur s\'est produite en cours de la transmission des e-mails aux adresses indiquées'+
                                     'Bien cordialement.\n'+
                                     signature_emails(), to=[user.get_email()] )
                email.send(fail_silently=True)



def media_access(request, path):
    request_image_path="photos/"+path 
    access_granted = False
    user = request.user

    if path == "anonymous-user.jpg" or (user.is_authenticated and user.has_perm('scolar.fonctionnalitenav_etudiants_annuairecomplet') and user.has_perm('scolar.fonctionnalitenav_enseignants_annuairecomplet')) :
        access_granted = True
    
    if not access_granted : 
        try :
            etudiant_=get_object_or_404(Etudiant, photo=request_image_path)
            if etudiant_.public_profile or (user.is_authenticated and user.has_perm_or_student_himself('scolar.fonctionnalitenav_etudiants_annuairecomplet', etudiant_.matricule)) or etudiant_.acces_profil_candidature(request.user):
                access_granted = True
            elif etudiant_.is_doctorant() and user.has_perm('scolar.fonctionnalitenav_postgraduation_visualisationdoctorants'):
                access_granted = True
        except Exception :
            pass
        
    if not access_granted : 
        try :        
            enseignant_=get_object_or_404(Enseignant, photo=request_image_path)
            if enseignant_.public_profile or (user.is_authenticated and user.has_perm_or_teacher_himself('scolar.fonctionnalitenav_enseignants_annuairecomplet', enseignant_.id)) or enseignant_.acces_profil_candidature(request.user):
                access_granted = True
            elif enseignant_.is_doctorant() and user.has_perm('scolar.fonctionnalitenav_postgraduation_visualisationdoctorants'):
                access_granted = True
        except Exception :
            pass
    
    if access_granted :
        try :
            if not settings.DEV_MODE :
                response = HttpResponse()
                response['X-Accel-Redirect']="/protected/media/photos/"+path #uniquement pour servir les photos avec Nginx
                
                guessed_mimetype, guessed_encoding = guess_type(settings.MEDIA_ROOT+'/'+request_image_path)
                if guessed_mimetype:
                    mimetype = guessed_mimetype
                else:
                    mimetype = 'application/octet-stream'
                    
                response['Content-length'] = os.path.getsize(settings.MEDIA_ROOT+'/'+request_image_path)
                response['Content-Type'] = mimetype
                encoding = guessed_encoding
                if encoding:
                    response['Content-Encoding'] = encoding
            else :
                dirname = os.path.dirname(settings.MEDIA_ROOT+'/'+request_image_path)
                basename = os.path.basename(settings.MEDIA_ROOT+'/'+request_image_path)
                response = serve(request, basename, dirname)
                
            if response :
                return response
            else :
                return HttpResponseForbidden('/')
        except Exception :
            return HttpResponseForbidden("Erreur d'accès à l'image")
            
    else:
        return HttpResponseForbidden('Accès non autorisé.')
 

def quittances_access(request, path):
    request_image_path="quittances/"+path 
    access_granted = False
    user = request.user

    if user.is_authenticated and (user.has_perm('fonctionnalitenav_etudiants_preinscriptions') or user.has_perm('fonctionnalitenav_postgraduation_preinscriptions')) :
        access_granted = True

    
    if access_granted :
        try :
            if not settings.DEV_MODE :
                response = HttpResponse()
                response['X-Accel-Redirect']="/protected/media/quittances/"+path #uniquement pour servir les quittances avec Nginx
                
                guessed_mimetype, guessed_encoding = guess_type(settings.MEDIA_ROOT+'/'+request_image_path)
                if guessed_mimetype:
                    mimetype = guessed_mimetype
                else:
                    mimetype = 'application/octet-stream'
                    
                response['Content-length'] = os.path.getsize(settings.MEDIA_ROOT+'/'+request_image_path)
                response['Content-Type'] = mimetype
                encoding = guessed_encoding
                if encoding:
                    response['Content-Encoding'] = encoding
            else :
                dirname = os.path.dirname(settings.MEDIA_ROOT+'/'+request_image_path)
                basename = os.path.basename(settings.MEDIA_ROOT+'/'+request_image_path)
                response = serve(request, basename, dirname)
                
            if response :
                return response
            else :
                return HttpResponseForbidden('/')
        except Exception as e:
            return HttpResponseForbidden("Erreur d'accès à l'image")
            
    else:
        return HttpResponseForbidden('Accès non autorisé.')
     
    
@login_required
def lettre_recommandation_form_view(request, etudiant_pk):
    if not request.user.is_enseignant():
        messages.error(request,"Vous n'avez pas les permissions d'accès")
        return redirect('index')
    etudiant_=get_object_or_404(Etudiant, matricule=etudiant_pk)
    if activation_ddc() :
        profile_chart=ProfileChart(etudiant_pk)
    context={}
    enseignant_ = get_object_or_404(Enseignant, id=request.user.enseignant.id)
    activite_list = Activite.objects.filter(Q(assuree_par=enseignant_)&(Q(type='C')|Q(type='TD')|Q(type='TP')|Q(type='P'))).distinct()
    groupes_etudiant=Groupe.objects.filter(Q(inscrits_periode__inscription__etudiant=etudiant_))
    
    groupes_etudiant_avec_sections=[]
    for groupe_ in groupes_etudiant :
        if not groupe_ in groupes_etudiant_avec_sections :
            groupes_etudiant_avec_sections.append(groupe_)
    
    for groupe_ in groupes_etudiant :
        if groupe_.section :
            groupe_section_qs=Groupe.objects.filter(code__isnull=True, section=groupe_.section)
            if groupe_section_qs.exists() :
                groupe_section=groupe_section_qs.first()
                if not groupe_section in groupes_etudiant_avec_sections :
                    groupes_etudiant_avec_sections.append(groupe_section)
    
    module_list = list(map(lambda x : x.module , activite_list))
    resultat = Resultat.objects.filter(inscription__etudiant__matricule = etudiant_pk , module__in = module_list)
    for act in resultat:
        act.nabsences = AbsenceEtudiant.objects.filter(etudiant=etudiant_, seance__activite__module=act.module).count()
    context['resultat'] = resultat
    #module_enseignant_etudiant = []
    #for module in module_list:
        #if etudiant_pk in list(map(lambda x : x.etudiant.matricule , module.inscrits_activite())) : module_enseignant_etudiant.append(module)
    #context['list'] = module_enseignant_etudiant
    context['module'] = activite_list
    context['matricule'] = request.user.enseignant.id
    if activation_ddc() :
        context['profile_chart']=profile_chart
    context['object'] = etudiant_
    context['parcours'] = InscriptionEtudiantTable(Inscription.objects.filter(etudiant=etudiant_).order_by('formation__annee_univ'))
    messages.info(request, "La lettre générée au format Word est compatible avec Microsoft Office, l'affichage peut ne pas se faire correctement avec un autre outil.")
    return render(request, 'scolar/lettre_recommandation_form.html', context)

@login_required
def lettre_recommandation_pdf_view(request, etudiant_pk):
    if not request.user.is_enseignant():
        messages.error(request,"Vous n'avez pas les permissions d'accès")
        return redirect('index')
    context={}
    etudiant_=get_object_or_404(Etudiant, matricule=etudiant_pk)
    context['object'] = etudiant_
    context['date'] = datetime.datetime.now().date().strftime('%d/%m/%Y')
    context['enseignant'] = request.user
    context['institution']=request.user.institution()
    context['matricule'] = request.user.enseignant.id
    context['motif'] = request.POST['motif']
    context['texte'] = request.POST['textLettre']
    context['critereList'] = request.POST.getlist('critere[]')
    context['competenceList'] = request.POST.getlist('competence[]')
    prc = request.POST.getlist('prc[]')
    context['parcours'] =  zip(prc[0::3], prc[1::3],prc[2::3])
    competenceMatrixDict = {}
    for critere in context['critereList']:
        evalu = request.POST[critere]
        if (evalu != "Non spécifié"):
            competenceMatrixDict[critere] = evalu
    context['matrix'] = competenceMatrixDict
    if activation_ddc() :
        context['profile_chart'] = request.POST['imageDataUrlForm']
    #return render(request, 'scolar/Lettre_Recommendation_pdf.html', context)
    template_name = 'scolar/lettre_recommandation_pdf.html'
    filename='lettre_recommandation.pdf'
    cmd_options={ 'orientation':'Portrait', 'page-size':'A4' }
    pdf_=render_pdf_from_template(template_name, header_template=None, footer_template=None, context=context, cmd_options=cmd_options, request=request)
    response = HttpResponse(pdf_,content_type='application/pdf')
    response['Content-Disposition'] = 'attachment; filename="lettre_recommandation.pdf"'
    return response

@login_required
def lettre_recommandation_word_view(request, etudiant_pk):
    if not request.user.is_enseignant():
        messages.error(request,"Vous n'avez pas les permissions d'accès")
        return redirect('index')
    etudiant_=get_object_or_404(Etudiant, matricule=etudiant_pk)
    critere = request.POST.getlist('critere[]')
    prc = request.POST.getlist('prc[]')
    document = Document()
    if activation_ddc() :
        tmp_img_file = tempfile.NamedTemporaryFile(delete=None, suffix='.jpg')
        img_blob = pybase64.urlsafe_b64decode(request.POST['imageDataUrlForm'])
        tmp_img_file.write(img_blob)
        
    if etudiant_.photo :
        tmp_photoprofil_file = tempfile.NamedTemporaryFile(delete=None, suffix='.jpg')
        img_blob = pybase64.urlsafe_b64decode(request.POST['imagePhotoProfilDataUrlForm'])
        tmp_photoprofil_file.write(img_blob)    
    
    table = document.add_table(rows=2, cols=3)
    
    entete_cells = table.rows[0].cells
    e1 = table.cell(0, 0)
    e2 = table.cell(0, 1)
    e3 = table.cell(0, 2)
    entete_row = e1.merge(e2).merge(e3)
    paragraph_entete = entete_row.paragraphs[0]
    paragraph_entete.alignment = (WD_PARAGRAPH_ALIGNMENT).CENTER
    run_entete=paragraph_entete.add_run()
    if request.user.institution().header :
        run_entete.add_picture(request.user.institution().header, width=Inches(7))
    
    hdr_cells = table.rows[1].cells
    a = table.cell(1, 0)
    b = table.cell(1, 1)
    A = a.merge(b)
    paragraph2 = A.paragraphs[0]
    run2 = paragraph2.add_run()
    run2.add_text("De  "+request.user.nom() + "    " + request.user.prenom())
    run2.add_break()
    run2.add_text(str(request.user.institution()))
    run2.add_break()
    if request.user.institution().ville :
        zone=request.user.institution().ville
        if request.user.institution().wilaya_institution :
            zone=zone+" - "+request.user.institution().wilaya_institution.nom
        run2.add_text(zone)
        run2.add_break()
    run2.add_text(request.user.get_email())
    run2.add_break()
    run2.add_text("Le "+datetime.datetime.now().date().strftime('%d/%m/%Y'))
    run2.add_break()
    #run2.add_text("A "+request.POST['motif'])
    run2.add_break()
    run2.add_break()
    run3 = paragraph2.add_run()
    run3.bold = True
    run3.add_text("Objet : Lettre de recommandation pour "+etudiant_.prenom +"    "+etudiant_.nom)
    run3.add_break()
    run3.add_break()
    paragraphtexte=A.add_paragraph()
    paragraphtexte.alignment=(WD_PARAGRAPH_ALIGNMENT).JUSTIFY
    run4 = paragraphtexte.add_run()
    run4.add_text(text=request.POST['textLettre'])
    paragraph = hdr_cells[2].paragraphs[0]
    paragraph.alignment = 1
    run = paragraph.add_run()
    if etudiant_.photo :
        try :
            run.add_picture(tmp_photoprofil_file, width = Inches(1.8))
        except Exception :
            pass
    run.add_break()
    if activation_ddc() :
        run.add_picture(tmp_img_file, width = Inches(3.3), height = Inches(2))
    filtered = list(filter(lambda ctr: request.POST[ctr] != "Non spécifié", critere))
    if(len(filtered) > 0 ):
        table2 =hdr_cells[2].add_table(rows = 1,cols = 2)
        table2.style = 'TableGrid'
        table2.alignment = 1
        header = table2.rows[0].cells
        header[0].text = "Compétence"
        header[1].text = "Evaluation"
        for critere in filtered:
            row = table2.add_row().cells
            row[0].text = critere
            row[1].text = request.POST[critere]
        run.add_break()
    if(len(prc) > 0 ):
        table3 =hdr_cells[2].add_table(rows = 1,cols = 3)
        table3.style = 'TableGrid'
        table3.alignment = 1
        header = table3.rows[0].cells
        header[0].text = "Formation"
        header[1].text = "Moyenne"
        header[2].text = "Classement"
        for formation,moyenne,classement in zip(prc[0::3], prc[1::3],prc[2::3]):
            row = table3.add_row().cells
            row[0].text = formation
            row[1].text = moyenne
            row[2].text = classement
    paragraph3 = A.add_paragraph()
    paragraph3.alignment = (WD_PARAGRAPH_ALIGNMENT).CENTER
    run7 = paragraph3.add_run()
    run7.add_break()
    run7.add_break()
    run8= paragraph3.add_run("Signature")
    run8.bold = True
    sections = document.sections
    for section in sections:
        section.right_margin = 0
        section.left_margin = 600000
    if activation_ddc() :
        tmp_img_file.close()

    if etudiant_.photo :
        tmp_photoprofil_file.close()
    response = HttpResponse(content_type='application/vnd.openxmlformats-officedocument.wordprocessingml.document')
    response['Content-Disposition'] = 'attachment; filename=lettre_recommandation_'+etudiant_.nom +"_"+etudiant_.prenom+'.docx'
    document.save(response)
    return response


@login_required
def mon_compte_update_view(request):

    user_=request.user
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = PasswordUpdateForm(user_, request, request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:
                # process the data in form.cleaned_data as required
                data=form.cleaned_data
                password_=data['password']
                if not password_ :
                    messages.error(request, "Le nouveau mot de passe ne doit pas être vide")
                else :
                    user_.set_password(password_)
                    user_.save()
                    update_session_auth_hash(request, user_)
                    trace_create(user_, user_, "Votre mot de passe a bien été modifié à votre demande. Si vous n'êtes pas à l'origine de cette modification, veuillez modifier votre mot de passe ainsi que signaler l'incident.")
                    messages.success(request, "Votre mot de passe a été modifié avec succès")
                    if activation_emails():
                        email_context = {
                            "template" : "mot_de_passe_modifie.html",
                            "objet" : "[Talents] Mot de passe modifié",
                            "nom" : user_.nom,
                            "destinataires" : [user_.get_email()]
                        }
                        send_email(email_context) 
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: lors de l'enregistrement des modifications du compte. Merci de le signaler à l'administrateur.")
                    return render(request, 'scolar/import.html', {'form': form })
                
            return HttpResponseRedirect(reverse('mon_compte'))
    # if a GET (or any other method) we'll create a blank form
    else:
        form = PasswordUpdateForm(user_, request)
    
    
    context={}  
    context['titre']=format_html("Modification du mot de passe<br><br><br>Votre nom d'utilisateur : <strong>"+user_.username+"</strong><br><br>Votre adresse e-mail : <strong>"+user_.get_email())
    context['form']=form
    return render(request, 'scolar/import.html', context)


class PersonnelCreateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, CreateView):
    model = Personnel
    fields = '__all__'
    template_name = 'scolar/create.html'
    permission_required='scolar.fonctionnalite_configurationetablissement_modification'
    success_message = "Le membre du personnel été créé avec succès!"
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.fields['user']=forms.ModelChoiceField(
                queryset=User.objects.filter(Q(personnel__isnull=True)).order_by('username'),
                label=u"Utilisateur de la plateforme",
                widget=ModelSelect2Widget(
                        model=User,
                        search_fields=['username__icontains', 'email__icontains'],
    
                    ),
                help_text = "Tapez le nom d'utilisateur ou une partie du nom d'utilisateur pour faire une recherche",
                required = False
            )
     
        form.helper.add_input(Submit('submit','Créer', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('personnel_list')
        return form
    
class PersonnelUpdateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, UpdateView):
    model = Personnel
    fields = ['user', 'nom','eps', 'prenom', 'nom_a', 'eps_a', 'prenom_a', 'sexe', 'tel', 'bureau',]
    template_name = 'scolar/update.html'
    permission_required='scolar.fonctionnalite_configurationetablissement_modification'
    success_message = "Le membre du personnel a été modifié avec succès!"
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        personnel_ = get_object_or_404(Personnel, id=self.kwargs.get("pk"))  
        form.fields['user']=forms.ModelChoiceField(
                queryset=User.objects.filter(Q(personnel__id=personnel_.id) | Q(personnel__isnull=True)).order_by('username'),
                label=u"Utilisateur de la plateforme",
                widget=ModelSelect2Widget(
                        model=User,
                        search_fields=['username__icontains', 'email__icontains'],
    
                    ),
                help_text = "Tapez le nom d'utilisateur ou une partie du nom d'utilisateur pour faire une recherche",
                required = False,
                initial=personnel_.user
            )
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('personnel_list')
        return form

class PersonnelDeleteView(LoginRequiredMixin, PermissionRequiredMixin, DeleteView):
    model = Personnel
    template_name = 'scolar/delete.html'
    permission_required = 'scolar.fonctionnalite_configurationetablissement_modification'

    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression Personnel : "+str(object_))
        return super(PersonnelDeleteView, self).delete(*args, **kwargs)
        
    def get_success_url(self):
        messages.success(self.request, "Le personnel a bien été supprimé!")
        return reverse('personnel_list')

class PersonnelListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name='scolar/list.html'

    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalite_configurationetablissement_visualisation')
    
    def get_queryset(self,**kwargs):
        return Personnel.objects.all().order_by('nom', 'prenom')
    
    def get_context_data(self, **kwargs):
        context = super(PersonnelListView, self).get_context_data(**kwargs)
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalite_configurationetablissement_modification'):
            exclude_.append('edit')
        table = PersonnelTable(self.get_queryset(**kwargs), exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['titre'] = "Liste des membres du personnel"
        context['table'] = table
        context['back'] = reverse('settings')
        btn_list={}
        if self.request.user.has_perm('scolar.fonctionnalite_configurationetablissement_modification') :
            btn_list['Créer un membre du personnel']=reverse('personnel_create')
        context['btn_list']=btn_list
        
        return context


class PaysCreateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, CreateView):
    model = Pays
    fields = '__all__'
    template_name = 'scolar/create.html'
    permission_required='scolar.fonctionnalite_configurationetablissement_modification'
    success_message = "Le pays été créé avec succès!"
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.helper.add_input(Submit('submit','Créer', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('pays_list')
        return form
    
class PaysUpdateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, UpdateView):
    model = Pays
    fields = ['nom']
    template_name = 'scolar/update.html'
    permission_required='scolar.fonctionnalite_configurationetablissement_modification'
    success_message = "Le pays a été modifié avec succès!"
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('pays_list')
        return form

class PaysDeleteView(LoginRequiredMixin, PermissionRequiredMixin, DeleteView):
    model = Pays
    template_name = 'scolar/delete.html'
    permission_required = 'scolar.fonctionnalite_configurationetablissement_modification'

    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression du pays : "+str(object_))
        return super(PaysDeleteView, self).delete(*args, **kwargs)
        
    def get_success_url(self):
        messages.success(self.request, "Le pays a bien été supprimé!")
        return reverse('pays_list')

class PaysListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name='scolar/list.html'

    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalite_configurationetablissement_visualisation')
    
    def get_queryset(self,**kwargs):
        return Pays.objects.all().order_by('nom')
    
    def get_context_data(self, **kwargs):
        context = super(PaysListView, self).get_context_data(**kwargs)
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalite_configurationetablissement_modification'):
            exclude_.append('edit')
        table = PaysTable(self.get_queryset(**kwargs), exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['titre'] = "Liste des pays"
        context['table'] = table
        context['back'] = reverse('settings')
        btn_list={}
        if self.request.user.has_perm('scolar.fonctionnalite_configurationetablissement_modification') :
            btn_list['Créer un pays']=reverse('pays_create')
            btn_list['Importer des pays']=reverse('pays_import')
        context['btn_list']=btn_list
        
        return context

class WilayaCreateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, CreateView):
    model = Wilaya
    fields = '__all__'
    template_name = 'scolar/create.html'
    permission_required='scolar.fonctionnalite_configurationetablissement_modification'
    success_message = "La wilaya été créée avec succès!"
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.helper.add_input(Submit('submit','Créer', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('wilaya_list')
        return form
    
class WilayaUpdateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, UpdateView):
    model = Wilaya
    fields = ['nom']
    template_name = 'scolar/update.html'
    permission_required='scolar.fonctionnalite_configurationetablissement_modification'
    success_message = "La wilaya a été modifiée avec succès!"
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('wilaya_list')
        return form

class WilayaDeleteView(LoginRequiredMixin, PermissionRequiredMixin, DeleteView):
    model = Wilaya
    template_name = 'scolar/delete.html'
    permission_required = 'scolar.fonctionnalite_configurationetablissement_modification'

    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression Wilaya : "+str(object_))
        return super(WilayaDeleteView, self).delete(*args, **kwargs)
        
    def get_success_url(self):
        messages.success(self.request, "La wilaya a bien été supprimée!")
        return reverse('wilaya_list')

class WilayaListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name='scolar/list.html'

    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalite_configurationetablissement_visualisation')
    
    def get_queryset(self,**kwargs):
        return Wilaya.objects.all().order_by('nom')
    
    def get_context_data(self, **kwargs):
        context = super(WilayaListView, self).get_context_data(**kwargs)
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalite_configurationetablissement_modification'):
            exclude_.append('edit')
        table = WilayaTable(self.get_queryset(**kwargs), exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['titre'] = "Liste des wilayas"
        context['table'] = table
        context['back'] = reverse('settings')
        btn_list={}
        if self.request.user.has_perm('scolar.fonctionnalite_configurationetablissement_modification') :
            btn_list['Créer une wilaya']=reverse('wilaya_create')
            btn_list['Importer des wilayas']=reverse('wilayas_import')
        context['btn_list']=btn_list
        
        return context

class CommuneCreateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, CreateView):
    model = Commune
    fields = '__all__'
    template_name = 'scolar/create.html'
    permission_required='scolar.fonctionnalite_configurationetablissement_modification'
    success_message = "La commune été créée avec succès!"
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.helper.add_input(Submit('submit','Créer', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('commune_list')
        return form
    
class CommuneUpdateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, UpdateView):
    model = Commune
    fields = ['nom', 'wilaya']
    template_name = 'scolar/update.html'
    permission_required='scolar.fonctionnalite_configurationetablissement_modification'
    success_message = "La commune a été modifiée avec succès!"
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        self.success_url = reverse('commune_list')
        return form

class CommuneDeleteView(LoginRequiredMixin, PermissionRequiredMixin, DeleteView):
    model = Commune
    template_name = 'scolar/delete.html'
    permission_required = 'scolar.fonctionnalite_configurationetablissement_modification'

    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression Commune : "+str(object_))
        return super(CommuneDeleteView, self).delete(*args, **kwargs)
        
    def get_success_url(self):
        messages.success(self.request, "La commune a bien été supprimée!")
        return reverse('commune_list')

class CommuneListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name='scolar/list.html'

    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalite_configurationetablissement_visualisation')
    
    def get_queryset(self,**kwargs):
        return Commune.objects.all().order_by('nom')
    
    def get_context_data(self, **kwargs):
        context = super(CommuneListView, self).get_context_data(**kwargs)
        exclude_=[]
        if not self.request.user.has_perm('scolar.fonctionnalite_configurationetablissement_modification'):
            exclude_.append('edit')
        table = CommuneTable(self.get_queryset(**kwargs), exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['titre'] = "Liste des communes"
        context['table'] = table
        context['back'] = reverse('settings')
        btn_list={}
        if self.request.user.has_perm('scolar.fonctionnalite_configurationetablissement_modification') :
            btn_list['Créer une commune']=reverse('commune_create')
            btn_list['Importer des communes']=reverse('communes_import')
        context['btn_list']=btn_list
        
        return context


@login_required
def etudiant_matricule_update_view(request, pk):
    if not request.user.has_perm('scolar.fonctionnalite_etudiants_gestion'):
        messages.error(request,"Vous n'avez pas les permissions d'accès à cette opération")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    etudiant_=get_object_or_404(Etudiant, matricule=pk)
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = EtudiantMatriculeUpdateForm(request, request.POST)
        # check whether it's valid:
        if form.is_valid():
            try:
                # process the data in form.cleaned_data as required
                data=form.cleaned_data
                etudiant_=etudiant_.matricule_update(data['matricule'])
                if etudiant_.matricule == pk :
                    messages.error(request, "Modification du matricule impossible : Vérifiez que le matricule est correct et unique")
                       
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: lors de la modification du matricule de l'étudiant. Veuillez le signaler à l'administrateur.")
                    return render(request, 'scolar/update.html', {'form': form })
            
            return HttpResponseRedirect(reverse('etudiant_detail', kwargs={'pk': etudiant_.matricule}))
    # if a GET (or any other method) we'll create a blank form
    else:
        form = EtudiantMatriculeUpdateForm(request)
        messages.info(request, "Utilisez ce formulaire pour modifier le matricule de l'étudiant")
    
    context={}      
    context['form']=form
    context['object']=etudiant_
    return render(request, 'scolar/update.html', context)


def etudiants_matricule_batch_update_view(request):
    if not request.user.has_perm('scolar.fonctionnalite_etudiants_gestion'):
        messages.error(request,"Vous n'avez pas les permissions pour effectuer cette opération.")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    # if this is a POST request we need to process the form data
    if request.method == 'POST':
        message_succes=""
        message_error=""
        # create a form instance and populate it with data from the request:
        form = ImportFileForm(request.POST, request.FILES)
        # check whether it's valid:
        if form.is_valid():
            try:    
                matricules_file = request.FILES['file']
                dataset = Dataset()
                imported_data = dataset.load(matricules_file.read(), format ='xlsx')
                # la première ligne du fichier doit contenir des entêtes, au moins Matricule, Enseignant
                # update Etudiant with tuteur
                for row in imported_data.dict :
                    try:
                        matricule=str(row.get('Matricule')).strip() if row.get('Matricule') else ''
                        nouveau_matricule=str(row.get('NouveauMatricule')).strip() if row.get('NouveauMatricule') else ''
                        if matricule and nouveau_matricule and (matricule != nouveau_matricule):
                            etudiant_=Etudiant.objects.get(matricule=matricule)
                            if etudiant_.matricule_update(nouveau_matricule) :
                                message_succes = message_succes +"Matricule "+matricule+" changé avec succès vers : "+nouveau_matricule+"<br>"
                            else :
                                message_error = message_error+"Echec lors du changement du Matricule "+matricule+" vers : "+nouveau_matricule+"<br>"
                            
                    except Exception:
                        message_error = message_error+"Echec lors du changement du Matricule "+matricule+" vers : "+nouveau_matricule+"<br>"
                        continue

            except Exception:
                if settings.DEBUG:
                    raise Exception
            if message_error :
                messages.error(request, mark_safe(message_error))
            if message_succes :
                messages.success(request, mark_safe(message_succes))
            # redirect to a new URL:
            return HttpResponseRedirect(reverse('etudiant_list')) 
    # if a GET (or any other method) we'll create a blank form
    else:
        form = ImportFileForm()
        messages.info(request, "Indiquer le fichier .xlsx des matricules à changer")
        messages.info(request, "La première ligne du fichier doit comporter au moins les colonnes suivantes: Matricule, NouveauMatricule")
    return render(request, 'scolar/import.html', {'form': form, 'titre':'Modification des matricules en lot'})


def enregistrement_etudiant_create_view(request):
    if not get_institution().activation_enregistrement_etudiants :
        messages.error(request,"Vous n'avez pas les permissions pour effectuer cette opération.")
        return redirect('/accounts/login/?next=%s' % request.path)
        
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = EnregistrementEtudiantCreateForm(request.POST, request.FILES)
        # check whether it's valid:
        if form.is_valid():
            try:
                data=form.cleaned_data
                email_=data['email']
                with transaction.atomic() :
                    enregistrement=form.save()
                    
                    user=User.objects.create_user(
                        username=email_,
                        first_name= data['prenom'],
                        last_name= data['nom'],
                        is_active=True,
                        is_superuser= False,
                        is_staff= False,
                        email=data['email'],
                        password=data['password'],
                        )
                    user.save()
                    enregistrement.user=user
                    enregistrement.save(update_fields=['user'])
                    trace_create(user, user, "La demande d'enregistrement a été transmise avec succès. Vous recevrez la réponse dans les prochaines heures via notification.")
                    user_authenticated=authenticate(request=request, username=data['email'], password=data['password'])
                    login(request, user_authenticated)
                    messages.success(request, "La demande d'enregistrement a été transmise avec succès, vous recevrez la réponse dans les prochaines heures via notification. Une fois votre accès étudiant validé, vous aurez accès à votre cursus étudiant, vos notes, vos documents, etc. Vous pouvez vous connecter au futur avec votre adresse e-mail et votre mot de passe.")
                    
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "Une erreur est survenue lors de la demande d'enregistrement.")
                    return render(request, 'scolar/create.html', {'form': form })
                
            return HttpResponseRedirect(reverse('home'))
    # if a GET (or any other method) we'll create a blank form
    else:
        form = EnregistrementEtudiantCreateForm()
        messages.info(request, "Utilisez ce formulaire pour vous enregistrer sur la plateforme en tant qu'étudiant.")
        messages.warning(request, mark_safe("Important : Vos informations doivent être exactes car elles seront utilisées pour :<br>- Mettre à jour votre dossier étudiant<br>- Générer vos documents de scolarité (certificat de scolarité, relevé de notes, ..).<br>- Vous authentifier pour vous accorder les droits d'accès sur votre dossier étudiant une fois votre enregistrement approuvé"))
    
    context={}  
    context['form']=form
    return render(request, 'scolar/create.html', context)


class EnregistrementEtudiantListView(LoginRequiredMixin, PermissionRequiredMixin, TemplateView):
    permission_required = 'scolar.fonctionnalitenav_configurationetablissement_enregistrementetudiants'
    template_name = 'scolar/filter_list.html'
    
    def get_queryset(self, **kwargs):
        return EnregistrementEtudiant.objects.all().order_by('-created_at')

    def get_context_data(self, **kwargs):
        context = super(EnregistrementEtudiantListView, self).get_context_data(**kwargs)
        filter_ = EnregistrementEtudiantFilter(self.request.GET, queryset=self.get_queryset(**kwargs))
        filter_.form.helper = FormHelper()
        table = EnregistrementEtudiantTable(filter_.qs)
        RequestConfig(self.request).configure(table)
        context['filter'] = filter_
        context['table'] = table
        context['titre']="Demandes d'enregistrement"
        
        return context
    
class EnregistrementEtudiantDeleteView(LoginRequiredMixin, PermissionRequiredMixin, DeleteView):
    model = EnregistrementEtudiant
    template_name = 'scolar/delete.html'
    permission_required = 'scolar.fonctionnalitenav_configurationetablissement_enregistrementetudiants'

    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression de la demande d'enregistrement : "+str(object_))
        return super(EnregistrementEtudiantDeleteView, self).delete(*args, **kwargs)
    
    def get_success_url(self):
        messages.success(self.request, "La demande d'enregistrement a bien été supprimée!")
        return reverse('enregistrement_etudiant_list')

@login_required
def enregistrement_etudiant_update_view(request, enregistrement_etudiant_pk):
    enregistrement_=get_object_or_404(EnregistrementEtudiant, id=enregistrement_etudiant_pk)
    if enregistrement_.statut=="V" :
        messages.success(request, "Cette demande a déjà été validée, vous ne pouvez plus la revalider mais vous pouvez vous en servir pour historique et comparaison.")
    if enregistrement_.statut=="R" :
        messages.error(request, "Cette demande a déjà été rejetée.")
                
    user_=enregistrement_.user
    etudiant_=None
    if 'etudiant' in request.POST:
        etudiant_=get_object_or_404(Etudiant, matricule=request.POST['etudiant'])
        
    if not request.user.has_perm('scolar.fonctionnalitenav_configurationetablissement_enregistrementetudiants') :
        messages.error(request,"Vous n'avez pas la permission d'exécution de cette opération")
        return redirect('/accounts/login/?next=%s' % request.path)
    
    champs_a_comparer=['nom', 'prenom', 'sexe', 'date_naissance', 'lieu_naissance', 'wilaya_naissance', 'wilaya_residence', 'commune_residence', 'interne', 'residence_univ', 'addresse_principale', 'nom_a', 'prenom_a', 'lieu_naissance_a', 'tel', 'numero_securite_sociale']    
        
    if request.method == 'POST':

        if 'submit_rejet' in request.POST:
            enregistrement_.statut="R"
            enregistrement_.save(update_fields=['statut'])
            trace_create(request.user, enregistrement_.user, "Votre demande d'enregistrement a été rejetée.")
            if activation_emails():
                email = EmailMessage('[Talents] Demande d\'enregistrement rejetée',
                                     'Bonjour\n'+ 
                                     'Votre demande d\'enregistrement a été rejetée.\n',
                                     'Veuillez renseigner vos informations exactes lors d\'une prochaine demande. Lien de la plateforme : '+settings.PROTOCOLE_HOST+'\n'
                                     'Bien cordialement.\n'+
                                     signature_emails(), to=[user_.get_email() if user_ else ''])
                email.send(fail_silently=True)
            messages.error(request, "Demande d'enregistrement rejetée")
                
            return HttpResponseRedirect(reverse('enregistrement_etudiant_list'))
            
                        
        if 'submit_selection_etudiant' in request.POST:
            # create a form instance and populate it with data from the request:
            form_selection_etudiant = SelectionEtudiantForm(etudiant_, request.POST)
            # check whether it's valid:
            if form_selection_etudiant.is_valid():
                data=form_selection_etudiant.cleaned_data
                etudiant_=data['etudiant_choisi']
        
        if 'submit' in request.POST:
            # create a form instance and populate it with data from the request:
            form = EnregistrementEtudiantUpdateForm(enregistrement_, etudiant_, request.POST)
            # check whether it's valid:
            if form.is_valid():
                data=form.cleaned_data
                try:
                    with transaction.atomic() :
                        etudiant_=data['etudiant']
                        for champs in champs_a_comparer :
                            if data['choosenew_'+champs] :
                                setattr(etudiant_, champs, data['new_'+champs])
                        etudiant_.save()
                        if enregistrement_.photo.name:
                            if etudiant_.photo.name != etudiant_.photo.field.upload_to+'/'+'anonymous-user.jpg':
                                etudiant_.photo.delete()
                            uploaded_file_name, uploaded_file_extension=os.path.splitext(enregistrement_.photo.name)
                            photo_file_name=etudiant_.matricule.replace('/','-')+uploaded_file_extension
                            etudiant_.photo = File(enregistrement_.photo, photo_file_name)
                        
                        user_.groups.add(Group.objects.get(name="etudiant"))
                        etudiant_.user=user_
                        etudiant_.save(update_fields=['user', 'photo'])
                        
                        enregistrement_.statut="V"
                        enregistrement_.save(update_fields=['statut'])
                        
                        trace_create(request.user, etudiant_, "Demande d'enregistrement confirmée. Votre accès étudiant a été activé.")
                        if activation_emails():
                            email = EmailMessage('[Talents] Demande d\'enregistrement confirmée',
                                                 'Bonjour\n'+ 
                                                 'Votre accès étudiant a été établi.\n',
                                                 'Vous pouvez vous connecter avec votre e-mail et mot de passe. Lien de la plateforme : '+settings.PROTOCOLE_HOST+'\n'
                                                 'Bien cordialement.\n'+
                                                 signature_emails(), to=[user_.get_email() if user_ else ''])
                            email.send(fail_silently=True)
                        messages.success(request, "Demande d'enregistrement traîtée avec succès")
                        
                except Exception:
                    if settings.DEBUG:
                        raise Exception
                    else:
                        messages.error(request, "ERREUR: lors du traîtement de la demande d'enregistrement. Merci de le signaler à l'administrateur." )
                    
                # redirect to a new URL:
                return HttpResponseRedirect(reverse('enregistrement_etudiant_list'))
                
    
    form_selection_etudiant=SelectionEtudiantForm(etudiant_)
    form = EnregistrementEtudiantUpdateForm(enregistrement_, etudiant_)
    context={
            'form': form,
            'form_selection_etudiant':form_selection_etudiant,
            'titre': 'Traîtement de la demande d\'enregistrement',
            'enregistrement': enregistrement_,
            'etudiant': etudiant_,
        }
    
    if enregistrement_.statut=="W" :
        messages.info(request, "Merci de vérifier les informations introduites par l'étudiant, de sélectionner l'étudiant existant pour comparer ls informations de la base de données avec les nouvelles informations ainsi que choisir quelle valeur considérer pour chaque information.")
    return render(request, 'scolar/enregistrement_etudiant_update.html', context)


class EquipeRechercheCreateView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, CreateView):
    model = EquipeRecherche
    fields = '__all__'
    template_name = 'scolar/create.html'
    success_message = "L'équipe de recherche a été créée avec succès"
    
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalite_postgraduation_gestionequipesrecherche')
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        try:
            form.fields['responsable']=forms.ModelChoiceField(
                queryset = Enseignant.objects.all().order_by('nom'),
                widget=ModelSelect2Widget(
                    model=Enseignant,
                    search_fields=['nom__icontains','prenom__icontains'],
                ),
                required=False,
                help_text = "Sélection multiple possible. Tapez le nom ou prénom de l'enseignant ou deux espaces pour avoir la liste complète.",    
            ) 
            form.fields['membres']=forms.ModelMultipleChoiceField(
                queryset = Enseignant.objects.all().order_by('nom'),
                widget=ModelSelect2MultipleWidget(
                    model=Enseignant,
                    search_fields=['nom__icontains','prenom__icontains'],
                ),
                required=False,
                help_text = "Sélection multiple possible. Tapez le nom ou prénom de l'enseignant ou deux espaces pour avoir la liste complète.",    
            )
            form.fields['membres_doctorants']=forms.ModelMultipleChoiceField(
                queryset = Doctorant.objects.all(),
                widget=ModelSelect2MultipleWidget(
                    model=Doctorant,
                    search_fields=['enseignant__nom__icontains', 'etudiant__nom__icontains','enseignant__prenom__icontains', 'etudiant__prenom__icontains'],
                ),
                required=False,
                help_text = "Sélection multiple possible. Tapez le nom ou prénom d'un doctorant ou deux espaces pour avoir la liste complète.",
            )
            form.fields['membres_externes'].widget=forms.Textarea(attrs={'rows':3})
            form.fields['membres_externes'].help_text="Saisissez chaque membre dans une nouvelle ligne"
            form.fields['organisme']=forms.ModelChoiceField(
                queryset = Organisme.objects.filter(interne=True),
                required=False,
            ) 
                     
            form.helper.add_input(Submit('submit','Enregistrer', css_class='btn-primary'))
            form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
            self.success_url = reverse('equiperecherche_list')
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors de la création d'une équipe de recherche.")
    
        return form

class EquipeRechercheListView(UserPassesTestMixin, TemplateView):
    template_name = 'scolar/filter_list.html'
 
    def test_func(self): 
        return get_institution().activation_public_equipesrecherche or (self.request.user.is_authenticated and self.request.user.has_perm('scolar.fonctionnalitenav_postgraduation_visualisationequipesrecherche'))
        
    def get_context_data(self, **kwargs):
        context = super(EquipeRechercheListView, self).get_context_data(**kwargs)

        filter_ = EquipeRechercheFilter(self.request.GET, queryset=EquipeRecherche.objects.all().order_by('code'))
        
        filter_.form.helper = FormHelper()
        exclude_=[]
        if not (self.request.user.is_authenticated and self.request.user.has_perm('scolar.fonctionnalite_postgraduation_gestionequipesrecherche')):
            exclude_.append('edit')
            exclude_.append('admin')
        table = EquipeRechercheTable(filter_.qs, exclude=exclude_)
        RequestConfig(self.request).configure(table)
            
        context['filter'] = filter_
        context['table'] = table
        context['titre'] = 'Liste des équipes de recherche'
        if self.request.user.is_authenticated and self.request.user.has_perm('scolar.fonctionnalite_postgraduation_gestionequipesrecherche'):
            context['btn_list']={
                    'Ajouter une équipe de recherche':reverse('equiperecherche_create'),
                }
        return context
      
class EquipeRechercheUpdateView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, UpdateView):
    model = EquipeRecherche
    template_name = 'scolar/update.html'
    permission_required = 'scolar.fonctionnalite_postgraduation_gestionequipesrecherche'
    success_message = "L'équipe de recherche été modifiée avec succès!"
    fields='__all__'
    
    def test_func(self):
        equipeRecherche_ = get_object_or_404(EquipeRecherche, id=self.kwargs.get('pk'))
        if self.request.user.has_perm('scolar.fonctionnalite_postgraduation_gestionequipesrecherche') :
            return True
        else :
            return (self.request.user.is_enseignant() and self.request.user.enseignant == equipeRecherche_.responsable)
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        equipeRecherche_ = get_object_or_404(EquipeRecherche, id=self.kwargs.get('pk'))
        
        edit_restreint=False
        if not self.request.user.has_perm('scolar.fonctionnalite_postgraduation_gestionequipesrecherche') :
            edit_restreint=True
        
        form.fields['responsable']=forms.ModelChoiceField(
            queryset = Enseignant.objects.all().order_by('nom'),
            widget=ModelSelect2Widget(
                model=Enseignant,
                search_fields=['nom__icontains','prenom__icontains'],
            ),
            required=False,
            initial = equipeRecherche_.responsable,
            help_text = "Sélection multiple possible. Tapez le nom ou prénom de l'enseignant ou deux espaces pour avoir la liste complète.",    
        ) 
        form.fields['membres']=forms.ModelMultipleChoiceField(
            queryset = Enseignant.objects.all().order_by('nom'),
            widget=ModelSelect2MultipleWidget(
                model=Enseignant,
                search_fields=['nom__icontains','prenom__icontains'],
            ),
            required=False,
            initial = equipeRecherche_.membres.all(),
            help_text = "Sélection multiple possible. Tapez le nom ou prénom de l'enseignant ou deux espaces pour avoir la liste complète.",    
        )
        form.fields['membres_doctorants']=forms.ModelMultipleChoiceField(
            queryset = Doctorant.objects.all(),
            widget=ModelSelect2MultipleWidget(
                model=Doctorant,
                search_fields=['enseignant__nom__icontains', 'etudiant__nom__icontains','enseignant__prenom__icontains', 'etudiant__prenom__icontains'],
            ),
            required=False,
            initial = equipeRecherche_.membres_doctorants.all(),
            help_text = "Sélection multiple possible. Tapez le nom ou prénom d'un doctorant ou deux espaces pour avoir la liste complète.",
        )
        form.fields['membres_externes'].widget=forms.Textarea(attrs={'rows':3})
        form.fields['membres_externes'].help_text="Saisissez chaque membre dans une nouvelle ligne"
        form.fields['organisme']=forms.ModelChoiceField(
            queryset = Organisme.objects.filter(interne=True),
            required=False,
            initial=equipeRecherche_.organisme
        )
        form.fields['description'].widget = forms.Textarea(attrs={'rows':20})
        if edit_restreint :
            for key_ in form.fields.keys():
                if key_!="description" :
                    form.fields[key_].disabled=True
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        
        if self.request.user.has_perm('scolar.fonctionnalitenav_postgraduation_visualisationprojetsrecherche') :
            self.success_url = reverse('equiperecherche_list')
        else :
            self.success_url = reverse('home')
        return form

  
class EquipeRechercheDeleteView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, DeleteView):
    permission_required = 'scolar.fonctionnalite_postgraduation_gestionequipesrecherche'
    model = EquipeRecherche
    template_name = 'scolar/delete.html'
    success_message = "L'équipe de recherche a bien été supprimée."

    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression de l'équipe de recherche : "+str(object_))
        return super(EquipeRechercheDeleteView, self).delete(*args, **kwargs)
        
    def get_success_url(self):
        return reverse('equiperecherche_list')


class EquipeRechercheDetailView(UserPassesTestMixin, TemplateView):
    template_name = 'scolar/form.html'

    def test_func(self): 
        equipeRecherche_=get_object_or_404(EquipeRecherche, id=self.kwargs.get("pk"))   
        permission_=False
        if get_institution().activation_public_equipesrecherche :
            return True
        else :
            if self.request.user.has_perm('scolar.fonctionnalitenav_postgraduation_visualisationequipesrecherche') :
                permission_ = permission_ | True
            if self.request.user.is_enseignant() :
                permission_= permission_ | EquipeRecherche.objects.filter(id=equipeRecherche_.id).filter(Q(chef=self.request.user.enseignant)|Q(membres__in=[self.request.user.enseignant])).exists()
        return permission_
        
    def get_context_data(self, **kwargs):
        context = super(EquipeRechercheDetailView, self).get_context_data(**kwargs)
        EquipeRecherche_=get_object_or_404(EquipeRecherche, id=self.kwargs.get("pk"))
        context['form'] = EquipeRechercheDetailForm(instance=EquipeRecherche_)
        
        return context
    

# Pour l'application mobile : serializer permettant de retourner un contenu JSON via l'URL
class AbsenceEtudiantSerializer(serializers.ModelSerializer):
    etudiant=serializers.SerializerMethodField('get_nom_etudiant')
    seance = serializers.SerializerMethodField('get_nom_seance')
    motif = serializers.SerializerMethodField('get_motif')
    
    def get_nom_etudiant(self, absence) :
    
        periodepgm_=absence.seance.activite.module.periode
        
        inscription_periode_=InscriptionPeriode.objects.filter(inscription__etudiant=absence.etudiant, periodepgm=periodepgm_, inscription__formation=absence.seance.activite.module.formation)
        if inscription_periode_.exists() :
            inscription_periode_=inscription_periode_.first()
            return absence.etudiant.nom + ' ' + absence.etudiant.prenom + ' ' + str(inscription_periode_.groupe)
        else :
            return absence.etudiant.nom + ' ' + absence.etudiant.prenom
        
    def get_nom_seance(self, absence):
        return str(absence.seance)
    
    def get_motif(self, absence):
        if absence.motif :
            return absence.motif
        else :
            return ""

    class Meta:
        model = AbsenceEtudiant
        fields=('id', 'etudiant','seance', 'justif', 'motif')

# Pour l'app mobile : API Listant les absences de l'étudiant connecté de l'année en cours, où bien les absences des étudiants concernant les modules enseignés par l'enseignant connecté durant l'année en cours                
class AbsencesAPI(APIView):
    def get(self, request):
        all_objects=AbsenceEtudiant.objects.none()
        if self.request.user.is_authenticated :
            if self.request.user.is_etudiant() :
                all_objects = AbsenceEtudiant.objects.filter(etudiant=self.request.user.etudiant, seance__activite__module__formation__annee_univ__encours=True).order_by('-seance__date', '-seance__heure_debut')
            if self.request.user.is_enseignant() :
                #absences des étudiants enseignés durant l'année en cours
                all_objects= (all_objects | AbsenceEtudiant.objects.filter(seance__activite__assuree_par__in=[self.request.user.enseignant] ,seance__activite__module__formation__annee_univ__encours=True).order_by('-seance__date', '-seance__heure_debut', 'etudiant__nom', 'etudiant__prenom')).distinct()
        serializer = AbsenceEtudiantSerializer(all_objects, many=True)
        return Response(serializer.data)

    def post(self):
        pass

#Pour l'app mobile    
class ResultatSerializer(serializers.ModelSerializer):
    module=serializers.SerializerMethodField('get_nom_module')
    inscription=serializers.SerializerMethodField('get_inscription')
    groupe=serializers.SerializerMethodField('get_groupe')
    
    def get_nom_module(self, resultat) :
        return str(resultat.module.matiere)
    
    def get_inscription(self, resultat) :
        return resultat.inscription.etudiant.nom + ' ' + resultat.inscription.etudiant.prenom

    def get_groupe(self, resultat) :
        periodepgm_=resultat.module.periode
        inscription_periode_=InscriptionPeriode.objects.filter(periodepgm=periodepgm_, inscription=resultat.inscription)
        if inscription_periode_.exists() :
            inscription_periode_=inscription_periode_.first()
            return str(inscription_periode_.groupe)
        else :
            return ''
    
        
    class Meta:
        model = Resultat
        fields=('id', 'module', 'groupe', 'inscription', 'moy')
 
 
 # Pour l'app mobile : API Listant les résultats de l'année en cours de l'étudiant connecté, ou bien les résultats des modules enseignés par l'enseignant connecté durant l'année en cours
class ResultatsAPI(APIView):
    def get(self, request):
        all_objects=Resultat.objects.none()
        if self.request.user.is_authenticated :
            if self.request.user.is_etudiant() :
                all_objects = Resultat.objects.filter(inscription__etudiant=self.request.user.etudiant, inscription__formation__annee_univ__encours=True).order_by('module__matiere__code', 'module__periode__code')
            if self.request.user.is_enseignant() : 
                #résultats des étudiants enseignés durant l'année en cours
                all_activites = Activite.objects.filter(module__formation__annee_univ__encours=True).filter((Q(module__coordinateur=self.request.user.enseignant) | (Q(assuree_par__in=[self.request.user.enseignant])&(~Q(type__startswith='E_'))))).distinct().order_by('module__periode__code')
                for activite_ in all_activites :
                    periodepgm_= activite_.module.periode
                    all_results = Resultat.objects.filter(module=activite_.module, inscription__inscription_periodes__periodepgm=periodepgm_, inscription__inscription_periodes__groupe__in=activite_.cible.all())
                    all_objects = all_objects | all_results
                all_objects = all_objects.distinct().order_by('module__matiere__code','inscription__groupe__code',  'inscription__etudiant__nom', 'inscription__etudiant__prenom')
            
        serializer = ResultatSerializer(all_objects, many=True)
        return Response(serializer.data)

    def post(self):
        pass    
    
def matieres_titres_en_arabe_import_view(request):
    if not request.user.has_perm('scolar.fonctionnalitenav_pedagogie_gestionprogrammes'):
        return redirect('/accounts/login/?next=%s' % request.path)
    
    # if this is a POST request we need to process the form data
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = ImportFileForm(request.POST, request.FILES)
        
        # check whether it's valid:
        if form.is_valid():
            try:
                matiere_file = request.FILES['file']
                dataset = Dataset(headers=['Code','TitreA',])
                imported_data = dataset.load(matiere_file.read(), format ='xlsx')
                # insert imported_data in Etudiant table
                for row in imported_data.dict :
                    if row['Code'] and row['TitreA'] :
                        matiere_qs=Matiere.objects.filter(code=row['Code'])
                        for matiere_ in matiere_qs :
                            matiere_.titre_a=row['TitreA']
                            matiere_.save(update_fields=['titre_a',])
                
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: Echec de l'importation.")
                    messages.info(request, "La première ligne du fichier .xlsx doit comprendre au moins les colonnes: 'Code', 'TitreA'")
                    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer les titres des matières en arabe'})
            # redirect to a new URL:
            messages.success(request, "L'importation s'est faite avec succès!")
            return HttpResponseRedirect(reverse('programme_design')) 
    # if a GET (or any other method) we'll create a blank form
    else:
        form = ImportFileForm()
        messages.info(request, "La première ligne du fichier .xlsx doit comprendre au moins les colonnes: 'Code', 'TitreA'")

    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer les titres des matières en arabe'})


def ues_codes_en_arabe_import_view(request):
    if not request.user.has_perm('scolar.fonctionnalitenav_pedagogie_gestionprogrammes'):
        return redirect('/accounts/login/?next=%s' % request.path)
    
    # if this is a POST request we need to process the form data
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = ImportFileForm(request.POST, request.FILES)
        
        # check whether it's valid:
        if form.is_valid():
            try:
                ue_file = request.FILES['file']
                dataset = Dataset(headers=['Code','CodeA',])
                imported_data = dataset.load(ue_file.read(), format ='xlsx')
                # insert imported_data in Etudiant table
                for row in imported_data.dict :
                    if row['Code'] and row['CodeA'] :
                        ue_qs=UE.objects.filter(code=row['Code'])
                        for ue_ in ue_qs :
                            ue_.code_a=row['CodeA']
                            ue_.save(update_fields=['code_a',])
                
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "ERREUR: Echec de l'importation.")
                    messages.info(request, "La première ligne du fichier .xlsx doit comprendre au moins les colonnes: 'Code', 'CodeA'")
                    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer les codes des UE en arabe'})
            # redirect to a new URL:
            messages.success(request, "L'importation s'est faite avec succès!")
            return HttpResponseRedirect(reverse('programme_design')) 
    # if a GET (or any other method) we'll create a blank form
    else:
        form = ImportFileForm()
        messages.info(request, "La première ligne du fichier .xlsx doit comprendre au moins les colonnes: 'Code', 'CodeA'")

    return render(request, 'scolar/import.html', {'form': form, 'titre':'Importer les codes des UE en arabe'})


# Pour les matières type stage validé/non-validé (sans notes)
@login_required

def acquis_toggle_view(request, resultat_pk):
    resultat_=Resultat.objects.get(id=resultat_pk)
    if request.user.has_perm('scolar.fonctionnalite_pedagogie_modificationnotes') or request.user.is_coordinateur(resultat_.module) :
        pass
    else :
        messages.error(request, "Vous n'avez pas la permission d'accéder à cette opération." )
        return redirect('/accounts/login/?next=%s' % request.path)
    resultat_.acquis = not resultat_.acquis
    resultat_.save(update_fields=['acquis'])
    if resultat_.acquis :
        messages.success(request, "La module a bien été marqué comme Validé pour l'étudiant")
        trace_create(request.user, resultat_.inscription.etudiant, str(resultat_)+ " : Passage à l'état Validé")
    else:
        messages.warning(request, "Le module a bien été marqué comme Non Validé pour l'étudiant")
        trace_create(request.user, resultat_.inscription.etudiant, str(resultat_)+ " : Passage à l'état Non Validé")
    return HttpResponseRedirect(request.META.get('HTTP_REFERER'))


class PaysPFEChart(Chart):
    chart_type='horizontalBar'
    options= {
        'legend': {
            'display': False,
        }
    }
    
    def __init__(self, *args, **kwargs):
        super(PaysPFEChart, self).__init__(*args, **kwargs)
        try:
            qs=Pays.objects.all().annotate(nb_pfe=Count('organisme__pfe', filter=Q(organisme__pfe__type='P', organisme__pfe__statut_validation='V', organisme__pfe__groupe__section__formation__programme__matiere_equipe__isnull=True))).exclude(nb_pfe=0).order_by('-nb_pfe')
            self.labels=list(qs.values_list('nom', flat=True))
            self.data=list(qs.values_list('nb_pfe', flat=True))
            self.colors=['green', 'blue', 'red', 'black', 'purple', '#A959A9', '#C0B0C0', '#D2D3D3']
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors de la génération du graphique des pays des PFE")

    def get_labels(self, *args, **kwargs):
        return self.labels
    
    def get_datasets(self, **kwargs):
        return [DataSet(data=self.data, backgroundColor=self.colors)]


class PaysMasterChart(Chart):
    chart_type='horizontalBar'
    options= {
        'legend': {
            'display': False,
        }
    }
    def __init__(self, *args, **kwargs):
        super(PaysMasterChart, self).__init__(*args, **kwargs)
        try:
            qs=Pays.objects.all().annotate(nb_pfe=Count('organisme__pfe', distinct=True, filter=Q(organisme__pfe__type='M', organisme__pfe__statut_validation='V', organisme__pfe__groupe__section__formation__programme__matiere_equipe__isnull=True))).exclude(nb_pfe=0).order_by('-nb_pfe')
            self.labels=list(qs.values_list('nom', flat=True))
            self.data=list(qs.values_list('nb_pfe', flat=True))
            self.colors=['green', 'blue', 'red', 'black', 'purple', '#A959A9', '#C0B0C0', '#D2D3D3']
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors de la génération du graphique des pays des Master")

    def get_labels(self, *args, **kwargs):
        return self.labels
    
    def get_datasets(self, **kwargs):
        return [DataSet(data=self.data, backgroundColor=self.colors)]

        
class DashboardStagesView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name = 'scolar/dashboard_stages.html'
    
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalitenav_dashboard_stages')

    def get_context_data(self, **kwargs):
        context = super(DashboardStagesView, self).get_context_data(**kwargs)
        if Pays.objects.all().annotate(nb_pfe=Count('organisme__pfe', distinct=True, filter=Q(organisme__pfe__type='P',organisme__pfe__statut_validation='V', organisme__pfe__groupe__section__formation__programme__matiere_equipe__isnull=True))).exclude(nb_pfe=0).order_by('-nb_pfe').exists() :
            context['pays_pfe_chart']=PaysPFEChart
        if Pays.objects.all().annotate(nb_pfe=Count('organisme__pfe', distinct=True, filter=Q(organisme__pfe__type='M', organisme__pfe__statut_validation='V', organisme__pfe__groupe__section__formation__programme__matiere_equipe__isnull=True))).exclude(nb_pfe=0).order_by('-nb_pfe').exists() :
            context['pays_master_chart']=PaysMasterChart
        qs_stages_organismes=Organisme.objects.all()\
                            .annotate(nb_sujets=Count('pfe', distinct=True, filter=Q(Q(pfe__type='P')|Q(pfe__type='M'), pfe__groupe__section__formation__programme__matiere_equipe__isnull=True)))\
                            .exclude(nb_sujets=0).order_by('-nb_sujets')\
                            .annotate(nb_sujets_reserves=Count('pfe', distinct=True, filter=Q(Q(pfe__type='P')|Q(pfe__type='M'), pfe__reserve_pour__isnull=False, pfe__groupe__section__formation__programme__matiere_equipe__isnull=True)))\
                            .annotate(nb_pfe=Count('pfe', distinct=True, filter=Q(pfe__type='P', pfe__groupe__section__formation__programme__matiere_equipe__isnull=True)))\
                            .annotate(nb_master=Count('pfe', distinct=True, filter=Q(pfe__type='M', pfe__groupe__section__formation__programme__matiere_equipe__isnull=True)))\
                            .annotate(nb_avis_favorables=Count('pfe__validations', distinct=True, filter=Q(pfe__validations__avis='V'), pfe__groupe__section__formation__programme__matiere_equipe__isnull=True))\
                            .annotate(nb_avis_reserves=Count('pfe__validations', distinct=True, filter=Q(Q(pfe__validations__avis='SR')|Q(pfe__validations__avis='MR'), pfe__groupe__section__formation__programme__matiere_equipe__isnull=True)))\
                            .annotate(nb_avis_defavorables=Count('pfe__validations', distinct=True, filter=Q(pfe__validations__avis='N'), pfe__groupe__section__formation__programme__matiere_equipe__isnull=True))\
                            .annotate(nb_avis_total=Count('pfe__validations', distinct=True, filter=Q(~Q(pfe__validations__avis='X'), pfe__groupe__section__formation__programme__matiere_equipe__isnull=True)))
        context['stages_organismes']=qs_stages_organismes
        
        qs_annees_stages=AnneeUniv.objects.all()\
                        .annotate(nb_sujets=Count('formation__sections__groupes__pfe', distinct=True, filter=Q(Q(formation__sections__groupes__pfe__type='P')|Q(formation__sections__groupes__pfe__type='M'), formation__programme__matiere_equipe__isnull=True)))\
                        .exclude(nb_sujets=0).order_by('annee_univ')
        
        stats_par_annee={}
        for annee in qs_annees_stages :
            dict_={
                'nb_stages_pfe_monomes' : PFE.objects.filter(groupe__section__formation__annee_univ=annee, type='P', groupe__section__formation__programme__matiere_equipe__isnull=True).annotate(nb_reserve_pour=Count('reserve_pour', distinct=True, filter=(Q(reserve_pour__isnull=False)))).filter(nb_reserve_pour=1).count(),
                'nb_stages_master_monomes' : PFE.objects.filter(groupe__section__formation__annee_univ=annee, type='M', groupe__section__formation__programme__matiere_equipe__isnull=True).annotate(nb_reserve_pour=Count('reserve_pour', distinct=True, filter=(Q(reserve_pour__isnull=False)))).filter(nb_reserve_pour=1).count(),
                'nb_stages_pfe_binomes' : PFE.objects.filter(groupe__section__formation__annee_univ=annee, type='P', groupe__section__formation__programme__matiere_equipe__isnull=True).annotate(nb_reserve_pour=Count('reserve_pour', distinct=True, filter=(Q(reserve_pour__isnull=False)))).filter(nb_reserve_pour=2).count(),
                'nb_stages_master_binomes' : PFE.objects.filter(groupe__section__formation__annee_univ=annee, type='M', groupe__section__formation__programme__matiere_equipe__isnull=True).annotate(nb_reserve_pour=Count('reserve_pour', distinct=True, filter=(Q(reserve_pour__isnull=False)))).filter(nb_reserve_pour=2).count(),
                'nb_stages_pfe_total' : PFE.objects.filter(groupe__section__formation__annee_univ=annee, type='P', groupe__section__formation__programme__matiere_equipe__isnull=True).annotate(nb_reserve_pour=Count('reserve_pour', distinct=True, filter=(Q(reserve_pour__isnull=False)))).count(),
                'nb_stages_master_total' : PFE.objects.filter(groupe__section__formation__annee_univ=annee, type='M', groupe__section__formation__programme__matiere_equipe__isnull=True).annotate(nb_reserve_pour=Count('reserve_pour', distinct=True, filter=(Q(reserve_pour__isnull=False)))).count(),
            }
            stats_par_annee[annee]=dict_
        context['stats_par_annee']=stats_par_annee
        
        return context

class StatistiquesSoutenancesView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name = 'scolar/statistiques_soutenances.html'
    
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalitenav_stages_visualisationstatistiques')

    def get_context_data(self, **kwargs):
        context = super(StatistiquesSoutenancesView, self).get_context_data(**kwargs)        
        qs_annees_stages=AnneeUniv.objects.all()\
                        .annotate(nb_sujets=Count('formation__sections__groupes__pfe', distinct=True, filter=Q(Q(formation__sections__groupes__pfe__type='P')|Q(formation__sections__groupes__pfe__type='M'), formation__programme__matiere_equipe__isnull=True)))\
                        .exclude(nb_sujets=0).order_by('-annee_univ')
        
        stats_par_annee={}
        
        for annee in qs_annees_stages :
            stats_pfe_par_enseignant=Enseignant.objects.all()\
                                    .annotate(nb_encadrant=Count('pfes', distinct=True, filter=Q(pfes__type='P', pfes__groupe__section__formation__annee_univ=annee, pfes__groupe__soutenance__date__isnull=False, pfes__groupe__section__formation__programme__matiere_equipe__isnull=True)))\
                                    .annotate(nb_president=Count('president', distinct=True, filter=Q(president__groupe__pfe__type='P', president__groupe__section__formation__annee_univ=annee, president__groupe__section__formation__programme__matiere_equipe__isnull=True)))\
                                    .annotate(nb_examinateur=Count('examinateur', distinct=True, filter=Q(examinateur__groupe__pfe__type='P', examinateur__groupe__section__formation__annee_univ=annee, examinateur__groupe__section__formation__programme__matiere_equipe__isnull=True)))\
                                    .annotate(nb_rapporteur=Count('rapporteur', distinct=True, filter=Q(rapporteur__groupe__pfe__type='P', rapporteur__groupe__section__formation__annee_univ=annee, rapporteur__groupe__section__formation__programme__matiere_equipe__isnull=True)))\
                                    .annotate(nb_assesseur=Count('assesseur1', distinct=True, filter=Q(assesseur1__groupe__pfe__type='P', assesseur1__groupe__section__formation__annee_univ=annee, assesseur1__groupe__section__formation__programme__matiere_equipe__isnull=True))+Count('assesseur2', distinct=True, filter=Q(assesseur2__groupe__pfe__type='P', assesseur2__groupe__section__formation__annee_univ=annee, assesseur2__groupe__section__formation__programme__matiere_equipe__isnull=True)))\
                                    .order_by('nom', 'prenom')

            stats_master_par_enseignant=Enseignant.objects.all()\
                                    .annotate(nb_president=Count('president', distinct=True, filter=Q(president__groupe__pfe__type='M', president__groupe__section__formation__annee_univ=annee, president__groupe__section__formation__programme__matiere_equipe__isnull=True)))\
                                    .annotate(nb_examinateur=Count('examinateur', distinct=True, filter=Q(examinateur__groupe__pfe__type='M', examinateur__groupe__section__formation__annee_univ=annee, examinateur__groupe__section__formation__programme__matiere_equipe__isnull=True)))\
                                    .annotate(nb_rapporteur=Count('rapporteur', distinct=True, filter=Q(rapporteur__groupe__pfe__type='M', rapporteur__groupe__section__formation__annee_univ=annee, rapporteur__groupe__section__formation__programme__matiere_equipe__isnull=True)))\
                                    .annotate(nb_assesseur=Count('assesseur1', distinct=True, filter=Q(assesseur1__groupe__pfe__type='M', assesseur1__groupe__section__formation__annee_univ=annee, assesseur1__groupe__section__formation__programme__matiere_equipe__isnull=True))+Count('assesseur2', distinct=True, filter=Q(assesseur2__groupe__pfe__type='M', assesseur2__groupe__section__formation__annee_univ=annee, assesseur2__groupe__section__formation__programme__matiere_equipe__isnull=True)))\
                                    .order_by('nom', 'prenom')
            dict_={
                'stats_pfe_par_enseignant' : stats_pfe_par_enseignant,
                'stats_master_par_enseignant' : stats_master_par_enseignant,
            }
            stats_par_annee[annee]=dict_
        context['stats_par_annee']=stats_par_annee
        
        return context


@login_required
def organisme_select_for_offre_create(request):
    if not activation_offres() :
        return HttpResponseRedirect(reverse('home'))
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = SelectOrCreateOrganismeOffreForm(request.POST)
        # check whether it's valid:
        if form.is_valid():
            data=form.cleaned_data
            
            if data['organisme'] :
                return HttpResponseRedirect(reverse('offre_create_with_selected_organisme', kwargs={'organisme_pk': data['organisme'].sigle})) 
            else :
                return HttpResponseRedirect(reverse('offre_create'))
        else:
            return render(request, 'scolar/import.html', {'form': form, 'titre':"Sélectionner ou créer un organisme"})
    # if a GET (or any other method) we'll create a blank form
    else:
        form = SelectOrCreateOrganismeOffreForm()
        
        messages.info(request, "Merci de sélectionner l'organisme dont est issue l'offre. Si l'offre est issue d'un particulier, laissez le champs vide.")
        messages.info(request, "Si l'organisme recherché n'existe pas, merci de le créer.")
        return render(request, 'scolar/import.html', {'form': form, 'titre':"Sélectionner ou créer un organisme"})

@login_required
def organisme_create_for_offre_create(request):
    if not activation_offres() :
        return HttpResponseRedirect(reverse('home'))
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = OrganismeForm(request.POST)
        # check whether it's valid:
        if form.is_valid():
            organisme=form.save()
            # redirect to a new URL:
            return HttpResponseRedirect(reverse('offre_create_with_selected_organisme', kwargs={'organisme_pk': organisme.sigle})) 
        else:
            return render(request, 'scolar/import.html', {'form': form, 'titre':"Créer un organisme"})
    # if a GET (or any other method) we'll create a blank form
    else:
        form = OrganismeForm()
        messages.info(request, "Merci d'utiliser ce formulaire pour créer un nouvel organisme")
        return render(request, 'scolar/import.html', {'form': form, 'titre':"Créer un organisme"})

class OffreCreateView(LoginRequiredMixin, UserPassesTestMixin, SuccessMessageMixin, CreateView):
    model = Offre
    fields = ['user', 'emetteur', 'type', 'intitule', 'specialites', 'organisme', 'description', 'fichier1', 'fichier2', 'fichier3', 'statut', 'activation_candidatures', 'notification']
    template_name = 'scolar/create.html'
    success_message = "L'offre a bien été soumise. Elle sera publiée après validation par un administrateur."
    
    def test_func(self):
        return activation_offres()
            
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.fields['user']=forms.ModelChoiceField(
                queryset=User.objects.all().order_by('username'),
                label=u"Offre déposée par",
                widget=ModelSelect2Widget(
                        model=User,
                        search_fields=['username__icontains', 'email__icontains'],
    
                    ),
                required = False,
                initial=self.request.user,
                disabled=not self.request.user.has_perm('scolar.fonctionnalitenav_offres_validation')
            )
        form.fields['emetteur'].initial=self.request.user.get_email()+' '+self.request.user.nom()+' '+self.request.user.prenom()
        form.fields['emetteur'].widget = forms.Textarea(attrs={'rows':1})
        form.fields['emetteur'].help_text="Indiquez le nom de la source réelle de l'offre si elle ne provient pas de vous. Si vous avez d'autres informations telles que l'URL de l'offre, veuillez les renseigner dans le champs de description."
        form.fields['intitule'].widget = forms.Textarea(attrs={'rows':1})
        form.fields['organisme']=forms.ModelChoiceField(
                queryset=Organisme.objects.all(),
                initial=self.kwargs.get("organisme_pk") if self.kwargs.get("organisme_pk") else None,
                disabled=True if self.kwargs.get("organisme_pk") else False,
                required=False,
            )
        
        form.fields['specialites']=forms.ModelMultipleChoiceField(
            queryset = Specialite.objects.all(),
            widget=ModelSelect2MultipleWidget(
                model=Specialite,
                search_fields=['code__icontains','intitule__icontains'],
            ),
            label='Spécialités ciblées (facultatif)',
            required=False,
            help_text="Tapez deux espaces pour avoir la liste des spécialités et cursus. Vous pouvez sélectionner les éléments ciblés par l'offre (facultatif). "
        )

        form.fields['description'].widget = forms.Textarea(attrs={'rows':20})
        
        if not self.request.user.has_perm('scolar.fonctionnalitenav_offres_validation') :
            form.fields['statut'].disabled=True
            form.fields['statut'].label="Statut initial après dépôt"

        form.helper.add_input(Submit('submit','Ajouter', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        
        self.success_url = reverse('user_offre_list')
        return form
    
    def get_context_data(self, **kwargs):
        context = super(OffreCreateView, self).get_context_data(**kwargs)
        context['titre'] = 'Publier une offre'
        return context
    
    def form_valid(self, form):
        self.object = form.save()
        offre_=self.object
        offre_.date=timezone.now()
        offre_.save(update_fields=['date',])
        try :
            for user_ in users_offres_institution() :
                trace_create(self.request.user, user_, "[Notification] Dépôt d'une nouvelle offre.\n"+
                                                        "Type : "+dict(TYPE_OFFRE)[offre_.type]+"\n"+
                                                        "Intitulé : "+str(offre_.intitule)+"\n"+
                                                        "Déposant : "+str(self.request.user)+" - "+self.request.user.nom()+" "+self.request.user.prenom()+"\n"+
                                                        "Statut initial : "+dict(STATUT_OFFRE)[offre_.statut]+"\n"+
                                                        "Lien de visualisation : "+settings.PROTOCOLE_HOST+reverse('offre_detail', kwargs={'pk':offre_.id})+"\n"+
                                                        "Lien de modification : "+settings.PROTOCOLE_HOST+reverse('offre_update', kwargs={'pk':offre_.id}))

            if activation_emails():
                email = EmailMessage("[Talents] Dépôt d'une nouvelle offre",
                                     'Bonjour,\n'+
                                     "Une nouvelle offre a été déposée sur Talents (en attente de vérification) : "+offre_.intitule+"\n"+
                                     "Type : "+dict(TYPE_OFFRE)[offre_.type]+"\n"+
                                     "Déposant : "+str(self.request.user)+" - "+self.request.user.nom()+" "+self.request.user.prenom()+"\n"+
                                     "Lien de visualisation : "+settings.PROTOCOLE_HOST+reverse('offre_detail', kwargs={'pk':offre_.id})+"\n"+
                                     "Lien de modification/validation : "+settings.PROTOCOLE_HOST+reverse('offre_update', kwargs={'pk':offre_.id})+"\n"+
                                     "Vous êtes invité(e) à vérifier l'offre et la basculer à l'état 'Ouverte' pour qu'elle soit visible par tous les utilisateurs de Talents"+"\n"+
                                     'Cordialement', to=email_offres() )
                email.send(fail_silently=True)
        
        except Exception :
            pass
        return HttpResponseRedirect(self.get_success_url())

class OffreListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name = 'scolar/filter_list.html'
    
    def test_func(self):
        return activation_offres()
    
    def get_context_data(self, **kwargs):
        context = super(OffreListView, self).get_context_data(**kwargs)

        #filter_ = PFEFilter(self.request.GET, queryset=PFE.objects.filter(groupe__isnull=True).order_by('id'))
        if self.request.user.has_perm('scolar.fonctionnalitenav_offres_validation') :
            filter_ = OffreFilter(self.request.GET, queryset=Offre.objects.all().order_by('-id'))
        else :
            filter_ = OffreFilter(self.request.GET, queryset=Offre.objects.all().exclude(Q(statut='C')|Q(statut='N')).order_by('-id'))
        filter_.form.helper = FormHelper()
        exclude_columns_=[]
        if not self.request.user.is_authenticated:
            exclude_columns_.append('edit')
        else :
            if not self.request.user.has_perm('scolar.fonctionnalitenav_offres_validation') :
                exclude_columns_.append('edit')
        table = OffreTable(filter_.qs, exclude=exclude_columns_)
        RequestConfig(self.request).configure(table)
            
        context['filter'] = filter_
        context['table'] = table
        context['titre'] = "Liste des offres"
        btn_list={}
        if self.request.user.is_authenticated:
            btn_list.update({'Nouvelle Offre':reverse('organisme_select_for_offre_create')})
        context['btn_list']=btn_list
        return context
    
class OffreDetailView(UserPassesTestMixin, TemplateView):
    template_name = 'scolar/offre_detail.html'

    def test_func(self):
        if not activation_offres() :  
            return False
        offre_=get_object_or_404(Offre, id=self.kwargs.get("pk"))  
        if offre_.statut=='C' or offre_.statut=='N' :
            if not self.request.user.is_authenticated :
                return False
            if self.request.user.has_perm('scolar.fonctionnalitenav_offres_validation') :
                return True
            elif offre_.user and self.request.user == offre_.user :
                return True
            else :
                return False
        else :
            return self.request.user.is_authenticated
        
    def get_context_data(self, **kwargs):
        context = super(OffreDetailView, self).get_context_data(**kwargs)
        titre='Offre N°: '+ self.kwargs.get("pk")
        context['titre'] = titre
        offre_=get_object_or_404(Offre, id=self.kwargs.get("pk"))
        context['offre_form'] = OffreDetailForm(instance=offre_)
        fichiers=[]
        if offre_.fichier1 :
            fichiers.append(offre_.fichier1)
        if offre_.fichier2 :
            fichiers.append(offre_.fichier2)
        if offre_.fichier3 :
            fichiers.append(offre_.fichier3)
        context['fichiers']=fichiers
        context['offre']=offre_

        exclude_columns_=[]
        if (not self.request.user.has_perm('scolar.fonctionnalitenav_offres_validation')):
            exclude_columns_.append('edit')

        table = CandidatureTable(Candidature.objects.filter(offre=offre_).order_by('-id'))
        RequestConfig(self.request).configure(table)
        context['candidature_table'] = table


        return context
        

class OffreUpdateView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, UpdateView):
    model = Offre
    template_name = 'scolar/update.html'
    success_message = "L'offre a été modifiée avec succès!"
    fields='__all__'
    
    def test_func(self):
        if not activation_offres() :  
            return False
        offre_=get_object_or_404(Offre, id=self.kwargs.get("pk"))  
        if not self.request.user.is_authenticated :
            return False
        if self.request.user.has_perm('scolar.fonctionnalitenav_offres_validation') :
            return True
        elif offre_.user and self.request.user == offre_.user :
            return True
        else :
            return False
        
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        offre_=get_object_or_404(Offre, id=self.kwargs.get("pk"))  
        edit_restreint=False
        
        if not self.request.user.has_perm('scolar.fonctionnalitenav_offres_validation') :
            edit_restreint=True
        
        form.fields['emetteur'].widget = forms.Textarea(attrs={'rows':1})
        form.fields['date'] = forms.DateField(label='Date de dépôt', input_formats = settings.DATE_INPUT_FORMATS, widget=DatePickerInput(format='%d/%m/%Y'), initial=offre_.date, required=False) 
            
        if edit_restreint :
            if not (offre_.statut == 'C' or offre_.statut == 'N') :
                form.fields['statut'].choices = set(STATUT_OFFRE) ^ set((('C', 'Offre en attente de vérification par un administrateur'),('N', 'Offre rejetée par un administrateur'),))
            else :
                form.fields['statut'].disabled=True 
            form.fields['date'].disabled=True  
                
        form.fields['user']=forms.ModelChoiceField(
                queryset=User.objects.all().order_by('username'),
                label=u"Offre déposée par",
                widget=ModelSelect2Widget(
                        model=User,
                        search_fields=['username__icontains', 'email__icontains'],
    
                    ),
                required = False,
                disabled=not self.request.user.has_perm('scolar.fonctionnalitenav_offres_validation')
            )

        form.fields['intitule'].widget = forms.Textarea(attrs={'rows':1})
        form.fields['organisme']=forms.ModelChoiceField(
                queryset=Organisme.objects.all(),
                disabled=True if self.kwargs.get("organisme_pk") else False,
                required=False,
            )
        
        form.fields['specialites']=forms.ModelMultipleChoiceField(
            queryset = Specialite.objects.all(),
            widget=ModelSelect2MultipleWidget(
                model=Specialite,
                search_fields=['code','intitule'],
            ),
            label='Spécialités ciblées (facultatif)',
            required=False,
            help_text="Tapez deux espaces pour avoir la liste des spécialités et cursus. Vous pouvez sélectionner les éléments ciblés par l'offre (facultatif). "
        )

        form.fields['description'].widget = forms.Textarea(attrs={'rows':20})
        form.helper.add_input(Submit('submit','Modifier', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        
        if offre_.user and self.request.user == offre_.user :
            self.success_url = reverse('user_offre_list')
        else :
            self.success_url = reverse('offre_list')
            
        return form

    def form_valid(self, form):
        offre_=self.object
        response = super().form_valid(form)
        try :
            for user_ in users_offres_institution() :
                trace_create(self.request.user, user_, "[Notification] Modification d'une offre.\n"+
                                                        "Type : "+dict(TYPE_OFFRE)[offre_.type]+"\n"+
                                                        "Intitulé : "+str(offre_.intitule)+"\n"+
                                                        "Modification par : "+str(self.request.user)+" - "+self.request.user.nom()+" "+self.request.user.prenom()+"\n"+
                                                        "Statut actuel : "+dict(STATUT_OFFRE)[offre_.statut]+"\n"+
                                                        "Lien de visualisation : "+settings.PROTOCOLE_HOST+reverse('offre_detail', kwargs={'pk':offre_.id})+"\n"+
                                                        "Lien de modification : "+settings.PROTOCOLE_HOST+reverse('offre_update', kwargs={'pk':offre_.id}))
            
            if offre_.user and (offre_.user != self.request.user) :
                trace_create(self.request.user, offre_.user, "Votre offre : "+str(offre_.intitule)+"\n"+
                                                             "A été actualisée."+"\n"+
                                                             "Statut actuel : "+dict(STATUT_OFFRE)[offre_.statut])
                if offre_.notification :
                    if activation_emails():
                        email = EmailMessage("[Talents] Actualisation de votre offre",
                                             'Bonjour,\n'+
                                             "Votre offre : "+str(offre_.intitule)+"\n"+
                                             "A été actualisée."+"\n"+
                                             "Statut actuel : "+dict(STATUT_OFFRE)[offre_.statut]+"\n"+
                                             "Lien de visualisation : "+settings.PROTOCOLE_HOST+reverse('offre_detail', kwargs={'pk':offre_.id})+"\n"+
                                             'Cordialement', to=[offre_.user.get_email() if offre_.user.get_email() else ''] )
                        email.send(fail_silently=True)
        
        except Exception :
            pass
        return response
  
class OffreDeleteView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, DeleteView):
    model = Offre
    template_name = 'scolar/delete.html'
    success_message = "L'offre a bien été supprimée."

    def test_func(self):
        offre_=get_object_or_404(Offre, id=self.kwargs.get("pk"))  
        if not self.request.user.is_authenticated :
            return False
        if self.request.user.has_perm('scolar.fonctionnalitenav_offres_validation') :
            return True
        elif offre_.user and self.request.user == offre_.user :
            return True
        else :
            return False
        
    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, None, "Suppression de l'offre : "+str(object_))
        return super(OffreDeleteView, self).delete(*args, **kwargs)
        
    def get_success_url(self):
        messages.success(self.request, self.success_message)
        if self.request.user.has_perm('scolar.fonctionnalitenav_offres_validation') :
            return reverse('offre_list')
        else :
            return reverse('user_offre_list')

class UserOffreListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name = 'scolar/list.html'
    
    def test_func(self):
        return activation_offres()
    
    def get_context_data(self, **kwargs):
        context = super(UserOffreListView, self).get_context_data(**kwargs)
        exclude_=[]     
        offre_table = OffreTable(Offre.objects.filter(user=self.request.user).order_by('-id'), exclude=exclude_)
        context['table'] = offre_table
        context['titre'] = "Mes offres"
        context['btn_list'] = {
                'Nouvelle Offre':reverse('organisme_select_for_offre_create')
            }
        return context

class UserCandidatureListView(LoginRequiredMixin, UserPassesTestMixin, TemplateView):
    template_name = 'scolar/list.html'
    
    def test_func(self):
        return activation_offres()
    
    def get_context_data(self, **kwargs):
        context = super(UserCandidatureListView, self).get_context_data(**kwargs)
        exclude_=[]     
        candidature_table = CandidatureTable(Candidature.objects.filter(user=self.request.user).order_by('-id'), exclude=exclude_)
        context['table'] = candidature_table
        context['titre'] = "Mes candidatures"
        context['btn_list'] = {}
        return context


class CandidatureCreateView(LoginRequiredMixin, UserPassesTestMixin, SuccessMessageMixin, CreateView):
    model = Candidature
    fields = ['user', 'nom', 'prenom', 'offre', 'reponse', 'competences', 'motivations', 'cv', 'fichier1', 'acces_profil']
    template_name = 'scolar/create.html'
    success_message = "Votre candidature a bien été transmise à l'émetteur de l'offre."
    
    def test_func(self):
        if not activation_offres() :
            return False
        offre_= get_object_or_404(Offre, id=int(self.kwargs.get("offre_pk")))
        if not offre_.activation_candidatures :
            return False
        if (self.request.user == offre_.user) or (offre_.statut != 'S'):
            return False
        if Candidature.objects.filter(offre=offre_, user=self.request.user).exists() :
            messages.warning(self.request, "Vous avez déjà candidaté pour cette offre. Vous pouvez modifier votre candidature dans votre espace.")
            return False
        return True
            
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        form.fields['user']=forms.ModelChoiceField(
                queryset=User.objects.all().order_by('username'),
                label=u"Candidature par",
                widget=ModelSelect2Widget(
                        model=User,
                        search_fields=['username__icontains', 'email__icontains'],
    
                    ),
                required = False,
                initial=self.request.user,
                disabled=True
            )
        form.fields['nom'].initial=self.request.user.nom()
        form.fields['prenom'].initial=self.request.user.prenom()
        form.fields['offre']=forms.ModelChoiceField(
                queryset=Offre.objects.all(),
                required=False,
                disabled=True,
                label=u"Candidature à l'offre suivante",
                initial=get_object_or_404(Offre, id=int(self.kwargs.get("offre_pk"))),
            )

        form.helper.add_input(Submit('submit','Candidater', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        
        self.success_url = reverse('user_candidature_list')
        return form
    
    def get_context_data(self, **kwargs):
        context = super(CandidatureCreateView, self).get_context_data(**kwargs)
        context['titre'] = 'Candidater à l\'offre'
        return context
    
    def form_valid(self, form):
        self.object = form.save()
        candidature_=self.object
        offre_=candidature_.offre
        try :
            trace_create(self.request.user, offre_.user, "[Notification] Une nouvelle candidature a été formulée pour votre offre.\n"+
                                                    "Offre : "+str(offre_)+"\n"+
                                                    "Intitulé : "+str(offre_.intitule)+"\n"+
                                                    "Candidat : "+str(self.request.user)+" - "+self.request.user.nom()+" "+self.request.user.prenom()+"\n"+
                                                    "Lien de visualisation : "+settings.PROTOCOLE_HOST+reverse('candidature_detail', kwargs={'pk':candidature_.id}))

            if offre_.notification and activation_emails():
                email = EmailMessage("[Talents] Une nouvelle candidature a été formulée pour votre offre",
                                     'Bonjour,\n'+
                                     "Une nouvelle candidature a été formulée pour votre offre : "+offre_.intitule+"\n"+
                                     "Candidat : "+str(self.request.user)+" - "+self.request.user.nom()+" "+self.request.user.prenom()+"\n"+
                                     "Lien de visualisation : "+settings.PROTOCOLE_HOST+reverse('candidature_detail', kwargs={'pk':candidature_.id})+"\n"+
                                     'Cordialement', to=[offre_.user.get_email() if (offre_.user and offre_.user.get_email()) else ''] )
                email.send(fail_silently=True)
        
        except Exception :
            pass
        return HttpResponseRedirect(self.get_success_url())
    
class CandidatureUpdateView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, UpdateView):
    model = Candidature
    template_name = 'scolar/update.html'
    success_message = "La candidature a été modifiée avec succès!"
    fields='__all__'
    
    def test_func(self):
        if not activation_offres() :  
            return False
        candidature_=get_object_or_404(Candidature, id=self.kwargs.get("pk"))  
        if not self.request.user.is_authenticated :
            return False
        elif candidature_.user and self.request.user == candidature_.user :
            return True
        else :
            return False
        
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        candidature_=get_object_or_404(Candidature, id=self.kwargs.get("pk"))  

        form.fields['user']=forms.ModelChoiceField(
                queryset=User.objects.all().order_by('username'),
                label=u"Candidature par",
                widget=ModelSelect2Widget(
                        model=User,
                        search_fields=['username__icontains', 'email__icontains'],
    
                    ),
                required = False,
                disabled=True
            )
    
        form.fields['date_time'].disabled=True
        form.fields['last_edit'].disabled=True
        form.fields['offre'].disabled=True

        form.helper.add_input(Submit('submit','Modifier', css_class='btn-primary'))
        form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
        
        self.success_url = reverse('user_candidature_list')
            
        return form

    def form_valid(self, form):
        self.object = form.save()
        candidature_=self.object
        candidature_.last_edit=timezone.now()
        candidature_.save(update_fields=['last_edit'])
        offre_=candidature_.offre
        try :
            trace_create(self.request.user, offre_.user, "[Notification] Une candidature a été modifiée pout votre offre.\n"+
                                                    "Offre : "+str(offre_)+"\n"+
                                                    "Intitulé : "+str(offre_.intitule)+"\n"+
                                                    "Candidature modifiée par : "+str(self.request.user)+" - "+self.request.user.nom()+" "+self.request.user.prenom()+"\n"+
                                                    "Lien de visualisation : "+settings.PROTOCOLE_HOST+reverse('candidature_detail', kwargs={'pk':candidature_.id}))

            if offre_.notification and activation_emails():
                email = EmailMessage("[Talents] Une candidature a été modifiée pout votre offre",
                                     'Bonjour,\n'+
                                     "Une candidature a été modifiée pour votre offre : "+offre_.intitule+"\n"+
                                     "Candidature modifiée par : "+str(self.request.user)+" - "+self.request.user.nom()+" "+self.request.user.prenom()+"\n"+
                                     "Lien de visualisation : "+settings.PROTOCOLE_HOST+reverse('candidature_detail', kwargs={'pk':candidature_.id})+"\n"+
                                     'Cordialement', to=[offre_.user.get_email() if (offre_.user and offre_.user.get_email()) else ''] )
                email.send(fail_silently=True)

        except Exception :
            pass
        return HttpResponseRedirect(self.get_success_url())

class CandidatureDeleteView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, DeleteView):
    model = Candidature
    template_name = 'scolar/delete.html'
    success_message = "La candidature a bien été supprimée."

    def test_func(self):
        if not activation_offres() :  
            return False
        candidature_=get_object_or_404(Candidature, id=self.kwargs.get("pk"))  
        if not self.request.user.is_authenticated :
            return False
        elif self.request.user.has_perm('scolar.fonctionnalitenav_offres_validation') or candidature_.user and self.request.user == candidature_.user :
            return True
        else :
            return False
        
    def delete(self, *args, **kwargs):
        object_=self.get_object()
        trace_create(self.request.user, object_.offre.user if object_.offre.user else None, "Suppression de la candidature : "+str(object_))
        return super(CandidatureDeleteView, self).delete(*args, **kwargs)
        
    def get_success_url(self):
        messages.success(self.request, self.success_message)
        if self.request.user.has_perm('scolar.fonctionnalitenav_offres_validation') :
            return reverse('offre_list')
        else :
            return reverse('user_candidature_list')

class CandidatureDetailView(UserPassesTestMixin, TemplateView):
    template_name = 'scolar/candidature_detail.html'

    def test_func(self):
        if not activation_offres() :  
            return False
        candidature_=get_object_or_404(Candidature, id=self.kwargs.get("pk"))  
        if not self.request.user.is_authenticated :
            return False
        if self.request.user.has_perm('scolar.fonctionnalitenav_offres_validation') :
            return True
        if candidature_.offre and candidature_.offre.user and (candidature_.offre.user == self.request.user) :
            return True
        if candidature_.user and (self.request.user == candidature_.user) :
            return True
        return False
        
    def get_context_data(self, **kwargs):
        context = super(CandidatureDetailView, self).get_context_data(**kwargs)
        candidature_=get_object_or_404(Candidature, id=self.kwargs.get("pk"))
        titre='Candidature pour l\'offre : '+ str(candidature_.offre)
        context['titre'] = titre
        context['candidature_form'] = CandidatureDetailForm(instance=candidature_)
        if candidature_.cv :
            context['cv']=candidature_.cv
        fichiers=[]
        if candidature_.fichier1 :
            fichiers.append(candidature_.fichier1)
        context['fichiers']=fichiers
        context['candidature']=candidature_
        return context

def demande_compte_view(request):
    if not get_institution().activation_demandes_comptes :
        messages.error(request,"Vous n'avez pas les permissions pour effectuer cette opération.")
        return redirect('/accounts/login/?next=%s' % request.path)
        
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = DemandeCompteForm(request.POST, request.FILES)
        # check whether it's valid:
        if form.is_valid():
            try:
                data=form.cleaned_data
                email=str(data['email'])
                nom=str(data['nom'])
                prenom=str(data['prenom'])
                motif=str(data['motif'])
                for user_ in users_demandes_comptes() :
                    trace_create(None, user_, "Nouvelle demande de création d'un compte pour le dépôt des stages, offres, etc.\n"+
                                              "Si vous approuvez la demande ci-dessous, veuillez créer manuellement le compte via : \n"+
                                               settings.PROTOCOLE_HOST+reverse('partenaire_create')+"\n"+
                                               "Détails de la demande : \n"+
                                               "Nom : "+nom+"\n"+
                                               "Prénom(s) : "+prenom+"\n"+
                                               "Email : "+email+"\n"+
                                               "Motif de la demande : "+motif)
                
                messages.success(request, "Votre demande de création d'un compte a bien été transmise. Vous recevrez une réponse dans les plus brefs délais")
                if activation_emails():
                    email = EmailMessage("[Talents] Demande de création d'un compte",
                                         'Bonjour,\n'+
                                         "Une nouvelle demande de création d'un compte pour le dépôt des stages, offres, etc. a été formulée\n"+
                                         "Si vous approuvez la demande ci-dessous, veuillez créer manuellement le compte (afin d'envoyer automatiquement les identifiants au demandeur par e-mail) via : \n"+
                                         settings.PROTOCOLE_HOST+reverse('partenaire_create')+"\n"+
                                         "Détails de la demande : \n"+
                                         "Nom : "+nom+"\n"+
                                         "Prénom(s) : "+prenom+"\n"+
                                         "Email : "+email+"\n"+
                                         "Motif de la demande : "+motif+"\n"
                                         'Cordialement', to=email_demandes_comptes())
                    email.send(fail_silently=True)
                
                
            except Exception:
                if settings.DEBUG:
                    raise Exception
                else:
                    messages.error(request, "Une erreur est survenue lors de la demande d'enregistrement.")
                    return render(request, 'scolar/create.html', {'form': form })
                
            return HttpResponseRedirect(reverse('home'))
    # if a GET (or any other method) we'll create a blank form
    else:
        form = DemandeCompteForm()
        messages.info(request, "Utilisez ce formulaire pour demander un compte dans la plateforme.")
        messages.warning(request, mark_safe("Une fois votre demande de création de compte validée, vous recevrez par e-mail vos informations d'authentification sur la plateforme. Vous pourrez ensuite utiliser votre compte pour :<br>- Déposer des sujets de fin d'études<br>- Déposer des offres (emplois, thèses, stages pratiques, etc.) visibles par tous les membres de l'institution (diplômés, étudiants, enseignants, chercheurs..)"))
        messages.warning(request, "Si vous êtes un utilisateur existant, veuillez plutôt vous authentifier afin d'accéder à cet espace.")
    context={}  
    context['form']=form
    return render(request, 'scolar/create.html', context)

class GoogleCalendarListView(TemplateView):
    template_name = 'scolar/filter_list.html'
    
    def get_context_data(self, **kwargs):
        context = super(GoogleCalendarListView, self).get_context_data(**kwargs)
       
        filter_ = GoogleCalenderFilter(self.request.GET, queryset=GoogleCalendar.objects.all())
  
        filter_.form.helper = FormHelper()
#         exclude_columns_ = exclude_columns(self.request.user)
        exclude_=[]
        table = GoogleCalenderTable(filter_.qs, exclude=exclude_)

        RequestConfig(self.request).configure(table)
        
        context['filter'] = filter_
        context['table'] = table
        context['titre'] = "Google Calender"
        context['btn_list'] = {
                 'Lier groupe':reverse('googlecalendar_create')
            }
        return context

class GoogleCalendarCreateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, CreateView):
    permission_required = 'scolar.fonctionnalitenav_planification_liaisongroupeetagenda'
    model = GoogleCalendar
    fields = ['code', 'calendarId']
    template_name = 'scolar/create.html'
    success_message = "Le calendrier a été ajouté avec succés!"

    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        try:
            form.fields['code'] = forms.CharField(
                max_length=20, 
                required=True,
               )
            form.fields['calendarId'] = forms.CharField(
                max_length=1000, 
                required=True,
               )

            form.helper.add_input(Submit('submit', 'Ajouter', css_class='btn-primary'))
            form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
            self.success_url = reverse('googlecalendar_list')
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors de la création d'un calendrier .")
   
        return form

    def get_context_data(self, **kwargs):
        context = super(GoogleCalendarCreateView, self).get_context_data(**kwargs)
        titre = 'Ajouter un calendrier'
        context['titre'] = titre
        return context
    
class GoogleCalendarUpdateView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, UpdateView):
    permission_required = 'scolar.fonctionnalitenav_planification_liaisongroupeetagenda'
    model = GoogleCalendar
    fields = ['code', 'calendarId']
    template_name = 'scolar/create.html'
    success_message = "Le calendrier a été modifié avec succés!"
 
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        try:
            form.helper.add_input(Submit('submit', 'Modifier', css_class='btn-warning'))
            form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
            self.success_url = reverse('googlecalendar_list')
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors de la modification d'un calendrier .")
   
        return form   
    
class GoogleCalendarDeleteView(LoginRequiredMixin, SuccessMessageMixin, PermissionRequiredMixin, DeleteView):
    model = GoogleCalendar
    template_name = 'scolar/delete.html'
    permission_required = 'scolar.fonctionnalitenav_planification_liaisongroupeetagenda'
    success_message = "Le calendrier a bien été supprimé"
 
    def get_success_url(self):
        return reverse('googlecalendar_list')   


class CPCreateView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, CreateView):
    model = CP
    fields = [ 'formation','periode','date_cp1','date_cp2','enseignants','delegues']
    permission_required = 'scolar.fonctionnalite_comite_pedagogique_gestion'
    template_name = 'scolar/create.html'
    success_message = "La Comité Pédagogique a été créé avec succès"
    
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalite_comite_pedagogique_gestion')
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        try:
         
            form.fields['formation']=forms.ModelChoiceField(queryset=Formation.objects.all())
            form.fields['periode']=forms.ModelChoiceField(queryset=Periode.objects.all())
            form.fields['date_cp1']=forms.DateField(label=u"Date du 1er cp",input_formats = settings.DATE_INPUT_FORMATS, widget=DatePickerInput(format='%d/%m/%Y'))
            form.fields['date_cp2']=forms.DateField(label=u"Date du 2eme cp", input_formats = settings.DATE_INPUT_FORMATS, widget=DatePickerInput(format='%d/%m/%Y'))
            
           
            form.fields['enseignants']=forms.ModelMultipleChoiceField(
                queryset = Enseignant.objects.all().order_by('nom'),
                widget=ModelSelect2MultipleWidget(
                    model=Enseignant,
                    search_fields=['nom__icontains','prenom__icontains'],
                ),
                required=False,
            ) 

            form.fields['delegues']=forms.ModelMultipleChoiceField(
                queryset = Etudiant.objects.all().order_by('nom'),
                widget=ModelSelect2MultipleWidget(
                    model=Etudiant,
                    search_fields=['nom__icontains','prenom__icontains'],
                ),
                required=False,
            ) 


            form.helper.add_input(Submit('submit','Enregistrer', css_class='btn-primary'))
            form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
            self.success_url =  reverse('comite_pedagogique_list')
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors de la création d'un cp.")
    
        return form
from django.forms import formset_factory
from django.forms import inlineformset_factory
from django.forms import modelformset_factory

class CPUpdateView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, UpdateView):
    model = CP
    fields = ['formation', 'periode', 'date_cp1', 'date_cp2', 'enseignants', 'delegues']
    permission_required = 'scolar.fonctionnalite_comite_pedagogique_gestion'
    template_name = 'stage/create.html'
    success_message = "La Comité Pédagogique a été bien mise à jour "
    success_url = '/scolar/comite_pedagogique'  


    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['cp_form'] = self.get_form()
        cp_instance = self.get_object()  

        OrdreDuJourFormSet = modelformset_factory(OrdreDuJour, form=OrdreDuJourForm, extra=1, can_delete=True)

        if self.request.method == 'POST':
            context['ordre_du_jour_cp1_formset'] = OrdreDuJourFormSet(self.request.POST, prefix='ordre_du_jour_cp1_formset', queryset=OrdreDuJour.objects.filter(cp=cp_instance, cp_type='cp1'))
            context['ordre_du_jour_cp2_formset'] = OrdreDuJourFormSet(self.request.POST, prefix='ordre_du_jour_cp2_formset', queryset=OrdreDuJour.objects.filter(cp=cp_instance, cp_type='cp2'))
        else:
            context['ordre_du_jour_cp1_formset'] = OrdreDuJourFormSet(prefix='ordre_du_jour_cp1_formset', queryset=OrdreDuJour.objects.filter(cp=cp_instance, cp_type='cp1'))
            context['ordre_du_jour_cp2_formset'] = OrdreDuJourFormSet(prefix='ordre_du_jour_cp2_formset', queryset=OrdreDuJour.objects.filter(cp=cp_instance, cp_type='cp2'))
        return context
    
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalite_comite_pedagogique_gestion')


    def form_valid(self, form):
        print(self.request.POST)

        context = self.get_context_data()
        ordre_du_jour_cp1_formset = context['ordre_du_jour_cp1_formset']
        ordre_du_jour_cp2_formset = context['ordre_du_jour_cp2_formset']

        if ordre_du_jour_cp1_formset.is_valid() and ordre_du_jour_cp2_formset.is_valid():
            self.object = form.save()

            ordres_cp1 = ordre_du_jour_cp1_formset.save(commit=False)
            for ordre in ordres_cp1:
                ordre.cp = self.object
                ordre.cp_type = 'cp1'
                ordre.save()

            ordres_cp2 = ordre_du_jour_cp2_formset.save(commit=False)
            for ordre in ordres_cp2:
                ordre.cp = self.object
                ordre.cp_type = 'cp2'
                ordre.save()

            ordre_du_jour_cp1_formset.save_m2m()
            ordre_du_jour_cp2_formset.save_m2m()
            
            for form in ordre_du_jour_cp1_formset.deleted_forms:
                form.instance.delete()
            for form in ordre_du_jour_cp2_formset.deleted_forms:
                form.instance.delete()

            return super().form_valid(form)
        else:
            return self.form_invalid(form)

class CPListView(LoginRequiredMixin, PermissionRequiredMixin, TemplateView):

    template_name='scolar/list.html'
    
    permission_required = 'scolar.fonctionnalite_comite_pedagogique_gestion' 
       
    def get_context_data(self, **kwargs):
        context = super(CPListView, self).get_context_data(**kwargs)
        exclude_=["delegues","enseignants"]
        table = CPTable(CP.objects.all(), exclude=exclude_)
        RequestConfig(self.request).configure(table)
        context['table'] = table

        btn_list={}
        btn_list['+ Créer']=reverse('comite_pedagogique_create')
        context['btn_list']=btn_list

        context['back'] = self.request.META.get('HTTP_REFERER')
        """if self.request.user.has_perm(''):
            context['create_url'] = reverse('anneeuniv_create')
            context['create_btn'] = 'Année'
            """
        return context

class RessourcesListView(LoginRequiredMixin, PermissionRequiredMixin, TemplateView):

    template_name='scolar/list.html'
    
    permission_required = 'scolar.fonctionnalite_ressources_gestion' 
       
    def get_context_data(self, **kwargs):
        context = super(RessourcesListView, self).get_context_data(**kwargs)
        table = RessourceTable(Ressource.objects.all())
        RequestConfig(self.request).configure(table)
        context['table'] = table

        btn_list={}
        btn_list['+ Créer']=reverse('ressource_create')
        context['btn_list']=btn_list

        context['back'] = self.request.META.get('HTTP_REFERER')

        return context

class RessourceCreateView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, CreateView):
    model = Ressource
    fields = [ 'nom','nombre']
    permission_required = 'scolar.fonctionnalite_ressources_gestion'
    template_name = 'scolar/create.html'
    success_message = "La ressource a été créé avec succès"
    
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalite_ressources_gestion')
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        try:
         

            form.helper.add_input(Submit('submit','Enregistrer', css_class='btn-primary'))
            form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
            self.success_url =  reverse('ressources_list')
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors de la création d'une ressource.")
    
        return form
    

class RessourceUpdateView(LoginRequiredMixin, SuccessMessageMixin, UserPassesTestMixin, UpdateView):
    model = Ressource
    fields = [ 'nom','nombre']
    permission_required = 'scolar.fonctionnalite_ressources_gestion'
    template_name = 'scolar/create.html'
    success_message = "La ressource a été bien mise à jour"
    
    def test_func(self):
        return self.request.user.has_perm('scolar.fonctionnalite_ressources_gestion')
    
    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        try:
         

            form.helper.add_input(Submit('submit','Enregistrer', css_class='btn-primary'))
            form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
            self.success_url =  reverse('ressources_list')
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors de la modification d'une ressource.")
    
        return form
class AllocationCreateView(LoginRequiredMixin, SuccessMessageMixin, CreateView):
    model = Allocation
    fields = ['ressource', 'date', 'heure_debut', 'heure_fin']
    template_name = 'scolar/create.html'
    success_message = "L'allocation a été créée avec succès"

    def form_valid(self, form):
        ens = Enseignant.objects.get(user= self.request.user)
        form.instance.enseignant = ens
        try:
            return super().form_valid(form)
        except ValidationError as e:
            form.add_error(None, e)
            return super().form_invalid(form)

    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        try:
            form.fields['ressource']=forms.ModelChoiceField(queryset=Ressource.objects.all())
            form.fields['date']=forms.DateField(label=u"Date",input_formats = settings.DATE_INPUT_FORMATS, widget=DatePickerInput(format='%d/%m/%Y'))
            form.fields['heure_debut'] = forms.TimeField(input_formats=['%H:%M'], widget=TimePickerInput(format='%H:%M'))
            form.fields['heure_fin'] = forms.TimeField(input_formats=['%H:%M'], widget=TimePickerInput(format='%H:%M'))
            form.helper.add_input(Submit('submit', 'Enregistrer', css_class='btn-primary'))
           
            form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
            self.success_url =  reverse('allocation_ressources_list')
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors de la modification d'une allocation.")
        return form


class AllocationUpdateView(LoginRequiredMixin,  SuccessMessageMixin, CreateView):
    model = Allocation
    fields = ['ressource', 'date', 'heure_debut', 'heure_fin']
    template_name = 'scolar/create.html'
    success_message = "L'allocation a été bien mise à jour"

    def form_valid(self, form):
        try:
            return super().form_valid(form)
        except ValidationError as e:
            form.add_error(None, e)
            return super().form_invalid(form)

    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        form.helper = FormHelper()
        try:
            form.fields['ressource']=forms.ModelChoiceField(queryset=Ressource.objects.all())
            form.fields['date']=forms.DateField(label=u"Date",input_formats = settings.DATE_INPUT_FORMATS, widget=DatePickerInput(format='%d/%m/%Y'))
            form.fields['heure_debut'] = forms.TimeField(input_formats=['%H:%M'], widget=TimePickerInput(format='%H:%M'))
            form.fields['heure_fin'] = forms.TimeField(input_formats=['%H:%M'], widget=TimePickerInput(format='%H:%M'))
            form.helper.add_input(Submit('submit', 'Enregistrer', css_class='btn-primary'))
           
            form.helper.add_input(Button('cancel', 'Annuler', css_class='btn-secondary', onclick="window.history.back()"))
            self.success_url =  reverse('allocation_ressources_list')
        except Exception:
            if settings.DEBUG:
                raise Exception
            else:
                messages.error(self.request, "ERREUR: lors de la modification d'une allocation.")
        return form
from django_tables2 import RequestConfig

class AllocationListView(LoginRequiredMixin, TemplateView):
    model = Allocation
    template_name = 'scolar/list.html'
    
    def test_func(self):
        user = self.request.user
        return (self.request.user.has_perm('scolar.fonctionnalite_ressources_gestion')) or (user.is_authenticated and user.is_enseignant())

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        
        # Create the allocation table and configure it
        table = AllocationTable(Allocation.objects.all())
        RequestConfig(self.request).configure(table)
        context['table'] = table

        btn_list = {}
        if self.request.user.is_authenticated and self.request.user.is_enseignant():
            btn_list['+ Créer'] = reverse('allocation_ressource_create')
        context['btn_list'] = btn_list
        context['back'] = self.request.META.get('HTTP_REFERER')

        return context

class GeneratePDFView(LoginRequiredMixin, UserPassesTestMixin,PDFTemplateView):
    # template_name = 'stage/test_pdf_stage_2.html'
    template_name = 'stage/pdf.html'

    
    cmd_options = {
        'orientation': 'Portrait',
        'page-size': 'A4',
        'enable-local-file-access': True,
        'quiet': False
        # 'header-html': 'stage/header.html',
        # 'footer-html': 'stage/footer.html'

    }
    def test_func(self):
        # Implement your test here
        # This is just an example, replace it with your actual test
        return self.request.user.is_authenticated

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)

        cp_id = self.kwargs.get('pk')

        cp = CP.objects.get(id=cp_id)
        print(f"CP: {cp}")

        formation = Formation.objects.get(id=cp.formation.id)
        print(f"Formation: {formation}")

        programme = Programme.objects.get(code=formation.programme.code)
        print(f"Programme: {programme}")

        periode_programmes = PeriodeProgramme.objects.filter(programme=programme)
        print(f"PeriodeProgrammes: {list(periode_programmes)}")

        ues = UE.objects.filter(periode__in=periode_programmes)
        print(f"UEs: {list(ues)}")

        matieres = Matiere.objects.filter(matiere_ues__in=ues).distinct()
        print(f"Matieres: {list(matieres)}")
        enseignants = list(cp.enseignants.all())
        delegues = list(cp.delegues.all())

        combined_list = []
        for i in range(max(len(enseignants), len(delegues))):
            combined_list.append({
                'enseignant': enseignants[i] if i < len(enseignants) else None,
                'delegue': delegues[i] if i < len(delegues) else None,
            })

        context['cp'] = cp
        context['matieres'] = matieres
        context['combined_list'] = combined_list

        self.filename='pv_du_cp.pdf'        
        return context